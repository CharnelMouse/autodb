% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dfd.r
\name{dfd}
\alias{dfd}
\title{DFD algorithm}
\usage{
dfd(
  df,
  accuracy,
  exclude = character(),
  exclude_class = character(),
  progress = 0L,
  progress_file = ""
)
}
\arguments{
\item{df}{a data.frame, the relation to evaluate.}

\item{accuracy}{a numeric in (0, 1]: the accuracy threshold required in order
to conclude a dependency.}

\item{exclude}{a character vector, containing names of attributes to not
consider as members of determinant sets. If names are given that aren't
present in \code{df}, the user is given a warning.}

\item{exclude_class}{a character vector, indicating classes of attributes to
not consider as members of determinant_sets. Attributes are excluded if
they inherit from any given class.}

\item{progress}{an integer, for whether to display progress to the user. 0
(default) displays nothing. 1 notes the start of finding each non-constant
attribute's determinant sets. 2 also briefly describes the status of the
search for an attribute's determinant sets when generating new seeds. 3
also gives the status after visiting each candidate determinant set / node.}

\item{progress_file}{a scalar character or a connection. If \code{progress}
is non-zero, determines where the progress is written to, in the same way
as the \code{file} argument for \code{\link[base]{cat}}.}
}
\value{
a named list with two elements. \code{dependencies} is a named list,
where the names give the dependent attribute, and each element is a list of
character vectors. Each character vector is a set of determinant attributes
for that dependent attribute. \code{attrs} is the column names of
\code{df}, in order. This is kept to serve as a default priority order for
the attributes during normalisation.
}
\description{
The DFD algorithm finds all the minimal functional dependencies represented
in a relation/table, represented here in a data.frame. Checks each column to
see if it's unique. If it is unique, it is added as the LHS of a dependency
for every other element. It then loops through all the other non-unique
columns and determines all the LHS that the column depends on. (LHS -->
column)
}
\details{
This implementation differs a little from the algorithm presented in the
original paper:
\itemize{
\item As was done in the original Python library, there is an extra case in
seed generation for when there are no discovered maximal non-dependencies.
In this case, we take all of the single-attribute nodes, then filter out by
minimal dependencies as usual. This is equivalent to taking the empty set
as the single maximal non-dependency.
\item There are three results when checking whether a candidate node is
minimal/maximal. TRUE indicates the node is minimal/maximal, as usual.
FALSE has been split into FALSE and NA. NA indicates that we can not yet
determine whether the node is minimal/maximal. FALSE indicates that we have
determined that it is not minimal/maximal, and we can set its category as
such. This is done by checking whether any of its adjacent
subsets/supersets are dependencies/non-dependencies, instead of waiting to
exhaust the adjacent subsets/supersets to visit when picking the next node
to visit.
\item Some attributes, or attribute types, can be designated, ahead of
time, as not being candidate members for determinant sets. This reduces the
number of candidate determinant sets to be searched, saving time by not
searching for determinant sets that the user would remove later anyway.
\item We do not yet preserve partitions, just their calculated sizes.
\item We do not yet keep hashmaps to manage subset/superset relationships,
as described in Section 3.5 of the original paper.
\item Missing values (NA) are treated as a normal value, with NA = NA being
true, and x = NA being false for any non-NA value of x.
}
}
