% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dfd.r
\name{dfd}
\alias{dfd}
\title{Dependency discovery with DFD}
\usage{
dfd(
  df,
  accuracy,
  cache = FALSE,
  exclude = character(),
  exclude_class = character(),
  progress = 0L,
  progress_file = ""
)
}
\arguments{
\item{df}{a data.frame, the relation to evaluate.}

\item{accuracy}{a numeric in (0, 1]: the accuracy threshold required in order
to conclude a dependency.}

\item{cache}{a logical, indicating whether to store information about how
sets of attributes group the table rows (stripped partitions). This is
expected to let the algorithm run more quickly, but might be inefficient
for small tables or small amounts of memory.}

\item{exclude}{a character vector, containing names of attributes to not
consider as members of determinant sets. If names are given that aren't
present in \code{df}, the user is given a warning.}

\item{exclude_class}{a character vector, indicating classes of attributes to
not consider as members of determinant_sets. Attributes are excluded if
they inherit from any given class.}

\item{progress}{an integer, for whether to display progress to the user. 0
(default) displays nothing. 1 notes the start of finding each non-constant
attribute's determinant sets. 2 also briefly describes the status of the
search for an attribute's determinant sets when generating new seeds. 3
also gives the status after visiting each candidate determinant set / node.}

\item{progress_file}{a scalar character or a connection. If \code{progress}
is non-zero, determines where the progress is written to, in the same way
as the \code{file} argument for \code{\link[base]{cat}}.}
}
\value{
A named list with two elements. \code{dependencies} is a named list,
where the names give the dependent attribute, and each element is a list of
character vectors. Each character vector is a set of determinant attributes
for that dependent attribute. \code{attrs} is the column names of
\code{df}, in order. This is kept to serve as a default priority order for
the attributes during normalisation.
}
\description{
The DFD algorithm finds all the minimal functional dependencies represented
in a relation/table, represented as a data frame.
}
\details{
Column names for \code{\link{df}} must be unique.

This implementation differs a little from the algorithm presented in the
original paper:
\itemize{
\item Some attributes, or attribute types, can be designated, ahead of
time, as not being candidate members for determinant sets. This reduces the
number of candidate determinant sets to be searched, saving time by not
searching for determinant sets that the user would remove later anyway.
\item Attributes that have a single unique value, i.e. are
constant, get attributed a single empty determinant set. In the standard
DFD algorithm, they would be assigned all the other non-excluded attributes
as length-one determinant sets. Assigning them the empty set distinguishes
them as constant, allowing for special treatment at normalisation and later
steps.
\item As was done in the original Python library, there is an extra case in
seed generation for when there are no discovered maximal non-dependencies.
In this case, we take all of the single-attribute nodes, then filter out by
minimal dependencies as usual. This is equivalent to taking the empty set
as the single maximal non-dependency.
\item There are three results when checking whether a candidate node is
minimal/maximal. TRUE indicates the node is minimal/maximal, as usual.
FALSE has been split into FALSE and NA. NA indicates that we can not yet
determine whether the node is minimal/maximal. FALSE indicates that we have
determined that it is not minimal/maximal, and we can set its category as
such. This is done by checking whether any of its adjacent
subsets/supersets are dependencies/non-dependencies, instead of waiting to
exhaust the adjacent subsets/supersets to visit when picking the next node
to visit.
\item We do not yet keep hashmaps to manage subset/superset relationships,
as described in Section 3.5 of the original paper.
\item Missing values (NA) are treated as a normal value, with NA = NA being
true, and x = NA being false for any non-NA value of x.
}
}
\references{
DFD paper.
}
