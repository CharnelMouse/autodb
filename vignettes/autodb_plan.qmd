---
title: "Planned improvements for autodb"
vignette: >
  %\VignetteIndexEntry{Planned improvements for autodb}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
    fig-width: 7
    fig-height: 5
---

```{r}
#| label: setup
library(autodb)
```

# Views for connected reference chains

When `autodb`, or `autoref`, generates foreign key references for relations decomposed from a single table, it naturally tends to a structure where there is a single low-level data relation on the left, and higher-level relations are "downstream" with respect to references, with the number of records strictly decreasing as we follow references to higher-level data relations.

```{.r}
#| label: nudge
show(reduce(
  autodb(
    nudge,
    remove_avoidable = TRUE,
    exclude_class = "numeric",
    exclude = "n_study"
  ),
  main = "study_id"
))
```

```{r}
#| echo: false
autodb(
  nudge,
  remove_avoidable = TRUE,
  exclude_class = "numeric",
  exclude = "n_study"
) |>
  reduce(main = "study_id") |>
  gv() |>
  write("nudge_reduced.gv")
```

```{dot}
//| file: nudge_reduced.gv
```

The nice thing about this is that, while the schema is created constructively, we can view it as a series of decompositions: start with the original table, split it up into two or more sub-tables, and repeat. Rejoining the database would then do this in reverse.

Unfortunately, not every set of functional dependencies allows this. Consider the following:

```{r}
#| label: nonconnected
#| echo: false
fds <- functional_dependency(
  list(
    list("a", "b"),
    list("a", "c"),
    list("b", "d"),
    list("c", "e"),
    list(c("d", "e"), "f")
  ),
  letters[1:6]
)
fds
```

Bernstein synthesis, and automatic foreign keys, give the following schema:

```{r}
#| label: nonconnected2
#| echo: false
schema <- normalise(fds)
write(gv(schema), "nonconnected.gv")
```

```{dot}
//| file: nonconnected.gv
```

The schema is not connected, because `d_e`'s key is not present in any other relation. In terms of a series of decompositions, we could think of the original table being split into `{a,b,c,d,e}` and `{d,e,f}` first, with a reference between them, and `d` and `e` being split off later, destroying the reference.

In short, while Boyes-Codd Normal Form may be the first normal form that can't always be satisfied with just relations, if we also want to keep all the relations related to each other with foreign key references for consistency, then third normal form also can't always be satisfied.

One way to solve this, which is a planned addition, is to allow virtual relations, also known as views. These are relations whose data is not stored, because it's generated from other relations that do store their data (real relations).

Usually, views are used to allow easy "look-up" of commonly-queried aggregates. Here, we could use them to maintain the connected schema structure. Here is a mockup of what the resulting schema might look like:

```{dot}
digraph {
  rankdir = "LR"
  node [shape=plaintext];

  "a" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">a</TD></TR>
    <TR><TD PORT="TO_a">a</TD><TD PORT="FROM_a" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_b">b</TD><TD PORT="FROM_b"></TD></TR>
    <TR><TD PORT="TO_c">c</TD><TD PORT="FROM_c"></TD></TR>
    </TABLE>>];
  "b" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">b</TD></TR>
    <TR><TD PORT="TO_b">b</TD><TD PORT="FROM_b" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_d">d</TD><TD PORT="FROM_d"></TD></TR>
    </TABLE>>];
  "c" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">c</TD></TR>
    <TR><TD PORT="TO_c">c</TD><TD PORT="FROM_c" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_e">e</TD><TD PORT="FROM_e"></TD></TR>
    </TABLE>>];
  "d_e" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">d_e</TD></TR>
    <TR><TD PORT="TO_d">d</TD><TD PORT="FROM_d" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_e">e</TD><TD PORT="FROM_e" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_f">f</TD><TD PORT="FROM_f"></TD></TR>
    </TABLE>>];
  "view" [label = <
    <TABLE BGCOLOR="lightgrey" BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="1">view</TD></TR>
    <TR><TD>a</TD></TR>
    <TR><TD>b</TD></TR>
    <TR><TD>c</TD></TR>
    <TR><TD>d</TD></TR>
    <TR><TD>e</TD></TR>
    <TR><TD>f</TD></TR>
    </TABLE>>];

  "a":FROM_b -> "b":TO_b;
  "a":FROM_c -> "c":TO_c;

  "view":TITLE -> "a":TITLE [arrowhead="empty" style="dashed"];
  "view":TITLE -> "d_e":TITLE [arrowhead="empty" style="dashed"];
}
```

Note that virtual relations have different rules to real relations:

- Virtual relations need not have a key. In this example, `view` does have `a` as a key, but this key can be inferred from the real relations it's a merging / joining of, so does not need to be stated explicitly.
- Virtual relations do not contain their own data: it's pulled in from the relations it merges together. This allows it to contain a set of attributes without being an instantiation of any functional dependencies between those attributes. For example, `view` contains `{a, b}`, but does not introduce a redundant instance of `{a} -> b` in addition to the one in relation `a`.
- Instead of foreign key references to keys in other relations, virtual relations just "refer" to the real relations they are a merging of.

This addition of virtual relations allows databases to always be connected as a tree. This is useful for visualisation, and for planning rejoins, since those can always be done by merging tables along foreign key references.

We could explicitly show *all* of the decomposition steps as virtual relations, but it's not clear that it's worth the bother:

```{dot}
digraph {
  rankdir = "LR"
  node [shape=plaintext];

  "a" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">a</TD></TR>
    <TR><TD PORT="TO_a">a</TD><TD PORT="FROM_a" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_b">b</TD><TD PORT="FROM_b"></TD></TR>
    <TR><TD PORT="TO_c">c</TD><TD PORT="FROM_c"></TD></TR>
    </TABLE>>];
  "b" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">b</TD></TR>
    <TR><TD PORT="TO_b">b</TD><TD PORT="FROM_b" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_d">d</TD><TD PORT="FROM_d"></TD></TR>
    </TABLE>>];
  "c" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">c</TD></TR>
    <TR><TD PORT="TO_c">c</TD><TD PORT="FROM_c" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_e">e</TD><TD PORT="FROM_e"></TD></TR>
    </TABLE>>];
  "d_e" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">d_e</TD></TR>
    <TR><TD PORT="TO_d">d</TD><TD PORT="FROM_d" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_e">e</TD><TD PORT="FROM_e" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_f">f</TD><TD PORT="FROM_f"></TD></TR>
    </TABLE>>];
  "view" [label = <
    <TABLE BGCOLOR="lightgrey" BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="1">view</TD></TR>
    <TR><TD>a</TD></TR>
    <TR><TD>b</TD></TR>
    <TR><TD>c</TD></TR>
    <TR><TD>d</TD></TR>
    <TR><TD>e</TD></TR>
    <TR><TD>f</TD></TR>
    </TABLE>>];
  "view2" [label = <
    <TABLE BGCOLOR="lightgrey" BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="1">view</TD></TR>
    <TR><TD>a</TD></TR>
    <TR><TD>b</TD></TR>
    <TR><TD>c</TD></TR>
    <TR><TD>d</TD></TR>
    <TR><TD>e</TD></TR>
    </TABLE>>];
  "view3" [label = <
    <TABLE BGCOLOR="lightgrey" BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="1">view</TD></TR>
    <TR><TD>a</TD></TR>
    <TR><TD>b</TD></TR>
    <TR><TD>c</TD></TR>
    <TR><TD>d</TD></TR>
    </TABLE>>];

  "a":FROM_b -> "b":TO_b;
  "a":FROM_c -> "c":TO_c;

  "view":TITLE -> "view2":TITLE [arrowhead="empty" style="dashed"];
  "view":TITLE -> "d_e":TITLE [arrowhead="empty" style="dashed"];
  "view2":TITLE -> "view3":TITLE [arrowhead="empty" style="dashed"];
  "view2":TITLE -> "c":TITLE [arrowhead="empty" style="dashed"];
  "view3":TITLE -> "a":TITLE [arrowhead="empty" style="dashed"];
  "view3":TITLE -> "b":TITLE [arrowhead="empty" style="dashed"];
}
```

# Boyes-Codd Normal Form

Another use of the virtual relations mentioned above is that they make BCNF always achievable. For example, take the following standard example of a set of functional dependencies that cannot be expressed in BCNF using just relations:

```{r}
#| label: bcnf
#| echo: false
fds <- functional_dependency(
  list(list(c("a", "b"), "c"), list("c", "a")),
  letters[1:3]
)
fds
schema <- normalise(fds)
write(gv(schema), "bcnf_3nf.gv")
```

```{dot}
//| file: bcnf_3nf.gv
```

The above schema is in third normal form. However, it is not in the higher Boyes-Codd normal form (BCNF), because `c -> a` is present in relation `a_b`, but not in terms of a key. This results in some redundancy, but also means that the two representations of `c -> a` can hold sets of data that aren't mutually coherent :

```{r}
#| label: bcnf2
db <- schema |>
  create() |>
  insert(data.frame(c = 1:2, a = 1:2), relations = "c") |>
  insert(data.frame(a = 1:2, b = 1L, c = 2:1), relations = "a_b")
knitr::kable(records(db)$a_b)
knitr::kable(records(db)$c)
```

The standard way to fix this schema to satisfy BCNF is by splitting relation `a_b` on the violated functional dependency, namely `c -> a`:

```{r}
#| label: bcnf3
#| echo: false
schema2 <- schema
keys(schema2)$a_b <- list(c("b", "c"))
attrs(schema2)$a_b <- c("b", "c")
names(schema2)[names(schema2) == "a_b"] <- "b_c"
write(gv(schema2), "bcnf_fix.gv")
```

```{dot}
//| file: bcnf_fix.gv
```

The resulting schema is now in BCNF, but we have a different problem: the dependency `{a, b} -> c` has disappeared! Fixing this can't be done with just real relations, but we can solve it by adding a virtual relation. Here is a mockup of what the resulting schema might look like:

```{dot}
digraph {
  rankdir = "LR"
  node [shape=plaintext];

  "c" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">c</TD></TR>
    <TR><TD PORT="TO_c">c</TD><TD PORT="FROM_c" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_a">a</TD><TD PORT="FROM_a"></TD></TR>
    </TABLE>>];
  "b_c" [label = <
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">b_c</TD></TR>
    <TR><TD PORT="TO_b">b</TD><TD PORT="FROM_b" BGCOLOR="black"></TD></TR>
    <TR><TD PORT="TO_c">c</TD><TD PORT="FROM_c" BGCOLOR="black"></TD></TR>
    </TABLE>>];
  "view" [label = <
    <TABLE BGCOLOR="lightgrey" BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
    <TR><TD PORT="TITLE" COLSPAN="2">view</TD></TR>
    <TR><TD>a</TD><TD BGCOLOR="black"></TD></TR>
    <TR><TD>b</TD><TD BGCOLOR="black"></TD></TR>
    <TR><TD>c</TD><TD></TD></TR>
    </TABLE>>];

  "b_c":FROM_c -> "c":TO_c;

  "view":TITLE -> "b_c":TITLE [arrowhead="empty" style="dashed"];
  "view":TITLE -> "c":TITLE [arrowhead="empty" style="dashed"];
}
```

Some features to note:

- Unlike before, the key for `view` is required, since it can't be inferred from the real relations. This is how we preserve `{a, b} -> c` when decomposing to BCNF.
- `view` references both of the real relations, to show that it's the result of combining both of them. This means that `view` "references" relation `c` both directly, and via `b_c`. For real relations, the direct reference would be removed as being transitive, but in this case both give necessary information. If virtual relations get implemented, virtual-to-real "references" would be displayed differently, to make this clear.
- `view` contains both `a` and `c`, as `a_b` did before. Unlike for `a_b`, this is not an extra appearance of `c -> a`, so is not a violation of BCNF. This is because, since `view` is virtual, its `a` and `c` values are exactly the same as those in relation `c`, so there is no incoherency possible.

# Proper handling of nullable data

This addresses how to decompose data with `NA` values. See the `autodb_na` vignette for details.

# Handling of duplicate records

Relational theory is based on data being given as relations, that cannot have duplicate records. However, it's expected that an R user might pass in a data frame with duplicates: for example, R comes with some datasets, such as `iris`, that have duplicates if we don't include the row names.

At the moment, these duplicates are kept when searching for dependencies. This can affect results for approximate dependencies, since it changes how many records must be removed for a given dependency to be satisfied. However, the duplicates are still removed when the data frame is decomposed into a database. At the moment, I'm not certain on whether these duplicates are best handled by removing them before beginning the search, or by simply returning an error if there are duplicate records.
