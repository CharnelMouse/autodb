---
title: "A larger example: the nudge dataset"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A larger example: the nudge dataset}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
    fig-width: 7
    fig-height: 5
---

```{r setup}
library(autodb)
```

```{r check_diagrammer}
if (requireNamespace("DiagrammeR", quietly = TRUE)) {
  show <- function(x) DiagrammeR::grViz(gv(x), width = "100%")
  maybe_plot <- function(x) DiagrammeR::grViz(gv(x), width = "100%")
}else{
  show <- print
  maybe_plot <- function(x) invisible(NULL)
}
```

Included in the package is a `r paste(dim(nudge), collapse = "-by-")` data frame called `nudge`:

```{r nudge_classes}
show(nudge)
```

This is the data set for a meta-analysis, looking at the effectiveness of "nudge" interventions. Measurements are taken within a three-layer hierarchy: publications contain studies, which contain effect size measurements. We expect this hierarchy to be apparent in the normalisation.

# Initial decomposition

Getting full dependency information for this relation can take a long time, so here we search for a reduced set, not considering numeric or sample size attributes as determinants:

```{r nudge_database}
nudge_deps <- discover(
  nudge,
  exclude = c("n_study", "n_comparison", "n_control", "n_intervention"),
  exclude_class = "numeric"
)
nudge_schema <- normalise(nudge_deps, remove_avoidable = TRUE)
show(nudge_schema)
```

We can see a relation, with many attributes, determined by the effect size ID number, `es_id`. This contains all of the numeric measurements, as expected in the relation for the lowest level in the hierarchy. As also expected, this has a foreign key reference to a relation for study-level information, determined by the study ID number, `study_id`.

However, the publication-level relation this refers to is not determined by the publication ID, `publication_id`, as we would expect; neither is it determined by the publication reference. Instead, it is solely determined by the publication's title: to use the ID, we would need to supplement it with other information, like the publication year, or other choices that come from the middle column of relations, which look likely to be spurious.

This suggests that some publication ID numbers have been erroneously assigned to several publications, which we can easily test:

```{r nudge_publication_check}
nudge_database <- decompose(nudge, nudge_schema)
nudge_title_relation <- records(nudge_database)$title
nudge_pid_duplicates <- unique(nudge_title_relation$publication_id[
  duplicated(nudge_title_relation$publication_id)
])
knitr::kable(subset(nudge_title_relation, publication_id %in% nudge_pid_duplicates))
```

We'd also expect `reference` to determine the publication, but this is also not the case: it needs additional information, such as `binary_outcome`.

This means that there are publications that share a reference:

```{r nudge_reference_check}
nudge_reference_duplicates <- unique(nudge_title_relation$reference[
  duplicated(nudge_title_relation$reference)
])
knitr::kable(subset(nudge_title_relation, reference %in% nudge_reference_duplicates))
```

BETA is the Behavioural Economics Team of the Australian Government, so it's not surprising that they'd have multiple publications/reports per year. Duplicate references is not necessarily an error, but would be awkward if the references were to be used.

There are other, clearly spurious, relations involving `reference`. One of these combines it with `type_experiment` to determine `location`. Since `reference` is a publication-level attribute, and `location` is a study-level attribute, this can't be right.

(As far as I'm aware, the publication ID and reference errors mentioned above would not have affected the meta-analysis results.)

# Removing spurious structure

The publication ID and the reference clearly have issues, so we need to decide what to do about them. Here, I'll show what is usually the correct approach, which is to remove the spurious functional dependencies. We'll look at the other options later.

The better option is to remove all functional dependencies that we'd consider to be spurious: those where publication ID or reference are part of a multiple-attribute determinant set, and the determinant set isn't just those two:

```{r nudge_filter}
nudge_deps_filtered <- nudge_deps[
  lengths(detset(nudge_deps)) == 1 |
    vapply(
      detset(nudge_deps),
      \(ds) length(setdiff(ds, c("publication_id", "reference"))) != 1,
      logical(1)
    )
]
nudge_schema_filtered <- normalise(nudge_deps_filtered, remove_avoidable = TRUE)
show(nudge_schema_filtered)
```

We now, finally, have the study location in a non-spurious relation. If we want to, we could also add the dependencies we fail to find, due to excluding the sample size attributes from determinant sets:

```{r nudge_sizes}
nudge_deps_size <- discover(nudge[, startsWith(names(nudge), "n_")])
nudge_deps_size
nudge_deps_final <- c(nudge_deps_filtered, nudge_deps_size)
nudge_schema_final <- normalise(nudge_deps_final, remove_avoidable = TRUE)
nudge_database_final <- decompose(nudge, nudge_schema_final)

show(nudge_schema_final)
```

The new schema confirms what we might expect, that the total sample size, and the sizes of control and treatment arms, only have two degrees of freedom: knowing two of them determines the other.

We'd expect this to be because the total sample size is the sum of the other two. However, the functional dependency can't determine this. Indeed, if we check for this more specific condition, we find that it doesn't hold:

```{r nudge_size_check}
knitr::kable(unique(subset(
  nudge,
  n_comparison != n_control + n_intervention,
  c(
    es_id,
    reference,
    title,
    n_study,
    n_comparison,
    n_control,
    n_intervention
  )
)))
```

Looking through the paper, the arm sample sizes aren't given explicitly, but the numbers here are consistent with the parts of the study that have two treatments.

Automatic search for functional dependencies cannot check domain-specific constraints like the summation constraint above, but it can give schemas that suggest constraints to check for, such as the two-degrees relation above.

Going back to the final database schema, removing dependencies has revealed extra information about study locations, via the new `title_type_experiment` relation: studies of the same experiment type in a publication always have the same location. Looking at the resulting database shows that this removes many entries of what would be redundant location information if kept in the study relation:

```{r nudge_clean_database}
show(nudge_database_final)
```

While this is not a dependency we could expect to hold if more data was collected, it's a reasonable dependency for the given data set, which won't be added to.

# How not to remove spurious structure

The additional relation mentioned at the end of the previous section is also notable for what we'll now discuss: alternative ways to get rid of spurious structure. How can we do this?

-   Remove the offending functional dependencies, and re-do the schema creation (the proper method);
-   Remove offending attributes from the table -- e.g. `publication_id` above, since it doesn't do its intended job of unique publication identification -- and re-do the entire process (re-running `discover` can be expensive; we don't always want to throw out everything to do with an attribute, e.g. `reference -> year`, or `title -> reference`);
-   Add offending attributes to `exclude`, to disallow them in determinant sets, and re-do the entire process (same issues as above, except that we keep `title -> reference`, since an excluded `reference` can still be a dependant);
-   Remove offending schemas from the database schema / database (see below).

What happens if we remove the offending schemas?

```{r nudge_publication_badfilter}
nudge_schema_relfiltered <- nudge_schema[
  !grepl("publication_id_", names(nudge_schema), fixed = TRUE) &
    !grepl("_publication_id", names(nudge_schema), fixed = TRUE) &
    !grepl("reference_", names(nudge_schema), fixed = TRUE) &
    !grepl("_reference", names(nudge_schema), fixed = TRUE)
]
```

Subsetting a database schema also removes any foreign key references involving removed schemas, so the resulting schema is still valid. However, any foreign key reference chains with removed schemas in the middle are broken. Amongst others, in this case we lose the reference between the three relations for the three hierarchical data levels:

```{r nudge_publication_badfilter_gv}
show(nudge_schema_relfiltered)
```

Re-running `autoref` has no effect, because the `es_id` section doesn't contain any key for the `title` section:

```{r nudge_publication_badfilter_autoref}
identical(autoref(nudge_schema_relfiltered), nudge_schema_relfiltered)
```

Because the database subschema including the `es_id` relation only has `publication_id` for distinguishing publications, effect sizes for the two publications with the same ID cannot be uniquely associated with their publication: removing schemas irreversibly separates two parts of the database schema.

Furthermore, compared to `nudge_schema_filtered`, there is a relation schema missing: directly removing schemas loses the structure information that results in the `title_type_experiment` relation. How does this happen?

The relation isn't present in the original schema, `nudge_schema_filtered`, because the full set of functional dependencies make its implied dependency transitive. Specifically, `nudge_fds` contains the following functional dependencies:

```{r nudge_badfilter_example_fds}
example_fds <- functional_dependency(
  list(
    list("title", "reference"),
    list(c("reference", "type_experiment"), "location"),
    list(c("title", "type_experiment"), "location")
  ),
  c("title", "reference", "type_experiment", "location")
)
example_fds
```

The first two dependencies make the third transitive, so it's ignored when constructing the relation schemas: it's implied, and enforced, by the `title` and `reference_type_experiment` relation schemas.

```{r nudge_badfilter_example_transitive}
show(normalise(example_fds, ensure_lossless = FALSE))
```

However, when `reference, type_experiment -> location` is removed as spurious, `title, type_experiment -> location` is no longer transitive, so it now appears as its own relation schema.

```r
normalise(example_fds[-2], ensure_lossless = FALSE)
```

```{r nudge_badfilter_example_nontransitive}
show(normalise(example_fds[-2], ensure_lossless = FALSE))
```

When we instead remove the `reference_type_experiment` schema, this implicitly also throws away the `title, type_experiment -> location` dependency that it co-implies. We throw away non-spurious information that we don't intend to.

Between the risk of irreversibly breaking the database schema's structure, and the risk of unintentionally removing additional structure information, I hope it's clear why directly removing relations should be avoided.
