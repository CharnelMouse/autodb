[{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"terminology","dir":"Articles","previous_headings":"","what":"Terminology","title":"Using autodb","text":"avoid confusion, vignette consistent terminology: data frame (table) records (rows) attributes (columns/variables), split database, consists relations (data frames key foreign key constraints ). line terms used relational model. talk type values attribute can take, talk data class, relational model R, rather value type, many programming languages.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Using autodb","text":"Let’s expand package DESCRIPTION: Automatic normalisation data frame third normal form, intention easing process data cleaning. (Usage design actual database advised.)","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"database-normalisation","dir":"Articles","previous_headings":"Motivation","what":"Database normalisation","title":"Using autodb","text":"Database normalisation , roughly, idea taking dataset splitting several linked tables. useful, makes structure data explicit, enforceable. example, let’s look ChickWeight dataset, included base R. simple dataset, flat table format obscures information structure data. Specifically, chicks diet assigned beginning study, ’s never changed. make explicit, split data two separate tables: can also add restriction chick can appear chick table , chick-time pair can appear measurement table . data management, good prevents common types data error: Consistency errors. flat table, can accidentally add row chick different diet . split tables, restrictions mean impossible. Insertion/deletion errors. Suppose chick ’s assigned diet, hasn’t measured yet. flat table, information can’t added, unless use temporary row time weight missing, hope remember remove later. split tables, can just add chick chick table without issue. Conversely, removed chick’s measurements flat table, ’d also lose information diet ’s assigned. Update errors. Suppose notice chick recorded wrong diet, change values correct . flat table, chick’s diet recorded every measurement, update mistake, resulting inconsistency. split tables, diet given , can’t happen. tie idea: reducing data redundancy fact stated one place.","code":"summary(ChickWeight) ##      weight           Time           Chick     Diet    ##  Min.   : 35.0   Min.   : 0.00   13     : 12   1:220   ##  1st Qu.: 63.0   1st Qu.: 4.00   9      : 12   2:120   ##  Median :103.0   Median :10.00   20     : 12   3:120   ##  Mean   :121.8   Mean   :10.72   10     : 12   4:118   ##  3rd Qu.:163.8   3rd Qu.:16.00   17     : 12           ##  Max.   :373.0   Max.   :21.00   19     : 12           ##                                  (Other):506 measurement <- unique(subset(ChickWeight, , -Diet)) chick <- unique(subset(ChickWeight, , c(Chick, Diet))) summary(measurement) ##      weight           Time           Chick     ##  Min.   : 35.0   Min.   : 0.00   13     : 12   ##  1st Qu.: 63.0   1st Qu.: 4.00   9      : 12   ##  Median :103.0   Median :10.00   20     : 12   ##  Mean   :121.8   Mean   :10.72   10     : 12   ##  3rd Qu.:163.8   3rd Qu.:16.00   17     : 12   ##  Max.   :373.0   Max.   :21.00   19     : 12   ##                                  (Other):506 summary(chick) ##      Chick    Diet   ##  18     : 1   1:20   ##  16     : 1   2:10   ##  15     : 1   3:10   ##  13     : 1   4:10   ##  9      : 1          ##  20     : 1          ##  (Other):44 stopifnot(   identical(     merge(measurement, chick, sort = FALSE)[names(ChickWeight)],     data.frame(ChickWeight)   ),   setequal(measurement$Chick, chick$Chick) )"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"for-data-cleaning","dir":"Articles","previous_headings":"Motivation","what":"For data cleaning","title":"Using autodb","text":"points also useful data exploration validation, ’s emphasis package. able make data’s structure explicit valuable making sure understand problem domain try model . true even still use original flat table analysis , since tools like R generally expect format. ’ve often started data exploration following conditions: Little prior knowledge data, since ’s provided third party. One-analyses, data discard end, ’s worth time get data proper database. Limited, unreliable, documentation. Data fits local memory, presenting less problems automation. ’s context usually normalisation hand, like tool semi-automatically. package intended tool, using minimal amount additional libraries. example, can pass ChickWeight main function, autodb, get expected normalisation: can also plot , using gv turn result code Graphviz language. interactive session, simplest way DiagrammeR package: also save Graphviz code file, either call Graphviz directly, call dot code block Quarto. Unlike DiagrammeR, don’t create HTML widget, get static image instead something built top 2MB Javascript. plot represents table/relation box: top row gives relation name number records, rows list attributes classes. middle grid containing black cells: column black cells represents key, uniqueness constraint, relation. Keys irreducible subsets relation’s attributes, take unique set values record. can treated unique row identifier. example, chick unique Chick value, measurement unique Time-Chick pair.","code":"chick_db <- autodb(ChickWeight) chick_db ## database with 2 relations ## 4 attributes: weight, Time, Chick, Diet ## relation Chick: Chick, Diet; 50 records ##   key 1: Chick ## relation Time_Chick: Time, Chick, weight; 578 records ##   key 1: Time, Chick ## references: ## Time_Chick.{Chick} -> Chick.{Chick} cat(gv(chick_db)) ## digraph { ##   rankdir = \"LR\" ##   node [shape=plaintext]; ##  ##   \"Chick\" [label = < ##     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> ##     <TR><TD COLSPAN=\"3\">Chick (50 records)<\/TD><\/TR> ##     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> ##     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD><\/TD><TD PORT=\"FROM_diet\">factor<\/TD><\/TR> ##     <\/TABLE>>]; ##   \"Time_Chick\" [label = < ##     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> ##     <TR><TD COLSPAN=\"3\">Time_Chick (578 records)<\/TD><\/TR> ##     <TR><TD PORT=\"TO_time\">Time<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_time\">numeric<\/TD><\/TR> ##     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> ##     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD><\/TD><TD PORT=\"FROM_weight\">numeric<\/TD><\/TR> ##     <\/TABLE>>]; ##  ##   \"Time_Chick\":FROM_chick -> \"Chick\":TO_chick; ## } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   show <- function(x) DiagrammeR::grViz(gv(x), width = \"100%\")   maybe_plot <- function(x) DiagrammeR::grViz(gv(x), width = \"100%\") }else{   show <- print   maybe_plot <- function(x) invisible(NULL) } maybe_plot(chick_db)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"not-for-database-design","dir":"Articles","previous_headings":"Motivation","what":"Not for database design","title":"Using autodb","text":"Good database design hard involved process, requires strong grasp domain database hold information . Please don’t try use package autopilot. , ’ll quickly find shortcomings results: Since package can work data ’s got, resulting database schema specific given dataset, rather data type general. useful data exploration, since can give useful information sampling issues, designing database. resulting “databases” might something SQL etc. accept -. example, autodb needs handle constant attributes, value every record. done making relation empty key, allowed relation model, SQL won’t let . real database, either store constants database , place expectation won’t stay constant data added. doesn’t introduce artificial keys, like using , single-attribute lookups, relational database’s equivalent factor levels. doesn’t create “virtual relations”, also known “views”, data-less relations defined terms manipulating real relations (usually create aggregates). relation multiple keys, doesn’t choose one “primary key”. Primary keys implementation details databases, part relational model, ’re especially relevant data exploration. However, SQL etc. ask one. can’t account semantic knowledge, person spot easily. See Limitations vignette (vignette(\"limits\", package = \"autodb\")) details.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"to-third-normal-form","dir":"Articles","previous_headings":"Motivation","what":"To third normal form","title":"Using autodb","text":"autodb gets given data frame third normal form (3NF): every attribute depends whole key(s), non-key attributes depend nothing key(s). mostly chosen existing algorithm, Bernstein’s synthesis, normalising third normal form. autodb works searching functional dependencies data, highest normal form attainable functional dependencies higher form called Boyes-Codd normal form (BCNF). However, normalising BCNF requires complicated infrastructure, autodb isn’t set yet. may change future. additional enhancement 3NF, called LTK form, available option: see section avoidable attributes details.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"finding-functional-dependencies","dir":"Articles","previous_headings":"Individual steps","what":"Finding functional dependencies","title":"Using autodb","text":"looked final result ChickWeight first, now look individual steps. first step find (non-trivial minimal) dependencies present given data frame. various ways ; default, package uses FDHitsSep, depth-first search algorithm. run using discover function, setting progress TRUE see steps taken: result list functional dependencies, format determinant -> dependant, attribute named attrs_order gives attribute names original order. three parts can extracted: former two useful filtering.","code":"deps <- discover(ChickWeight, progress = TRUE) ## formatting numerical/complex variables with 7 significant digits ## simplifying data types ## calculating single-attribute PLIs ## sampling difference sets ## 7 initial diffsets ##  ## dependant weight ## dependant Time ## dependant Chick ## dependant Diet ##  ## FDHitsSep complete ## 9 final diffsets ## 10 nodes visited ## 7 partitions cached deps ## 2 functional dependencies ## 4 attributes: weight, Time, Chick, Diet ## Time, Chick -> weight ##       Chick -> Diet detset(deps) ## [[1]] ## [1] \"Time\"  \"Chick\" ##  ## [[2]] ## [1] \"Chick\" dependant(deps) ## [1] \"weight\" \"Diet\" attrs_order(deps) ## [1] \"weight\" \"Time\"   \"Chick\"  \"Diet\""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"normalisation","dir":"Articles","previous_headings":"Individual steps","what":"Normalisation","title":"Using autodb","text":"Now list discovered dependencies, can construct database schema, relation schemas normalised third normal form. done using Bernstein’s synthesis. can also plot schema: similar database plot given , information present, requires data frame : record counts, data classes. automatically-generated names individual relations, created using keys. point, references relation schemas, since Bernstein’s synthesis doesn’t supply information foreign key references. use database schema build database, ’d rather add foreign key references first.","code":"schema <- synthesise(deps) schema ## 2 relation schemas ## 4 attributes: weight, Time, Chick, Diet ## schema Chick: Chick, Diet ##   key 1: Chick ## schema Time_Chick: Time, Chick, weight ##   key 1: Time, Chick maybe_plot(schema)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"adding-foreign-key-references","dir":"Articles","previous_headings":"Individual steps","what":"Adding foreign key references","title":"Using autodb","text":"Getting back ChickWeight example, now database schema, consisting list relation schemas. However, information relation schemas linked . particular, information foreign keys. can add information using autoref: also used normalise, instead synthesise autoref separately: Plotting updated database schema shows relation schemas , linked together foreign key references:","code":"linked_schema <- autoref(schema) linked_schema ## database schema with 2 relation schemas ## 4 attributes: weight, Time, Chick, Diet ## schema Chick: Chick, Diet ##   key 1: Chick ## schema Time_Chick: Time, Chick, weight ##   key 1: Time, Chick ## references: ## Time_Chick.{Chick} -> Chick.{Chick} normalise(deps) ## database schema with 2 relation schemas ## 4 attributes: weight, Time, Chick, Diet ## schema Chick: Chick, Diet ##   key 1: Chick ## schema Time_Chick: Time, Chick, weight ##   key 1: Time, Chick ## references: ## Time_Chick.{Chick} -> Chick.{Chick} show(linked_schema)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"decomposing-the-original-relation","dir":"Articles","previous_headings":"Individual steps","what":"Decomposing the original relation","title":"Using autodb","text":"Finally, normalised database schema, can apply original data frame, new one structure. results normalised database, got using autodb:","code":"db <- decompose(ChickWeight, linked_schema) show(db)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"rejoining-a-database-back-into-a-data-frame","dir":"Articles","previous_headings":"Individual steps","what":"Rejoining a database back into a data frame","title":"Using autodb","text":"can reverse process turning data frame database rejoin function. may identical ChickWeight, since rows may rearranged. However, can use convenience function df_equiv check equivalence row reordering:","code":"rejoined <- rejoin(db) summary(rejoined) ##      weight           Time           Chick     Diet    ##  Min.   : 35.0   Min.   : 0.00   13     : 12   1:220   ##  1st Qu.: 63.0   1st Qu.: 4.00   9      : 12   2:120   ##  Median :103.0   Median :10.00   20     : 12   3:120   ##  Mean   :121.8   Mean   :10.72   10     : 12   4:118   ##  3rd Qu.:163.8   3rd Qu.:16.00   17     : 12           ##  Max.   :373.0   Max.   :21.00   19     : 12           ##                                  (Other):506 identical(rejoined, ChickWeight) ## [1] FALSE df_equiv(rejoined, ChickWeight) ## [1] TRUE"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"tuning-detection-and-normalisation","dir":"Articles","previous_headings":"Individual steps","what":"Tuning detection and normalisation","title":"Using autodb","text":"Let’s look different dataset moment, look cases don’t want use dependencies given. ’ll use Titanic data set, also provided base R. data array form, first convert data frame form: simple set data, single count observation, Freq, combination four determining attributes. words, relation already normalised, expect one relation normalised database. use autodb , get following database: Oops! search found functional dependencies count used determine another attribute. clearly spurious: frequency count can’t causally determine age, example. two ways can remove spurious dependencies: limiting search check first place, removing dependencies using synthesise/normalise. limit search, can set certain attributes considered members determinants, can exclude attributes inherit certain classes. example, exclude Freq considered: Alternatively, exclude attributes inherit “numeric”: can also limit search using autodb: Excluding numeric attributes determinants often useful, expect non-integer numbers measurement doesn’t co-determine anything else. main exception attributes summaries others. Alternatively, can remove unwanted dependencies. found dependencies, don’t exclude anything: can remove unwanted dependencies, Age dependant, using subsetting, Filter, etc.:","code":"knitr::kable(as.data.frame(Titanic)) show(autodb(as.data.frame(Titanic))) titanic_deps_freqonly <- discover(as.data.frame(Titanic), exclude = \"Freq\") titanic_deps_freqonly ## 1 functional dependency ## 5 attributes: Class, Sex, Age, Survived, Freq ## Class, Sex, Age, Survived -> Freq stopifnot(setequal(   titanic_deps_freqonly,   discover(as.data.frame(Titanic), exclude_class = \"numeric\") )) show(autodb(as.data.frame(Titanic), exclude = \"Freq\")) titanic_deps <- discover(as.data.frame(Titanic)) titanic_deps ## 3 functional dependencies ## 5 attributes: Class, Sex, Age, Survived, Freq ##       Sex, Survived, Freq -> Age ##     Class, Survived, Freq -> Age ## Class, Sex, Age, Survived -> Freq titanic_deps[dependant(titanic_deps) == \"Age\"] ## 2 functional dependencies ## 5 attributes: Class, Sex, Age, Survived, Freq ##   Sex, Survived, Freq -> Age ## Class, Survived, Freq -> Age"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"avoidable-attributes","dir":"Articles","previous_headings":"","what":"Avoidable attributes","title":"Using autodb","text":"next normal form third normal form (3NF) Boyes-Codd normal form (BCNF). Ensuring BCNF enforced database trickier: cases, can’t enforced just relations foreign key constraints. However, package includes option convert enhanced third normal form, also known LTK form, can enforced. enhancement tangential BCNF, also used enhance schemas BCNF. brief, standard normal forms put constraints attributes present relations one relation time. enhancement constraint attributes present relation, considering presence relations. attribute relation can removed, still determined relation joining others, attribute “avoidable”, can removed. attribute relation’s keys, ’ll replaced keys use attributes removed. removes attributes relations without removing information database whole. example, can take simple example Chapter 6 Theory Relational Databases, David Maier: Attributes B equivalent, since relation key. words, relation simple lookup relation. , remove B relation A_C, replace key B, D , D, equivalent accounting relation . can removal avoidable attributes done automatically, using remove_avoidable flag normalise: schema now LTK form, remaining avoidable attributes. also removed relation A_C instead B, process may unique result. package’s implementation prefers remove attributes appear later original relation.","code":"avoid_deps <- functional_dependency(   list(     list(\"A\", \"B\"),     list(\"B\", \"A\"),     list(c(\"A\", \"C\"), \"D\"),     list(c(\"A\", \"C\"), \"E\"),     list(c(\"B\", \"D\"), \"C\")   ),   attrs_order = c(\"A\", \"B\", \"C\", \"D\", \"E\") ) avoid_deps ## 5 functional dependencies ## 5 attributes: A, B, C, D, E ##    A -> B ##    B -> A ## A, C -> D ## A, C -> E ## B, D -> C avoid_schema <- normalise(avoid_deps) show(avoid_schema) avoid_schema_removed <- normalise(   avoid_deps,   remove_avoidable = TRUE ) show(avoid_schema_removed)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/limits.html","id":"meaningful-duplicate-rows-row-order","dir":"Articles","previous_headings":"","what":"Meaningful duplicate rows / row order","title":"Limitations","text":"autodb assumes input data relational data (1NF), data can considered set records. means duplicate rows – can remove duplicates without loss information – order rows doesn’t matter. isn’t case, data need manipulated first, .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/limits.html","id":"value-based-constraints","dir":"Articles","previous_headings":"","what":"Value-based constraints","title":"Limitations","text":"FD search agnostic kind data stored attribute; just cares records value given attribute. can’t find constraints depend actual data values. example, can’t determine whether numeric attribute’s values within expected interval: require using knowledge attribute’s class. Similarly, can’t determine inequality constraints numeric attributes: require knowing attributes numeric, comparing suitable (aren’t integers represent non-ordinal IDs, example).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/limits.html","id":"semantic-types","dir":"Articles","previous_headings":"","what":"Semantic types","title":"Limitations","text":"section noted search can’t account data classes, .e. attributes’ syntactic classes (integer, float, etc.). also can’t account semantic classes. Suppose dataset publication citations, row contains citer citee IDs, plus supplementary information publications. resulting database given autodb following schema, giving relations appropriate names: course, citers citees publications type, shouldn’t separate relations: make improvement citer_id citee_id values , semantically, class object, goes authors, titles, etc. Semantic classes something can inferred just looking syntactic/data classes. don’t account semantic identity, separate citer citee information relations original schema can hold information publication. introduces possibility hold different information, data publication incoherent. Currently, way account semantic identity create modify schema manually, .","code":"show(database_schema(   relation_schema(     list(       citation = list(c(\"citer_id\", \"citee_id\"), list(c(\"citer_id\", \"citee_id\"))),       citer = list(c(\"citer_id\", \"citer_title\", \"citer_author\", \"citer_year\"), list(\"citer_id\")),       citee = list(c(\"citee_id\", \"citee_title\", \"citee_author\", \"citee_year\"), list(\"citee_id\"))     ),     c(       \"citer_id\", \"citer_title\", \"citer_author\", \"citer_year\",       \"citee_id\", \"citee_title\", \"citee_author\", \"citee_year\"     )   ),   list(     list(\"citation\", \"citer_id\", \"citer\", \"citer_id\"),     list(\"citation\", \"citee_id\", \"citee\", \"citee_id\")   ) )) show(database_schema(   relation_schema(     list(       citation = list(c(\"citer\", \"citee\"), list(c(\"citer\", \"citee\"))),       publication = list(c(\"id\", \"title\", \"author\", \"year\"), list(\"id\"))     ),     c(\"citer\", \"citee\", \"id\", \"title\", \"author\", \"year\")   ),   list(     list(\"citation\", \"citer\", \"publication\", \"id\"),     list(\"citation\", \"citee\", \"publication\", \"id\")   ) ))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/limits.html","id":"table-merges-dont-fix-issues-with-merge-data-frame","dir":"Articles","previous_headings":"","what":"Table merges don’t fix issues with merge.data.frame","title":"Limitations","text":"specific autodb, rather relational model general. Rejoining databases, checking relations satisfy foreign key constraints, done using merge.data.frame. means data classes don’t work properly merge aren’t guaranteed work properly autodb. issues come certain data classes handled merges base language, issues R, rather autodb, plans fix . autodb seems odd failures, check used data classes behave correctly merges. example, older versions R, built-POSIXct date/time class didn’t values merged properly, merge didn’t account differences time zone / daylight saving time. result , example, nycflights13::weather data set violating foreign key constraints discovered schema, since one foreign key used POSIXct attribute. complex example, still applies probably always , merge two attributes merged different classes. general, allowed: since autodb written R, dynamically-typed language, follows SQLite constraining user much comes data classes schemas. primitive classes, R’s class coercion usually makes things work ’d expect. practice, attribute’s class vary across relation belongs asking trouble. particular, ’s representing factor one relation, non-factor, non-character class another, latter values former’s levels, merging cause issues. unexpected, ’s just coercing factors works R. example, can define data frames: can merge data frame logical two, keeping row attributes track records merged. Whichever data frame merge , two sets values different classes, R coercion. merging just , gives result ’d expect, data frames regardless merge order. integer version, logical values coerced integers: factor version, logical values coerced factors, don’t match given levels, become NA: However, see unexpected behaviour factor version, also merging another attribute, b: merge result now depends input order. factor version first, result similar : logical version first, however, logical values NA coercion kept, rather : said , letting attribute’s class vary across relations done caution.","code":"df_badmerge_int <- cbind(   expand.grid(     a = c(NA, 0L, 1L),     b = c(NA, FALSE, TRUE)   ),   row = 1:9 ) df_badmerge_factor <- df_badmerge_int df_badmerge_factor$a <- as.factor(df_badmerge_factor$a) knitr::kable(df_badmerge_int) df_badmerge_logical <- df_badmerge_int df_badmerge_logical$a <- as.logical(df_badmerge_logical$a) names(df_badmerge_logical)[[3]] <- \"row2\" knitr::kable(df_badmerge_logical) knitr::kable(merge(   df_badmerge_int[, c(\"a\", \"row\")],   df_badmerge_logical[, c(\"a\", \"row2\")] )) knitr::kable(merge(   df_badmerge_logical[, c(\"a\", \"row2\")],   df_badmerge_int[, c(\"a\", \"row\")] )) knitr::kable(merge(   df_badmerge_factor[, c(\"a\", \"row\")],   df_badmerge_logical[, c(\"a\", \"row2\")] )) knitr::kable(merge(   df_badmerge_logical[, c(\"a\", \"row2\")],   df_badmerge_factor[, c(\"a\", \"row\")] )) knitr::kable(merge(   df_badmerge_factor,   df_badmerge_logical )) ## Warning in `[<-.factor`(`*tmp*`, ri, value = c(NA, FALSE, TRUE, NA, FALSE, : ## invalid factor level, NA generated knitr::kable(merge(   df_badmerge_logical,   df_badmerge_factor ))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/limits.html","id":"synthesis-doesnt-minimise-relation-key-count","dir":"Articles","previous_headings":"","what":"Synthesis doesn’t minimise relation key count","title":"Limitations","text":"Bernstein’s synthesis guaranteed minimise number relations created given set functional dependencies, removing avoidable attributes can reduce number attributes relations. However, can still redundant keys. example, can take following set functional dependencies: Normalising gives following relations: relations redundancy: relation implies {b, d} -> c, relation d implies {d} -> c. isn’t resolved removing avoidable attributes, d still needs relation : just need remove {b, d} key. However, resolved instead use set functional dependencies, equivalent previous set: ’s way autodb find better sets like .","code":"fds_redkey <- functional_dependency(   list(     list(\"a\", \"b\"),     list(\"d\", \"c\"),     list(c(\"b\", \"d\"), \"a\"),     list(\"a\", \"c\"),     list(c(\"b\", \"c\"), \"d\")   ),   letters[1:4] ) fds_redkey ## 5 functional dependencies ## 4 attributes: a, b, c, d ##    a -> b ##    d -> c ## b, d -> a ##    a -> c ## b, c -> d schema_redkey <- normalise(fds_redkey, remove_avoidable = TRUE) show(schema_redkey) fds_redkey_fix <- functional_dependency(   list(     list(\"a\", \"b\"),     list(\"d\", \"c\"),     list(c(\"b\", \"c\"), \"a\"),     list(\"a\", \"d\")   ),   letters[1:4] ) fds_redkey_fix ## 4 functional dependencies ## 4 attributes: a, b, c, d ##    a -> b ##    d -> c ## b, c -> a ##    a -> d schema_redkey_fix <- normalise(fds_redkey_fix, remove_avoidable = TRUE) show(schema_redkey_fix)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/limits.html","id":"normal-forms-aret-all-there-is-to-database-design","dir":"Articles","previous_headings":"","what":"Normal forms are’t all there is to database design","title":"Limitations","text":"Normal forms refer one relation time: referring database given normal form just means relations normal form individually. independence means ’s easy make database schemas technically well-normalised, obvious issues. example, take database schema, whose relation schemas third normal form: now create copies relations, intention copies always contain data, relations still third normal form, ’d say database also third normal form: However, one claim good database design, since clearly large amount data redundancy. Higher normal forms change . fact, since ’ve implemented subset-based-copying copies referencing , trivial insert data make database incoherent. example, Chick Chick.1 contain different diet assignments.","code":"dup_db <- autodb(ChickWeight) show(dup_db) show(dup_db[c(1, 1, 2, 2, 2)])"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/nudge.html","id":"initial-decomposition","dir":"Articles","previous_headings":"","what":"Initial decomposition","title":"A larger example: the nudge dataset","text":"full dependency information data rather large. results relatively large search time data set size, still takes seconds. However, resulting schema hard make anything , relations ’d want go manually: reasons , main one sheer number functional dependencies discovered: Even remove transitive dependencies, implied others, still 597 dependenices.","code":"nudge_deps_big <- discover(nudge) nudge_schema_big <- normalise(nudge_deps_big, remove_avoidable = TRUE) nudge_db_big <- decompose(nudge, nudge_schema_big) length(nudge_schema_big) ## [1] 473 length(nudge_deps_big) ## [1] 3732"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/nudge.html","id":"simplifying-the-search-result","dir":"Articles","previous_headings":"","what":"Simplifying the search result","title":"A larger example: the nudge dataset","text":"rather large set simple approach simplifying set FDs: manually looking spurious cases remove normalisation. hack, can use reduce database. finds relations records – .e. relations one record unique row original data – returns reduced database, containing relations, relations reference, either directly indirectly. relations removed reduce often spurious, always: see reference chains section Planned improvements vignette (vignette(\"plans\", package = \"autodb\")) example non-spurious tables connected. However, reduce least gives us something smaller look . case, reduced database still large easily review: Instead, get grip ’s going collecting statistics attributes involved determinants. example, can also see large determinants : large true determinants real data, common rule thumb FDs larger determinants likely spurious. doesn’t make obvious way filter FDs hard size limit, though. can also see often attribute appears determinant: can specific, see often attributes appears determinant given size: Either way, can see attributes wouldn’t expect determinant, often , especially larger ones. don’t expect measurement attributes like variance_d sd_control co-determine anything else, often . generally, certain data classes don’t expect see appear determinants. example, numerics (floats) probably measurements, shouldn’t co-determine anything else. However, count determinant appearances attribute’s class, find often appear determinants: suggests simple first step remove FD float determinant. can write filter vector: removes lot! use filtered set FDs, still get large schema: However, reduce resulting database, get something much manageable: Let’s look resulting relations, two sets. ’s left-hand set: see two relations, es_id study_id, clearly represent effect study levels data hierarchy, encouraging. contain ID next level, , . relation effect relation references, long name, looks rather arbitrary, relations references look useful. One shows intervention technique determines intervention category, .e. techniques subcategories. Less simply, relation contains three effect sample sizes: comparison size, intervention arm size, control arm size. pair sizes determines , ’d see comparison size sum two. However, can’t assume nature relationship. Indeed, can find case ’s false: turns difficult identify results relevant paper referring , since presentation results rather obfuscated. However, clear referring part study three arms instead two (actually nine arms aggregated groups three). account two treatment arms, arm sizes sum comparison size, still sum relationship sorts, just simpler one might expect. case, relations set seem reasonable. can’t said set, represent publication-level data: lot going , let’s look last two: publication-level data, something wrong. publication ID simple key, ’d expect. Neither reference, ’d expect unique, otherwise bibliography duplicate entries. Instead, simple key publication’s title. use ID reference identifier publications, need use together compound key. Without looked data , keys tell us duplicate publication IDs duplicate references. Since keys title relation showed us problem, can search relation find duplicates, attributes needed context: publications ID first author references; looks like simple data entry error. BETA Behavioural Economics Team Australian Government, ’s surprising ’d multiple publications/reports per year. However references publications generated, possibility group publishing multiple relevant papers year wasn’t accounted . Looking keys relations, see often include publication_id reference, relationships describe seem rather questionable. worth going detail, since can guess stem duplication problems. real project, good point go back data provider questions, since now examples data surprising behaviour.","code":"nudge_reduced_big <- reduce(nudge_db_big) length(nudge_reduced_big) ## [1] 124 table(lengths(detset(nudge_deps_big))) ##  ##   1   2   3   4   5   6   7  ##  41 545 780 993 926 435  12 sort(table(unlist(detset(nudge_deps_big))), decreasing = TRUE) ##  ##           n_comparison        type_experiment  intervention_category  ##                   1095                   1085                   1061  ##              n_control                 domain         n_intervention  ##                   1029                   1016                    993  ##                   year          approximation intervention_technique  ##                    889                    766                    745  ##               location             variance_d        sd_intervention  ##                    739                    727                    687  ##             sd_control                n_study               cohens_d  ##                    684                    628                    549  ##         binary_outcome           mean_control      mean_intervention  ##                    503                    370                    313  ##             population                wansink         publication_id  ##                    269                    248                    119  ##              reference                  title               study_id  ##                    108                     83                     37  ##                  es_id  ##                     24 sort_by_rowSums <- function(x, ...) x[order(rowSums(x), ...), , drop = FALSE] level_table <- function(x, levels) table(factor(x, levels)) attrs_table <- function(x) level_table(unlist(x), names(nudge)) by_lengths <- function(x, f) do.call(cbind, tapply(x, lengths(x), f))  by_lengths(detset(nudge_deps_big), attrs_table) |>   sort_by_rowSums(decreasing = TRUE) ##                         1   2   3   4   5   6  7 ## n_comparison            0  73  64 342 395 217  4 ## type_experiment         0   6 114 286 376 295  8 ## intervention_category   0   2 140 185 389 341  4 ## n_control               0  53 148 305 361 162  0 ## domain                  0  23 109 335 453  84 12 ## n_intervention          0  64 142 283 290 206  8 ## year                    0  11 266 408 192  12  0 ## approximation           0   0  35 125 317 277 12 ## intervention_technique  1  25 124 309 249  37  0 ## location                0   4  91 191 259 182 12 ## variance_d              0  76 201 241 164  45  0 ## sd_intervention         0  15  65 228 227 148  4 ## sd_control              0  12  65 228 227 148  4 ## n_study                 0  60  81 224 182  77  4 ## cohens_d                0 211 258  23  46  11  0 ## binary_outcome          0   3  20  74 225 177  4 ## mean_control            1  89 196  59  25   0  0 ## mean_intervention       1 103 141  46  22   0  0 ## population              0   0   7  38 112 104  8 ## wansink                 0   0   0  42 119  87  0 ## publication_id          0  97  22   0   0   0  0 ## reference               1  85  22   0   0   0  0 ## title                   3  58  22   0   0   0  0 ## study_id               10  20   7   0   0   0  0 ## es_id                  24   0   0   0   0   0  0 attr_classes <- vapply(nudge, \\(x) class(x)[[1]], character(1)) class_table <- function(x) {   level_table(attr_classes[unlist(x)], sort(unique(attr_classes))) }  by_lengths(detset(nudge_deps_big), class_table) |>   sort_by_rowSums(decreasing = TRUE) ##            1   2   3    4    5    6  7 ## factor     1  60 585 1344 1838 1043 44 ## integer   34 378 730 1562 1420  674 16 ## numeric    2 506 926  825  711  352  8 ## logical    0   3  55  241  661  541 16 ## character  4 143  44    0    0    0  0 det_nofloat <- vapply(   detset(nudge_deps_big),   \\(x) all(attr_classes[x] != \"numeric\"),   logical(1) ) summary(det_nofloat) ##    Mode   FALSE    TRUE  ## logical    2784     948 length(normalise(nudge_deps_big[det_nofloat])) ## [1] 176 nudge_schema_filtered <- normalise(nudge_deps_big[det_nofloat]) nudge_db_filtered <- reduce(decompose(nudge, nudge_schema_filtered)) show(nudge_db_filtered) subsample <- c(   \"es_id\",   \"study_id\",   \"intervention_technique_n_comparison_n_control\",   \"intervention_technique\",   \"n_comparison_n_control\" ) show(nudge_db_filtered[subsample]) knitr::kable(   subset(     nudge,     n_comparison != n_control + n_intervention,     c(reference, study_id, es_id, n_study, n_comparison, n_control, n_intervention)   ),   row.names = FALSE ) show(nudge_db_filtered[setdiff(names(nudge_db_filtered), subsample)]) show(nudge_db_filtered[c(\"title\", \"reference\")]) duplicates <- function(x) unique(x[duplicated(x)]) subset_duplicates <- function(x, attr) {   x[x[[attr]] %in% duplicates(x[[attr]]), , drop = FALSE] } nudge_title_relation <- records(nudge_db_filtered)$title knitr::kable(subset_duplicates(nudge_title_relation, \"publication_id\")) knitr::kable(subset_duplicates(nudge_title_relation, \"reference\"))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/nudge.html","id":"fixing-the-data","dir":"Articles","previous_headings":"","what":"Fixing the data","title":"A larger example: the nudge dataset","text":"two ideal results find surprising behaviour: behaviour , can correct understanding data; behaviour unexpected, can fix data get rid . example, publication_id reference synthetic variables, can easily fix data : can re-run autodb find new schema. Note use exclude_class argument exclude FDs floats determinants, instead removing . prunes search space, speeding search. improvement: publications now ID reference simple keys, , questionable relations disappeared.","code":"nudge_fixed <- within(nudge, {   publication_id[publication_id == 95 & year == 2015] <- max(publication_id) + 1L   reference[publication_id == 19] <- \"BETA (2018a)\" }) db_fixed <- autodb(   nudge_fixed,   exclude_class = \"numeric\" ) length(db_fixed) ## [1] 170 show(reduce(db_fixed))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/nudge.html","id":"simplifying-further-with-search-filters","dir":"Articles","previous_headings":"","what":"Simplifying further with search filters","title":"A larger example: the nudge dataset","text":"relations still questionable. examine , see large keys, containing three attributes . simplify things, can decide remove . Rather manually filter FDs , can using another filtering argument discover/autodb, detset_limit: database now small enough need reduce : However, relations referred effect relation look spurious , can reduce database remove : great improvement. left two relations don’t expect general, hold dataset particular: publication_id_type_experiment states studies publication, use type experiment, also take place location. probably interesting, since “location” just logical value whether study conducted USA. publication_id_n_study states studies publication, sample size, location, domain, target population. likely coincidence, much interest either. Dataset-particular relations like useful check, since often indicate sampling limitations, can make planned statistical analysis infeasible. can remove either relations easily using exclude, since keys contain attributes don’t appear keys elsewhere. , get schema looks reasonable data sort general, apart mentioned issue effect sample sizes:","code":"db_final <- autodb(   nudge_fixed,   exclude_class = \"numeric\",   detset_limit = 2 ) length(db_final) ## [1] 11 show(db_final) show(reduce(db_final)) show(reduce(autodb(   nudge_fixed,   exclude = c(\"type_experiment\", \"n_study\"),   exclude_class = \"numeric\",   detset_limit = 2 )))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/nudge.html","id":"how-not-to-remove-spurious-structure","dir":"Articles","previous_headings":"","what":"How not to remove spurious structure","title":"A larger example: the nudge dataset","text":"Instead adding search filters, removing functional dependencies, try simplify original schema removing questionable relations. section bad idea. database : happens remove offending relations schema? offending relations removed, foreign key references involving . resulting schema isn’t invalid, ’s less connected . Calling autoref re-generate foreign key references doesn’t entirely fix problem, since, example, relation contains key title relation: partly happens removing relations removes information needs . remove relevant functional dependencies instead, can new intermediate relations appear new schema, whose dependencies originally redundant transitivity. Removing relations directly can’t account .","code":"show(nudge_db_filtered) nudge_schema_relfiltered <- nudge_schema_filtered[   vapply(     keys(nudge_schema_filtered),     \\(ks) all(lengths(ks) <= 2) &&       sum(c(\"publication_id\", \"reference\") %in% ks[[1]]) != 1,     logical(1)   ) ] show(nudge_schema_relfiltered) show(autoref(nudge_schema_relfiltered))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/nudge.html","id":"alternative-approach-hierarchical-limits","dir":"Articles","previous_headings":"","what":"Alternative approach: hierarchical limits","title":"A larger example: the nudge dataset","text":"alternative approach make use knowledge data hierarchical, remove dependencies attribute co-determining attribute lower level. example, publication-level attributes shouldn’t co-determine study- measurement-level attributes. means don’t find cases , decide cases spurious, don’t want spend time . Filtered result original data: Filtered result fixed data:","code":"hlev <- c(   publication_id = 3,   study_id = 2,   es_id = 1,   reference = 3,   title = 3,   year = 3,   location = 2,   domain = 2,   intervention_category = 2,   intervention_technique = 2,   type_experiment = 2,   population = 2,   n_study = 2,   n_comparison = 1,   n_control = 1,   n_intervention = 1,   binary_outcome = 1,   mean_control = 1,   sd_control = 1,   mean_intervention = 1,   sd_intervention = 1,   cohens_d = 1,   variance_d = 1,   approximation = 1,   wansink = 2 ) hfilter <- function(fds, hlev) {   fds[mapply(     \\(det, dep) all(hlev[det] <= hlev[[dep]]),     detset(fds),     dependant(fds)   )] } original_deps <- discover(   nudge,   exclude_class = \"numeric\",   detset_limit = 2 ) original_deps |>   hfilter(hlev) |>   normalise(remove_avoidable = TRUE) |>   decompose(df = nudge) |>   reduce() |>   show() fixed_deps <- discover(   nudge_fixed,   exclude_class = \"numeric\",   detset_limit = 2 ) fixed_deps |>   hfilter(hlev) |>   normalise(remove_avoidable = TRUE) |>   decompose(df = nudge_fixed) |>   show()"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/null.html","id":"missing-values","dir":"Articles","previous_headings":"","what":"Missing values","title":"Handling missing values","text":"functional dependency X→yX \\rightarrow y satisfied , two records whose values X equal, values y also equal. result equality comparisons must true false, otherwise ’s unclear interpret . forbids use missing values (NA NaN), problem much data handled R . autodb uses , believe, standard fix: instead searching functional dependencies, searches weaker variant, called literal functional dependency (LFD), treats missing values equal , equal anything else. LFDs generic standard FDs: since practically every class takes identity operator, make weak assumptions attribute classes present data set, can use just anything. FD variants handle missing values, LFDs noteworthy still satisfying Armstrong’s axioms. example, still respect transitivity: X→YX \\rightarrow Y Y→ZY \\rightarrow Z literally, X→ZX \\rightarrow Z literally. allows us construct database schema Bernstein synthesis, using LFDs instead FDs, get something coherent.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/null.html","id":"decomposing-to-remove-missing-values","dir":"Articles","previous_headings":"","what":"Decomposing to remove missing values","title":"Handling missing values","text":"However, ignoring special status missing values way ignores important structural information. Ideally, want avoid missing values, raise awkward questions handle missing comparison results filtering joining relations. example, take following data frame: autodb currently treats NA just another value, data kept together database schema: case, missing exit date represents exit date: patient still trial. make difference explicit – enforced – move exit information separate relation, containing patients exit date. removes need missing values. decomposition isn’t done autodb , can manually:","code":"df_nas <- data.frame(   patient = c(1L, 2L, 3L, 4L),   trial_entry_date = as.Date(c(\"2022/05/02\", \"2022/06/06\", \"2022/04/01\", \"2022/03/19\")),   trial_exit_date = as.Date(c(NA, NA, \"2022/10/07\", NA)) ) knitr::kable(df_nas) show(autodb(df_nas)) ds_trial <- database_schema(   relation_schema(     list(       patient = list(c(\"patient\", \"trial_entry_date\"), list(\"patient\")),       patient_exit = list(c(\"patient\", \"trial_exit_date\"), list(\"patient\"))     ),     names(df_nas)   ),   list(list(\"patient_exit\", \"patient\", \"patient\", \"patient\")) )  # approach 1: decompose, then remove ideal_db <- decompose(df_nas, ds_trial) records(ideal_db)$patient_exit <- subset(   records(ideal_db)$patient_exit,   !is.na(trial_exit_date) )  # approach 2: create and insert ideal_db2 <- create(ds_trial) |>   insert(df_nas, relations = \"patient\") |>   insert(subset(df_nas, !is.na(trial_exit_date)), relations = \"patient_exit\")  stopifnot(identical(ideal_db2, ideal_db)) show(ideal_db)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/null.html","id":"structure-conditional-on-value-presence","dir":"Articles","previous_headings":"","what":"Structure conditional on value presence","title":"Handling missing values","text":"case simple conditions values can missing, missing values introduce complications. example, whether attribute missing can depend whether attributes missing: Sets attributes missing non-missing together. Two sets attributes mutually exclusive: exactly one non-missing. sets might disjoint. common different records represent different types entity, use different attributes. Ideally, stored separate relations instead, often aren’t. data records knowledge values. can either known single values, interval associated distribution, may distribution parameters. format common listing model parameters. Since autodb doesn’t treat missing values special case, can detect relationships, resulting schema ignores : However, looking data , can see clearly-implied structure: Records either perfectly-known value, distribution value . two options separate attributes. Distribution information contains lower upper bound, distribution type. Different distributions different numbers distribution parameters, given shared parameter attributes. Parameter attributes ordered: can second parameter ’s first parameter. general hack finding sorts relationships, like taking attribute missing values, adding presence indicator attribute, states whether value present missing: always practical, adding columns rapidly increases search time dependency search. case, search time issue, makes structure database schema apparent: new information trivially true: attributes always determine presence. interest value_present relation, shows values, bounds, interval distributions inform presence : interval_distribution relation, can also see interval distribution determines many parameters required: can use enhanced database decide manually split actual database.","code":"df_options <- data.frame(   id = 1:20,   value = c(2.3, 2.3, 5.7, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),   lower_bound = c(NA_real_, NA_real_, NA_real_, 2.4, 0, 1, 0, 5.6, 2.4, 5.3, 5.3, 2.4, 2.4, 2.4, 2.4, 2.4, 2.4, 2.4, 5.6, 2.4),   upper_bound = c(NA_real_, NA_real_, NA_real_, 7.1, 10, 10, 13.1, 25.8, 10, 13.1, 10, 25.8, 25.8, 25.8, 25.8,13.1, 13.1, 25.8, 25.8, 25.8),   interval_distribution = factor(c(NA, NA, NA, \"uniform\", \"uniform\", \"uniform\", \"uniform\", \"uniform\", \"Beta\", \"Beta\", \"Beta\", \"Beta\", \"Kumaraswamy\", \"Kumaraswamy\", \"Kumaraswamy\", \"Kumaraswamy\", \"PERT\", \"PERT\", \"PERT\", \"PERT\")),   param1 = c(NA, NA, NA, NA, NA, NA, NA, NA, 1, 1, 1, 2, 2, 2.1, 2, 2, 2, 1, 2, 2),   param2 = c(NA, NA, NA, NA, NA, NA, NA, NA, 1, 2, 2, 2, 2, 1, 1, 1, NA, NA, NA, NA) ) knitr::kable(df_options) db_options <- autodb(df_options) show(db_options) df_options_presence <- df_options[vapply(df_options, anyNA, logical(1))] df_options_presence[] <- lapply(df_options_presence, Negate(is.na)) names(df_options_presence) <- paste0(names(df_options_presence), \"_present\") df_options_with_presence <- cbind(df_options, df_options_presence) db_options_with_presence <- autodb(df_options_with_presence) show(db_options_with_presence) knitr::kable(records(db_options_with_presence)$value_present) knitr::kable(records(db_options_with_presence)$interval_distribution)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/plans.html","id":"views-for-bcnf-and-connected-reference-chains","dir":"Articles","previous_headings":"","what":"Views for BCNF and connected reference chains","title":"Planned improvements","text":"Two features ’d like add autodb issues current implementation, solved allowing restricted version virtual relations, commonly known views. ’ll show issues first.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/plans.html","id":"boyes-codd-normal-form","dir":"Articles","previous_headings":"Views for BCNF and connected reference chains","what":"Boyes-Codd Normal Form","title":"Planned improvements","text":"autodb currently normalises data third normal form (3NF). (Actually, normalises slightly strong form called elementary key normal form, issue presented ). Third normal form can formally defined follows: database third normal form (3NF) relations 3NF. relation 3NF non-trivial functional dependencies X→yX \\rightarrow y satisfied attributes satisfy one following: XX superkey (.e. contains one relation’s keys); yy member key. functional dependency (FD) X→yX \\rightarrow y trivial yy XX, .e. states attribute co-determines , trivially true. Boyes-Codd normal form (BCNF) strengthens dropping second condition. (Conversely, second normal form weakens adding third option: XX subkey, .e. contained one keys.) see difference 3NF BCNF, consider following set FDs, resulting schema given autodb: schema 3NF, BCNF: Relation c contains one FD: {c}→\\{c\\} \\rightarrow . Since {c}\\{c\\} key, relation c 3NF, BCNF. Relation a_b contains two FDs: {,b}→c\\{, b\\} \\rightarrow c {c}→\\{c\\} \\rightarrow . {,b}\\{, b\\} key a_b, {c}\\{c\\} , a_b BCNF. However, aa within key \\{, b\\}, relation a_b 3NF. fact, autodb required : relation a_b 3NF, contains attributes, don’t need relation c. double appearance {c}→\\{c\\} \\rightarrow results redundancy: ’re listing resulting (c, ) pairs twice. Even worse, one enforced via key: , normalising, add data two relations separately, can two sets (c, ) pairs aren’t mutually coherent : remove relation c, still problem, relation a_b doesn’t enforce {c}→\\{c\\} \\rightarrow key, can easily insert data violates . standard way fix schema satisfy BCNF splitting relation a_b violated functional dependency, namely c -> : now BCNF: relation c BCNF reasons , relation b_c contains FDs , required decomposition lossless. now different issue: FD \\{, b\\} \\rightarrow c isn’t represented anywhere, let alone enforced key! example BCNF sometimes can’t achieved using just (real) relations. can keep FD noting somewhere, ’d call nice approach. also raises questions plot schema nicely: don’t want just list non-represented FDs sitting corner plot. problem BCNF introduced, ’s often added rare occurrence practice, usually can normalise 3NF get BCNF free, without issue. say , almost every real dataset ’ve worked , normalising autodb demonstrated subsection data exactly three-attribute situation shown example .","code":"fds <- functional_dependency(   list(list(c(\"a\", \"b\"), \"c\"), list(\"c\", \"a\")),   letters[1:3] ) fds ## 2 functional dependencies ## 3 attributes: a, b, c ## a, b -> c ##    c -> a schema <- normalise(fds) show(schema) db <- schema |>   create() |>   insert(data.frame(c = 1:2, a = 1:2), relations = \"c\") |>   insert(data.frame(a = 1:2, b = 1L, c = 2:1), relations = \"a_b\") rab <- records(db)$a_b rc <- records(db)$c knitr::kable(rab) knitr::kable(rc) knitr::kable(merge(rab, rc, by = \"c\", suffixes = c(\".a_b\", \".c\")))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/plans.html","id":"reference-chains","dir":"Articles","previous_headings":"Views for BCNF and connected reference chains","what":"Reference chains","title":"Planned improvements","text":"described , Boyes-Codd normal form can always represented just (real) relations. However, want desirable properties foreign key references, run problems third normal form . autodb, autoref, generates foreign key references relations decomposed single table, naturally tends structure single low-level data relation left – several original data independent partitions – higher-level relations “downstream” respect references, number records strictly decreasing follow references higher-level data relations. resulting database schema acyclic. Acyclic database schemas nice properties, important one , want join together two relations common attributes, always way joining along foreign key references. Similarly, ’s simple reconstruct original simple table: just join relations back together “telescoping” back along foreign key references. Considering rejoin plan reverse, schema created constructively, can view series decompositions: start original table, split two sub-tables, linked together foreign key references, repeat. Rejoining database undoes decompositions, opposite order. Unfortunately, every set functional dependencies allows , resulting schema might connected. Consider following set FDs: Bernstein synthesis, automatic foreign keys, give following schema: schema connected: relation d_e stranded, relation contains key, vice versa. terms series decompositions, think original table split {,b,c,d,e} {d,e,f} first, \\{d, e\\} forming foreign key reference, d e split apart later, destroying reference. Similarly example BCNF, undesirable consequences add data normalisation: d_e isolated, can insert data inconsistent relations rejoin everything back together.","code":"fds <- functional_dependency(   list(     list(\"a\", \"b\"),     list(\"a\", \"c\"),     list(\"b\", \"d\"),     list(\"c\", \"e\"),     list(c(\"d\", \"e\"), \"f\")   ),   letters[1:6] ) fds ## 5 functional dependencies ## 6 attributes: a, b, c, d, e, f ##    a -> b ##    a -> c ##    b -> d ##    c -> e ## d, e -> f schema <- normalise(fds) show(schema)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/plans.html","id":"views-as-a-solution","dir":"Articles","previous_headings":"Views for BCNF and connected reference chains","what":"Views as a solution","title":"Planned improvements","text":"Virtual relations, views, defined result operation relations (real virtual). real databases, might done convenient way refer result joining tables, aggregating values non-trivial way, code doesn’t need repeated. Virtual relations don’t store data : ’re queried, ’re created scratch, ’re never inconsistent relations ’re defined . , use restricted version views, defined join relations. Views always least one key, implied relations ’re joining. extend letting non-implied keys, required hold join result. Let’s see can solve issue BCNF example, normalising left FD {,b}→c\\{, b\\} \\rightarrow c represented schema: view darker background, points relations ’s calculated using different arrows, mark different. Note points one relation (b_c), implication first joins table ancestors (c). view implied key {b,c}\\{b, c\\}, show missing FD {,b}→c\\{, b\\} \\rightarrow c giving {,b}\\{, b\\} additional key. Note view contains aa cc. However, unlike original schema, repeat occurrence {c}→\\{c\\} \\rightarrow , data taken directly appearance relation c. ’s also worth noting , since view just original 3NF solution, BCNF . Views need high normal form database ’re . ’s views solve issue 3NF example: , note view 3NF , since contains implied transitive dependencies. might seem unnecessary bring attribute view, since need attributes relations b c connect d_e. However, creating view without either doesn’t result acyclic schema,, requires real relation foreign key reference view: latter isn’t wrong – referring view really means referring relations gets decomposed – take getting used , especially , like , “key” referred isn’t shown, ’s implied decomposition. also bring “view” must viewed something ’s decomposed, result Cartesian join components. latter result view containing many records. explicitly show decomposition steps views, ’s clear ’s worth bother:","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/plans.html","id":"proper-handling-of-nullable-data","dir":"Articles","previous_headings":"","what":"Proper handling of nullable data","title":"Planned improvements","text":"addresses decompose data NA values. See Handling missing values vignette (vignette(\"null\", package = \"autodb\")) details currently manually. plan allow incorporating process search, long way worked fully.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/plans.html","id":"handling-of-duplicate-records","dir":"Articles","previous_headings":"","what":"Handling of duplicate records","title":"Planned improvements","text":"Relational theory based data given relations, duplicate records. However, ’s expected R user might pass data frame duplicates: example, R comes datasets, iris, duplicates don’t include row names. moment, duplicates kept searching dependencies. can affect results approximate dependencies, since changes many records must removed given dependency satisfied. However, duplicates still removed data frame decomposed database. moment, ’m certain whether duplicates best handled removing beginning search, simply returning error duplicate records.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mark Webster. Author, maintainer.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Webster M (2025). autodb: Automatic Database Normalisation Data Frames. R package version 3.1.0.9000, https://charnelmouse.github.io/autodb/.","code":"@Manual{,   title = {autodb: Automatic Database Normalisation for Data Frames},   author = {Mark Webster},   year = {2025},   note = {R package version 3.1.0.9000},   url = {https://charnelmouse.github.io/autodb/}, }"},{"path":"https://charnelmouse.github.io/autodb/dev/index.html","id":"autodb","dir":"","previous_headings":"","what":"Automatic Database Normalisation for Data Frames","title":"Automatic Database Normalisation for Data Frames","text":"autodb R package automatic normalisation data frame third normal form, intention easing process data cleaning. (Usage design actual database advised.)","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Automatic Database Normalisation for Data Frames","text":"Install stable released version CRAN : Install unstable development version GitHub :","code":"install.packages(\"autodb\") # install.packages(\"devtools\") devtools::install_github(\"CharnelMouse/autodb\")"},{"path":"https://charnelmouse.github.io/autodb/dev/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Automatic Database Normalisation for Data Frames","text":"Turning simple data frame database:  Using exclude argument forbid certain variables appearing keys:   also functions step database creation separately, including functional dependency detection normalisation. See vignette details.","code":"library(autodb) #>  #> Attaching package: 'autodb' #> The following object is masked from 'package:stats': #>  #>     decompose summary(ChickWeight) #>      weight           Time           Chick     Diet    #>  Min.   : 35.0   Min.   : 0.00   13     : 12   1:220   #>  1st Qu.: 63.0   1st Qu.: 4.00   9      : 12   2:120   #>  Median :103.0   Median :10.00   20     : 12   3:120   #>  Mean   :121.8   Mean   :10.72   10     : 12   4:118   #>  3rd Qu.:163.8   3rd Qu.:16.00   17     : 12           #>  Max.   :373.0   Max.   :21.00   19     : 12           #>                                  (Other):506 db <- autodb(ChickWeight) db #> database with 2 relations #> 4 attributes: weight, Time, Chick, Diet #> relation Chick: Chick, Diet; 50 records #>   key 1: Chick #> relation Time_Chick: Time, Chick, weight; 578 records #>   key 1: Time, Chick #> references: #> Time_Chick.{Chick} -> Chick.{Chick} graphviz_text <- gv(db) DiagrammeR::grViz(graphviz_text) summary(CO2) #>      Plant             Type         Treatment       conc          uptake      #>  Qn1    : 7   Quebec     :42   nonchilled:42   Min.   :  95   Min.   : 7.70   #>  Qn2    : 7   Mississippi:42   chilled   :42   1st Qu.: 175   1st Qu.:17.90   #>  Qn3    : 7                                    Median : 350   Median :28.30   #>  Qc1    : 7                                    Mean   : 435   Mean   :27.21   #>  Qc3    : 7                                    3rd Qu.: 675   3rd Qu.:37.12   #>  Qc2    : 7                                    Max.   :1000   Max.   :45.50   #>  (Other):42 db2_noexclude <- autodb(CO2) db2_noexclude #> database with 3 relations #> 5 attributes: Plant, Type, Treatment, conc, uptake #> relation Plant: Plant, Type, Treatment; 12 records #>   key 1: Plant #> relation Plant_conc: Plant, conc, Treatment, uptake; 84 records #>   key 1: Plant, conc #>   key 2: Treatment, conc, uptake #> relation conc_uptake: conc, uptake, Type; 82 records #>   key 1: conc, uptake #> references: #> Plant_conc.{Plant} -> Plant.{Plant} #> Plant_conc.{conc, uptake} -> conc_uptake.{conc, uptake} graphviz_text2_noexclude <- gv(db2_noexclude) DiagrammeR::grViz(graphviz_text2_noexclude) db2 <- autodb(CO2, exclude = \"uptake\") db2 #> database with 2 relations #> 5 attributes: Plant, Type, Treatment, conc, uptake #> relation Plant: Plant, Type, Treatment; 12 records #>   key 1: Plant #> relation Plant_conc: Plant, conc, uptake; 84 records #>   key 1: Plant, conc #> references: #> Plant_conc.{Plant} -> Plant.{Plant} graphviz_text2 <- gv(db2) DiagrammeR::grViz(graphviz_text2)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational data attributes — attrs","title":"Relational data attributes — attrs","text":"Generic function, fetching attribute sets elements relational object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational data attributes — attrs","text":"","code":"attrs(x, ...)  attrs(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational data attributes — attrs","text":"x relational schema object, relation_schema database_schema object, relational data object, relation database object. ... arguments passed methods. value character vector length attrs(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational data attributes — attrs","text":"list, containing character vector element x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational data attribute order — attrs_order","title":"Relational data attribute order — attrs_order","text":"Generic function, fetching attribute order relational objects.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational data attribute order — attrs_order","text":"","code":"attrs_order(x, ...)  attrs_order(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational data attribute order — attrs_order","text":"x R object, functional_dependency, relation_schema, relation, database_schema, database object. ... arguments passed methods. value character vector length attrs_order(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational data attribute order — attrs_order","text":"character vector, giving attributes order prioritised sorting within x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relational data attribute order — attrs_order","text":"classes autodb contain attrs_order attribute. gives easy way find list attributes/variables involved object, main purpose also assign attributes consistent order printing plotting object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Database-style normalisation for data.frames — autodb-package","title":"Database-style normalisation for data.frames — autodb-package","text":"Automatic normalisation data.frame third normal form, intention easing process data cleaning. (Usage design actual database advised.) Originally inspired Alteryx's AutoNormalize Python library (https://github.com/alteryx/autonormalize), various changes improvements. Automatic discovery functional approximate dependencies, normalisation based , plotting resulting \"database\" via Graphviz, options exclude attributes discovery time, remove discovered dependencies normalisation time.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Database-style normalisation for data.frames — autodb-package","text":"Maintainer: Mark Webster markwebster204@yahoo.co.uk (ORCID)","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a normalised database from a data frame — autodb","title":"Create a normalised database from a data frame — autodb","text":"wrapper function applying normalise, autoref, decompose. takes data frame converts straight database, main intended use case package.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a normalised database from a data frame — autodb","text":"","code":"autodb(   df,   keep_rownames = FALSE,   digits = getOption(\"digits\"),   single_ref = FALSE,   ensure_lossless = TRUE,   remove_avoidable = FALSE,   constants_name = \"constants\",   progress = FALSE,   progress_file = \"\",   ... )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a normalised database from a data frame — autodb","text":"df data.frame, containing data normalised. keep_rownames logical string, indicating whether include row names column. string given, used name column, otherwise column named \"row\". Like column names, function returns error results duplicate column names. Set FALSE default. digits positive integer, indicating many significant digits used numeric complex variables. used pre-formatting discover, rounding data use decompose, data satisfies resulting schema. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See \"Floating-point variables\" section discover rounding necessary consistent results across different machines. See note print.default digits >=   16. single_ref logical, FALSE default. TRUE, one reference relation pair kept generating foreign key references. pair multiple references, kept reference refers earliest key child relation, sorted priority order. ensure_lossless logical, indicating whether check whether normalisation lossless. , additional relation added final \"database\", containing key df. enough make normalisation lossless. remove_avoidable logical, indicating whether remove avoidable attributes relations. , attribute removed relations keys can changed needed preserve given functional dependencies. constants_name scalar character, giving name relation created store constant attributes. generated relation name, changed, warning, ensure relations unique name. progress logical, whether display progress user dependency search discover. progress_file scalar character connection. progress non-zero, determines progress written , way file argument cat. ... arguments passed discover.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a normalised database from a data frame — autodb","text":"database, containing data df within inferred database schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a normalised database from a data frame — autodb","text":"Since decompose works functional dependencies, approximate dependencies, accuracy discover fixed 1.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a normalised database from a data frame — autodb","text":"","code":"# simple example autodb(ChickWeight) #> database with 2 relations #> 4 attributes: weight, Time, Chick, Diet #> relation Chick: Chick, Diet; 50 records #>   key 1: Chick #> relation Time_Chick: Time, Chick, weight; 578 records #>   key 1: Time, Chick #> references: #> Time_Chick.{Chick} -> Chick.{Chick}"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":null,"dir":"Reference","previous_headings":"","what":"Add foreign key references to a normalised database — autoref","title":"Add foreign key references to a normalised database — autoref","text":"Adds foreign key references relation_schema object automatically, replacing existing references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add foreign key references to a normalised database — autoref","text":"","code":"autoref(schema, single_ref = FALSE)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add foreign key references to a normalised database — autoref","text":"schema relation_schema object, given synthesise. single_ref logical, FALSE default. TRUE, one reference relation pair kept generating foreign key references. pair multiple references, kept reference refers earliest key child relation, sorted priority order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add foreign key references to a normalised database — autoref","text":"database_schema object, containing given relation schemas created foreign key references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add foreign key references to a normalised database — autoref","text":"method generating references simple. First, finds every link two relation schemas, parent contains attributes one child's keys. can done separately child's keys, can multiple links parent child single_ref TRUE. Second, transitive references removed: link relation pairs -> b, b -> c, -> c, latter transitive, removed. cyclic reference, e.g. c -> , choice link remove arbitrary. Cycles occur sets relation schemas resulting decomposing single table.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add foreign key references to a normalised database — autoref","text":"","code":"rs <- relation_schema(   list(     a_b_c = list(c(\"a\", \"b\", \"c\", \"d\"), list(c(\"a\", \"b\", \"c\"))),     a_b = list(c(\"a\", \"b\", \"d\"), list(c(\"a\", \"b\"), c(\"b\", \"d\")))   ),   letters[1:4] ) autoref(rs, single_ref = FALSE) #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a_b_c: a, b, c, d #>   key 1: a, b, c #> schema a_b: a, b, d #>   key 1: a, b #>   key 2: b, d #> references: #> a_b_c.{a, b} -> a_b.{a, b} #> a_b_c.{b, d} -> a_b.{b, d} autoref(rs, single_ref = TRUE) #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a_b_c: a, b, c, d #>   key 1: a, b, c #> schema a_b: a, b, d #>   key 1: a, b #>   key 2: b, d #> references: #> a_b_c.{a, b} -> a_b.{a, b}"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create instance of a schema — create","title":"Create instance of a schema — create","text":"Create relation data object, using given relational schema object, resulting relations empty ready data insertion using insert.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create instance of a schema — create","text":"","code":"create(x, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create instance of a schema — create","text":"x relational schema object, representing schema create instance , relation_schema database_schema object. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create instance of a schema — create","text":"instance schema. example, calling create database_schema creates database, relations contain zero records.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.data.frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate D2 input text to plot a data frame — d2.data.frame","title":"Generate D2 input text to plot a data frame — d2.data.frame","text":"Produces text input D2 make diagram given data frame, usually rendered SVG.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.data.frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate D2 input text to plot a data frame — d2.data.frame","text":"","code":"# S3 method for class 'data.frame' d2(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.data.frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate D2 input text to plot a data frame — d2.data.frame","text":"x data.frame. name character scalar, giving name record, . name must non-empty, since also used name single table plot. Defaults NA: left missing, set \"data\". ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.data.frame.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate D2 input text to plot a data frame — d2.data.frame","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.data.frame.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate D2 input text to plot a data frame — d2.data.frame","text":"rows plotted data frame include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate D2 input text to plot databases — d2.database","title":"Generate D2 input text to plot databases — d2.database","text":"Produces text input D2 make diagram given database, usually rendered SVG.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate D2 input text to plot databases — d2.database","text":"","code":"# S3 method for class 'database' d2(x, name = NA_character_, reference_level = c(\"attr\", \"relation\"), ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate D2 input text to plot databases — d2.database","text":"x database. name character scalar, giving name schema, . reference_level character scalar, indicating format use foreign key references. \"relation\" specifies relations involved; \"attr\" also specifies attributes involved, one pair time. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate D2 input text to plot databases — d2.database","text":"scalar character, containing text input D2.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate D2 input text to plot databases — d2.database","text":"relation database presented set rows, one attribute relation. rows include information attribute classes. foreign key references represented arrows either attribute pairs relation pairs, depending value reference_level. allows output geared towards specific layout engine. engines currently available D2, Dagre can plot references relation attributes, just attributes , using reference_level = \"relation\" prevents compound foreign keys resulting duplicate reference arrows. ELK Tala can plot relation attributes, default reference_level = \"attr\" works intended.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate D2 input text to plot database schemas — d2.database_schema","title":"Generate D2 input text to plot database schemas — d2.database_schema","text":"Produces text input D2 make diagram given database schema, usually rendered SVG.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate D2 input text to plot database schemas — d2.database_schema","text":"","code":"# S3 method for class 'database_schema' d2(x, name = NA_character_, reference_level = c(\"attr\", \"relation\"), ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate D2 input text to plot database schemas — d2.database_schema","text":"x database schema, given database_schema normalise. name character scalar, giving name schema, . reference_level character scalar, indicating format use foreign key references. \"relation\" specifies relations involved; \"attr\" also specifies attributes involved, one pair time. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate D2 input text to plot database schemas — d2.database_schema","text":"scalar character, containing text input D2.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.database_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate D2 input text to plot database schemas — d2.database_schema","text":"relation schema presented set rows, one attribute relation. rows include information attribute classes. foreign key references represented arrows either attribute pairs relation pairs, depending value reference_level. allows output geared towards specific layout engine. engines currently available D2, Dagre can plot references relation attributes, just attributes , using reference_level = \"relation\" prevents compound foreign keys resulting duplicate reference arrows. ELK Tala can plot relation attributes, default reference_level = \"attr\" works intended.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate D2 input text to plot objects — d2","title":"Generate D2 input text to plot objects — d2","text":"Produces text input D2 make diagram given object, usually rendered SVG.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate D2 input text to plot objects — d2","text":"","code":"d2(x, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate D2 input text to plot objects — d2","text":"x object plotted. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate D2 input text to plot objects — d2","text":"scalar character, containing text input D2.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate D2 input text to plot objects — d2","text":"D2 language early stage development (pre-v1.0), may subject changes make unable use output current version d2. Details plotted given individual methods. expected commonalities, described . object expected one following: object whose elements length. Examples data frames, matrices, objects can represent relations, names elements, optional name object . graph sub-objects, represent relation described , possibly connections objects, optional name graph whole. relation presented record-like shape, following elements: optional header relation's name, number (unique) records. set rows, one attribute relation. rows following contents: attribute names. depiction relation's (candidate) keys. column represents key, filled cell indicates attribute row key. keys given lexical order, precedence given keys fewer attributes, keys attributes appear earlier original data frame's attribute order. Default output package functions thus primary key given first. future, changed always give primary key first. optionally, attribute types: specifically, first element passing attribute's values class. foreign key references relations represented one-way arrows, one per attribute foreign key. object name, currently name used, except single data frame's name. future, used give name generated board, make use D2's composition features.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate D2 input text to plot objects — d2","text":"","code":"# simple data.frame example cat(d2(ChickWeight, \"chick\")) #> direction: right #> \"chick\": \"chick (578 rows)\" { #>   shape: sql_table #>   \"weight\": numeric #>   \"Time\": numeric #>   \"Chick\": ordered #>   \"Diet\": factor #> }"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate D2 input text to plot relations — d2.relation","title":"Generate D2 input text to plot relations — d2.relation","text":"Produces text input D2 make diagram given relation, usually rendered SVG.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate D2 input text to plot relations — d2.relation","text":"","code":"# S3 method for class 'relation' d2(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate D2 input text to plot relations — d2.relation","text":"x relation. name character scalar, giving name schema, . ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate D2 input text to plot relations — d2.relation","text":"scalar character, containing text input D2.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate D2 input text to plot relations — d2.relation","text":"relation presented set rows, one attribute relation. rows include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate D2 input text to plot relation schemas — d2.relation_schema","title":"Generate D2 input text to plot relation schemas — d2.relation_schema","text":"Produces text input D2 make diagram given relation schema, usually rendered SVG.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate D2 input text to plot relation schemas — d2.relation_schema","text":"","code":"# S3 method for class 'relation_schema' d2(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate D2 input text to plot relation schemas — d2.relation_schema","text":"x relation schema, given relation_schema synthesise. name character scalar, giving name schema, . ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate D2 input text to plot relation schemas — d2.relation_schema","text":"scalar character, containing text input D2.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/d2.relation_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate D2 input text to plot relation schemas — d2.relation_schema","text":"relation schema presented set rows, one attribute relation. rows include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":null,"dir":"Reference","previous_headings":"","what":"Databases — database","title":"Databases — database","text":"Enhances relation object foreign key reference information.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Databases — database","text":"","code":"database(relations, references, check = TRUE)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Databases — database","text":"relations relation object. references list references, represented list containing four character elements. order, elements scalar giving name child (referrer) schema, vector giving child attribute names, scalar giving name parent (referee) schema, vector giving parent attribute names. vectors must length contain names attributes present respective schemas, parent attributes must form key. check logical, indicating whether check relations satisfies foreign key references given references creating result. redundant relations references constructed based functional dependencies, using autodb. set FALSE references definitely satisfied: checking references violate data result invalid database, detected operated .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Databases — database","text":"database object, containing relations references stored attribute name. References stored attributes order appear respective relations.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Databases — database","text":"Unlike relation_schema relation, like database_schema, database designed vector-like: holds single database. adheres usual package use case, single data frame analysed time. However, inherits relation, vectorised respect relations. relation, duplicate relations, ordering attribute, allowed, can removed unique. References, .e. foreign key references, allowed different attribute names child parent relations; occur output autoref normalise. Subsetting removes references involve removed relations. Removing duplicates unique changes references involving duplicates involve kept equivalent relations instead. Renaming relations names<- also changes names references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Databases — database","text":"","code":"rels <- relation(   list(     a = list(       df = data.frame(a = logical(), b = logical()),       keys = list(\"a\")     ),     b = list(       df = data.frame(b = logical(), c = logical()),       keys = list(\"b\", \"c\")     )   ),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) db <- database(   rels,   list(list(\"a\", \"b\", \"b\", \"b\")) ) print(db) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} attrs(db) #> $a #> [1] \"a\" \"b\" #>  #> $b #> [1] \"b\" \"c\" #>  stopifnot(identical(   attrs(db),   lapply(records(db), names) )) keys(db) #> $a #> $a[[1]] #> [1] \"a\" #>  #>  #> $b #> $b[[1]] #> [1] \"b\" #>  #> $b[[2]] #> [1] \"c\" #>  #>  attrs_order(db) #> [1] \"a\" \"b\" \"c\" \"d\" names(db) #> [1] \"a\" \"b\" references(db) #> [[1]] #> [[1]][[1]] #> [1] \"a\" #>  #> [[1]][[2]] #> [1] \"b\" #>  #> [[1]][[3]] #> [1] \"b\" #>  #> [[1]][[4]] #> [1] \"b\" #>  #>   # relations can't reference themselves if (FALSE) { # \\dontrun{   database(     relation(       list(a = list(df = data.frame(a = 1:5), keys = list(\"a\"))),       c(\"a\", \"b\")     ),     list(list(\"a\", \"a\", \"a\", \"a\"))   )   database(     relation(       list(a = list(df = data.frame(a = 1:5, b = 6:10), keys = list(\"a\"))),       c(\"a\", \"b\")     ),     list(list(\"a\", \"b\", \"a\", \"a\"))   ) } # }  # an example with references between differently-named attributes print(database(   relation(     list(       citation = list(         df = data.frame(citer = 1:5, citee = 6:10),         keys = list(c(\"citer\", \"citee\"))       ),       article = list(df = data.frame(article = 1:10), keys = list(\"article\"))     ),     c(\"citer\", \"citee\", \"article\")   ),   list(     list(\"citation\", \"citer\", \"article\", \"article\"),     list(\"citation\", \"citee\", \"article\", \"article\")   ) )) #> database with 2 relations #> 3 attributes: citer, citee, article #> relation citation: citer, citee; 5 records #>   key 1: citer, citee #> relation article: article; 10 records #>   key 1: article #> references: #> citation.{citer} -> article.{article} #> citation.{citee} -> article.{article}  # inserting data insert(db, data.frame(a = 1L, b = 2L, c = 3L, d = 4L)) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} # data is only inserted into relations where all columns are given... insert(db, data.frame(a = 1L, b = 2L, c = 3L)) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} # and that are listed in relations argument insert(   db,   data.frame(a = 1L, b = 2L, c = 3L, d = 4L),   relations = \"b\" ) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} # inserted data can't violate keys if (FALSE) { # \\dontrun{   insert(     db,     data.frame(a = 1L, b = 1:2)   ) } # } # inserted data can't violate foreign key references if (FALSE) { # \\dontrun{   insert(     db,     data.frame(a = 1L, b = 2L, c = 3L, d = 4L),     relations = \"a\"   ) } # }  # vector operations db2 <- database(   relation(     list(       e = list(df = data.frame(a = 1:5, e = 6:10), keys = list(\"e\"))     ),     attrs_order = c(\"a\", \"e\")   ),   list() ) c(db, db2) # attrs_order attributes are merged #> database with 3 relations #> 5 attributes: a, b, c, d, e #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation e: e, a; 5 records #>   key 1: e #> references: #> a.{b} -> b.{b} unique(c(db, db)) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b}  # subsetting db[1] #> database with 1 relation #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> no references stopifnot(identical(db[[1]], db[1])) db[c(1, 2, 1, 2)] # replicates the foreign key references #> database with 4 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation a.1: a, b; 0 records #>   key 1: a #> relation b.1: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} #> a.{b} -> b.1.{b} #> a.1.{b} -> b.{b} #> a.1.{b} -> b.1.{b} c(db[c(1, 2)], db[c(1, 2)]) # doesn't reference between separate copies of db #> database with 4 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation a.1: a, b; 0 records #>   key 1: a #> relation b.1: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} #> a.1.{b} -> b.1.{b} unique(db[c(1, 2, 1, 2)]) # unique() also merges references #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b}  # another example of unique() merging references db_merge <- database(   relation(     list(       a = list(         df = data.frame(a = logical(), b = logical()),         keys = list(\"a\")       ),       b = list(         df = data.frame(b = logical(), c = logical(), d = logical()),         keys = list(\"b\")       ),       c_d = list(         df = data.frame(c = logical(), d = logical(), e = logical()),         keys = list(c(\"c\", \"d\"))       ),       a.1 = list(         df = data.frame(a = logical(), b = logical()),         keys = list(\"a\")       ),       b.1 = list(         df = data.frame(b = logical(), c = logical(), d = logical()),         keys = list(\"b\")       )     ),     c(\"a\", \"b\", \"c\", \"d\", \"e\")   ),   list(     list(\"a\", \"b\", \"b\", \"b\"),     list(\"b.1\", c(\"c\", \"d\"), \"c_d\", c(\"c\", \"d\"))   ) ) print(db_merge) #> database with 5 relations #> 5 attributes: a, b, c, d, e #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c, d; 0 records #>   key 1: b #> relation c_d: c, d, e; 0 records #>   key 1: c, d #> relation a.1: a, b; 0 records #>   key 1: a #> relation b.1: b, c, d; 0 records #>   key 1: b #> references: #> a.{b} -> b.{b} #> b.1.{c, d} -> c_d.{c, d} unique(db_merge) #> database with 3 relations #> 5 attributes: a, b, c, d, e #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c, d; 0 records #>   key 1: b #> relation c_d: c, d, e; 0 records #>   key 1: c, d #> references: #> a.{b} -> b.{b} #> b.{c, d} -> c_d.{c, d}  # reassignment # can't change keys included in references if (FALSE) keys(db)[[2]] <- list(\"c\") # \\dontrun{} # can't remove attributes included in keys if (FALSE) attrs(db)[[2]] <- list(\"c\", \"d\") # \\dontrun{} # can't remove attributes included in references if (FALSE) attrs(db)[[1]] <- c(\"a\", \"d\") # \\dontrun{} db3 <- db # can change subset of schema, but loses references between altered and # non-altered subsets db3[2] <- database(   relation(     list(d = list(df = data.frame(d = logical(), c = logical()), keys = list(\"d\"))),     attrs_order(db3)   ),   list() ) print(db3) # note the schema's name doesn't change #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: d, c; 0 records #>   key 1: d #> no references # names(db3)[2] <- \"d\" # this would change the name keys(db3)[[2]] <- list(character()) # removing keys first... # for a database_schema, we could then change the attrs for # the second database. For a created relation, this is not # allowed. if (FALSE) { # \\dontrun{   attrs(db3)[[2]] <- c(\"b\", \"c\")   names(records(db3)[[2]]) <- c(\"b\", \"c\") } # }  # changing appearance priority for attributes attrs_order(db3) <- c(\"d\", \"c\", \"b\", \"a\") print(db3) #> database with 2 relations #> 4 attributes: d, c, b, a #> relation a: a, b; 0 records #>   key 1: a #> relation b: d, c; 0 records #>   key 1:  #> no references  # changing relation schema names changes them in references names(db3) <- paste0(names(db3), \"_long\") print(db3) #> database with 2 relations #> 4 attributes: d, c, b, a #> relation a_long: a, b; 0 records #>   key 1: a #> relation b_long: d, c; 0 records #>   key 1:  #> no references  # reconstructing from components db_recon <- database(   relation(     Map(list, df = records(db), keys = keys(db)),     attrs_order(db)   ),   references(db) ) stopifnot(identical(db_recon, db)) db_recon2 <- database(   subrelations(db),   references(db) ) stopifnot(identical(db_recon2, db))  # can be a data frame column data.frame(id = 1:2, relation = db) #>   id               relation #> 1  1 relation a (0 records) #> 2  2 relation b (0 records)  # setting check = FALSE can give invalid databases chickfds <- discover(ChickWeight) chickschema <- synthesise(chickfds) chickrels <- insert(create(chickschema), ChickWeight) badrefs <- list(list(\"Time_Chick\", \"weight\", \"Chick\", \"Chick\")) # check = TRUE stops on non-satisfied references if (FALSE) database(chickrels, badrefs) # \\dontrun{} # check = FALSE returns an invalid database baddb <- database(chickrels, badrefs, check = FALSE) # only returns an error when further manipulated by certain methods if (FALSE) insert(baddb, ChickWeight) # \\dontrun{}"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Database schemas — database_schema","title":"Database schemas — database_schema","text":"Enhances relation_schema object foreign key reference information.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Database schemas — database_schema","text":"","code":"database_schema(relation_schemas, references)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Database schemas — database_schema","text":"relation_schemas relation_schema object, returned synthesise relation_schema. references list references, represented list containing four character elements. order, elements scalar giving name child (referrer) schema, vector giving child attribute names, scalar giving name parent (referee) schema, vector giving parent attribute names. vectors must length contain names attributes present respective schemas, parent attributes must form key.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Database schemas — database_schema","text":"database_schema object, containing relation_schemas references stored attribute name. References stored attributes order appear respective relation schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Database schemas — database_schema","text":"Unlike functional_dependency relation_schema, database_schema designed vector-like: holds single database schema. adheres usual package use case, single data frame analysed time. However, inherits relation_schema, vectorised respect relation schemas. relation_schema, duplicate relation schemas, ordering attribute, allowed, can removed unique. References, .e. foreign key references, allowed different attribute names child parent relations; occur output autoref normalise. Subsetting removes references involve removed relation schemas. Removing duplicates unique changes references involving duplicates involve kept equivalent schemas instead. Renaming relation schemas names<- also changes names references.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Database schemas — database_schema","text":"","code":"rs <- relation_schema(   list(     a = list(c(\"a\", \"b\"), list(\"a\")),     b = list(c(\"b\", \"c\"), list(\"b\", \"c\"))   ),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) ds <- database_schema(   rs,   list(list(\"a\", \"b\", \"b\", \"b\")) ) print(ds) #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} attrs(ds) #> $a #> [1] \"a\" \"b\" #>  #> $b #> [1] \"b\" \"c\" #>  keys(ds) #> $a #> $a[[1]] #> [1] \"a\" #>  #>  #> $b #> $b[[1]] #> [1] \"b\" #>  #> $b[[2]] #> [1] \"c\" #>  #>  attrs_order(ds) #> [1] \"a\" \"b\" \"c\" \"d\" names(ds) #> [1] \"a\" \"b\" references(ds) #> [[1]] #> [[1]][[1]] #> [1] \"a\" #>  #> [[1]][[2]] #> [1] \"b\" #>  #> [[1]][[3]] #> [1] \"b\" #>  #> [[1]][[4]] #> [1] \"b\" #>  #>   # relations can't reference themselves if (FALSE) { # \\dontrun{   database_schema(     relation_schema(       list(a = list(\"a\", list(\"a\"))),       c(\"a\", \"b\")     ),     list(list(\"a\", \"a\", \"a\", \"a\"))   )   database_schema(     relation_schema(       list(a = list(c(\"a\", \"b\"), list(\"a\"))),       c(\"a\", \"b\")     ),     list(list(\"a\", \"b\", \"a\", \"a\"))   ) } # }  # an example with references between differently-named attributes print(database_schema(   relation_schema(     list(       citation = list(c(\"citer\", \"citee\"), list(c(\"citer\", \"citee\"))),       article = list(\"article\", list(\"article\"))     ),     c(\"citer\", \"citee\", \"article\")   ),   list(     list(\"citation\", \"citer\", \"article\", \"article\"),     list(\"citation\", \"citee\", \"article\", \"article\")   ) )) #> database schema with 2 relation schemas #> 3 attributes: citer, citee, article #> schema citation: citer, citee #>   key 1: citer, citee #> schema article: article #>   key 1: article #> references: #> citation.{citer} -> article.{article} #> citation.{citee} -> article.{article}  # vector operations ds2 <- database_schema(   relation_schema(     list(       e = list(c(\"a\", \"e\"), list(\"e\"))     ),     attrs_order = c(\"a\", \"e\")   ),   list() ) c(ds, ds2) # attrs_order attributes are merged #> database schema with 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema e: e, a #>   key 1: e #> references: #> a.{b} -> b.{b} unique(c(ds, ds)) #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b}  # subsetting ds[1] #> database schema with 1 relation schema #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> no references stopifnot(identical(ds[[1]], ds[1])) ds[c(1, 2, 1, 2)] # replicates the foreign key references #> database schema with 4 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema a.1: a, b #>   key 1: a #> schema b.1: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} #> a.{b} -> b.1.{b} #> a.1.{b} -> b.{b} #> a.1.{b} -> b.1.{b} c(ds[c(1, 2)], ds[c(1, 2)]) # doesn't reference between separate copies of ds #> database schema with 4 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema a.1: a, b #>   key 1: a #> schema b.1: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} #> a.1.{b} -> b.1.{b} unique(ds[c(1, 2, 1, 2)]) # unique() also merges references #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b}  # another example of unique() merging references ds_merge <- database_schema(   relation_schema(     list(       a = list(c(\"a\", \"b\"), list(\"a\")),       b = list(c(\"b\", \"c\", \"d\"), list(\"b\")),       c_d = list(c(\"c\", \"d\", \"e\"), list(c(\"c\", \"d\"))),       a.1 = list(c(\"a\", \"b\"), list(\"a\")),       b.1 = list(c(\"b\", \"c\", \"d\"), list(\"b\"))     ),     c(\"a\", \"b\", \"c\", \"d\", \"e\")   ),   list(     list(\"a\", \"b\", \"b\", \"b\"),     list(\"b.1\", c(\"c\", \"d\"), \"c_d\", c(\"c\", \"d\"))   ) ) print(ds_merge) #> database schema with 5 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c, d #>   key 1: b #> schema c_d: c, d, e #>   key 1: c, d #> schema a.1: a, b #>   key 1: a #> schema b.1: b, c, d #>   key 1: b #> references: #> a.{b} -> b.{b} #> b.1.{c, d} -> c_d.{c, d} unique(ds_merge) #> database schema with 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c, d #>   key 1: b #> schema c_d: c, d, e #>   key 1: c, d #> references: #> a.{b} -> b.{b} #> b.{c, d} -> c_d.{c, d}  # reassignment # can't change keys included in references if (FALSE) keys(ds)[[2]] <- list(\"c\") # \\dontrun{} # can't remove attributes included in keys if (FALSE) attrs(ds)[[2]] <- list(\"c\", \"d\") # \\dontrun{} # can't remove attributes included in references if (FALSE) attrs(ds)[[1]] <- c(\"a\", \"d\") # \\dontrun{} ds3 <- ds # can change subset of schema, but loses references between altered and # non-altered subsets ds3[2] <- database_schema(   relation_schema(     list(d = list(c(\"d\", \"c\"), list(\"d\"))),     attrs_order(ds3)   ),   list() ) print(ds3) # note the schema's name doesn't change #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: d, c #>   key 1: d #> no references # names(ds3)[2] <- \"d\" # this would change the name keys(ds3)[[2]] <- list(character()) # removing keys first... attrs(ds3)[[2]] <- c(\"b\", \"c\") # so we can change the attrs legally keys(ds3)[[2]] <- list(\"b\", \"c\") # add the new keys # add the reference lost during subset replacement references(ds3) <- c(references(ds3), list(list(\"a\", \"b\", \"b\", \"b\"))) stopifnot(identical(ds3, ds))  # changing appearance priority for attributes attrs_order(ds3) <- c(\"d\", \"c\", \"b\", \"a\") print(ds3) #> database schema with 2 relation schemas #> 4 attributes: d, c, b, a #> schema a: a, b #>   key 1: a #> schema b: c, b #>   key 1: c #>   key 2: b #> references: #> a.{b} -> b.{b}  # changing relation schema names changes them in references names(ds3) <- paste0(names(ds3), \"_long\") print(ds3) #> database schema with 2 relation schemas #> 4 attributes: d, c, b, a #> schema a_long: a, b #>   key 1: a #> schema b_long: c, b #>   key 1: c #>   key 2: b #> references: #> a_long.{b} -> b_long.{b}  # reconstructing from components ds_recon <- database_schema(   relation_schema(     Map(list, attrs(ds), keys(ds)),     attrs_order(ds)   ),   references(ds) ) stopifnot(identical(ds_recon, ds)) ds_recon2 <- database_schema(   subschemas(ds),   references(ds) ) stopifnot(identical(ds_recon2, ds))  # can be a data frame column data.frame(id = 1:2, schema = ds) #>   id   schema #> 1  1 schema a #> 2  2 schema b"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":null,"dir":"Reference","previous_headings":"","what":"Decompose a data frame based on given normalised dependencies — decompose","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"Decomposes data frame several relations, based given database schema. intended data frame satisfies functional dependencies implied schema, schema constructed data frame. case, function returns error.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"","code":"decompose(   df,   schema,   keep_rownames = FALSE,   digits = getOption(\"digits\"),   check = TRUE )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"df data.frame, containing data normalised. schema database schema foreign key references, given autoref. keep_rownames logical string, indicating whether include row names column. string given, used name column, otherwise column named \"row\". Set FALSE default. digits positive integer, indicating many significant digits used numeric complex variables. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See \"Floating-point variables\" section discover rounding necessary consistent results across different machines. See note print.default digits >= 16. check logical, indicating whether check df satisfies functional dependencies enforced schema creating result. can find key violations without spending time creating result first, redundant df used create schema first place.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"database object, containing data df within database schema given schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"schema constructed using approximate dependencies data frame, decompose returns error, prevent either duplicate records lossy decompositions. temporary: next update, plan add option allow , add \"approximate\" equivalents databases database schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/dependant.html","id":null,"dir":"Reference","previous_headings":"","what":"Dependants — dependant","title":"Dependants — dependant","text":"Generic function, given method fetching dependants functional dependencies.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/dependant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dependants — dependant","text":"","code":"dependant(x, ...)  dependant(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/dependant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dependants — dependant","text":"x R object. given method, functional_dependency. ... arguments passed methods. value character vector length dependant(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/dependant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dependants — dependant","text":"character vector containing dependants.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/detset.html","id":null,"dir":"Reference","previous_headings":"","what":"Determinant sets — detset","title":"Determinant sets — detset","text":"Generic function, given method fetching determinant sets functional dependencies.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/detset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determinant sets — detset","text":"","code":"detset(x, ...)  detset(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/detset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determinant sets — detset","text":"x R object. given method, functional_dependency. ... arguments passed methods. value character vector length detset(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/detset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determinant sets — detset","text":"list containing determinant sets, consisting character vector unique elements.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine Duplicate Elements — df_duplicated","title":"Determine Duplicate Elements — df_duplicated","text":"duplicated \"determines elements vector data frame duplicates elements smaller subscripts, returns logical vector indicating elements (rows) duplicates\". However, R 4.1, calling data frame zero columns always returns empty logical vector. repercussions functions use duplicated, unique anyDuplicated. functions add zero-column data frames special case.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine Duplicate Elements — df_duplicated","text":"","code":"df_duplicated(x, incomparables = FALSE, fromLast = FALSE, ...)  df_unique(x, incomparables = FALSE, fromLast = FALSE, ...)  df_anyDuplicated(x, incomparables = FALSE, fromLast = FALSE, ...)  df_records(x, use_rownames = FALSE, use_colnames = FALSE)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine Duplicate Elements — df_duplicated","text":"x data frame. incomparables vector values compared.     FALSE special value, meaning values can     compared, may value accepted methods     default.  coerced internally type        x. fromLast logical indicating duplication considered     reverse side, .e., last (rightmost) identical     elements correspond duplicated = FALSE. ... arguments particular methods. use_rownames logical, FALSE default, indicating whether row values keep row names x. Defaults FALSE. use_colnames logical, FALSE default, indicating whether row values keep column names x elements. Defaults FALSE.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine Duplicate Elements — df_duplicated","text":"df_duplicated, logical vector one element row. df_unique, data frame returned columns, possible fewer rows (row names first occurrences unique rows). df_anyDuplicated, integer real vector length one value 1-based index first duplicate , otherwise 0. df_records, list row values x. based step duplicated.data.frame. However, data frames zero columns, special handling returns list empty row values, one row x. Without special handling, step returns empty list. cause duplicated returning incorrect results zero-column data frames older versions R.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine Duplicate Elements — df_duplicated","text":"","code":"# row values for a 5x0 data frame x <- data.frame(a = 1:5)[, FALSE, drop = FALSE] do.call(Map, unname(c(list, x))) # original step returns empty list #> list() df_records(x) # corrected version preserves row count #> [[1]] #> list() #>  #> [[2]] #> list() #>  #> [[3]] #> list() #>  #> [[4]] #> list() #>  #> [[5]] #> list() #>"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_equiv.html","id":null,"dir":"Reference","previous_headings":"","what":"Test data frames for equivalence under row reordering — df_equiv","title":"Test data frames for equivalence under row reordering — df_equiv","text":"convenience function, mostly used testing rejoin works intended. checks data frames dimensions column names, duplicates allowed, checks contain data. latter step, column names made unique first, columns duplicate names must presented order data frames.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_equiv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test data frames for equivalence under row reordering — df_equiv","text":"","code":"df_equiv(df1, df2, digits = getOption(\"digits\"))"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_equiv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test data frames for equivalence under row reordering — df_equiv","text":"df1, df2 Data frames. digits positive integer, indicating many significant digits used numeric complex variables. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See note print.default digits >= 16.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_equiv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test data frames for equivalence under row reordering — df_equiv","text":"logical.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_rbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine R Objects by Rows or Columns — df_rbind","title":"Combine R Objects by Rows or Columns — df_rbind","text":"rbind takes \"sequence vector, matrix data-frame arguments\", combines rows latter. However, R 4.1, calling data frame zero columns always returns zero rows, due issue mentioned df_duplicated. function adds zero-column data frames special case.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_rbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine R Objects by Rows or Columns — df_rbind","text":"","code":"df_rbind(...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_rbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine R Objects by Rows or Columns — df_rbind","text":"... data frames.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_rbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine R Objects by Rows or Columns — df_rbind","text":"data frame containing ... arguments row-wise.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":null,"dir":"Reference","previous_headings":"","what":"Dependency discovery with DFD — discover","title":"Dependency discovery with DFD — discover","text":"Finds minimal functional dependencies represented data frame.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dependency discovery with DFD — discover","text":"","code":"discover(   df,   method = c(\"FDHitsSep\", \"FDHitsJoint\", \"DFD\"),   keep_rownames = FALSE,   digits = getOption(\"digits\"),   exclude = character(),   exclude_class = character(),   dependants = names(df),   detset_limit = ncol(df) - 1L,   progress = FALSE,   progress_file = \"\",   skip_bijections = FALSE,   accuracy = 1,   full_cache = TRUE,   store_cache = TRUE )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dependency discovery with DFD — discover","text":"df data.frame, relation evaluate. method string, indicating search algorithm use. Currently, defaults DFD. Alternative options FDHitsSep FDHitsJoint. keep_rownames logical string, indicating whether include row names column. string given, used name column, otherwise column named \"row\". Like column names, function returns error results duplicate column names. Set FALSE default. digits positive integer, indicating many significant digits used numeric complex variables. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See \"Floating-point variables\" section rounding necessary consistent results across different machines. See note print.default digits >=   16. exclude character vector, containing names attributes consider members determinant sets. names given present df, user given warning. exclude_class character vector, indicating classes attributes consider members determinant_sets. Attributes excluded inherit given class. dependants character vector, containing names attributes find minimal functional dependencies dependant. default, attribute names. smaller set attribute names reduces amount searching required, can reduce computation time potential dependencies interest. detset_limit integer, indicating largest determinant set size searched . default, large enough allow possible determinant sets. See Details comments effect result, computation time. progress logical, whether display progress user dependency search discover. progress_file scalar character connection. progress non-zero, determines progress written , way file argument cat. skip_bijections logical, indicating whether skip dependency searches made redundant discovered bijections attributes. can significantly speed search df contains equivalent attributes early column order, results undefined behaviour accuracy < 1. See Details information. Currently implemented DFD. accuracy numeric (0, 1]: accuracy threshold required order conclude dependency. Accuracy thresholds less one supported DFD. full_cache logical, indicating whether store information sets attributes group relation records (stripped partitions). Otherwise, number groups stored. Storing stripped partition expected let algorithm run quickly, might inefficient small data frames small amounts memory. relevant DFD. store_cache logical, indicating whether keep cached information use finding dependencies dependants. allows algorithm run quickly re-calculate information, takes memory. relevant DFD.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dependency discovery with DFD — discover","text":"functional_dependency object, containing discovered dependencies. column names df stored attrs attribute, order, serve default priority order attributes normalisation.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dependency discovery with DFD — discover","text":"Column names df must unique. two search algorithms available finding dependencies: DFD, FDHits. described .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"dfd","dir":"Reference","previous_headings":"","what":"DFD","title":"Dependency discovery with DFD — discover","text":"DFD algorithm searches determinant sets dependant attribute separately, traversing powerset (non-excluded) attributes. can roughly considered depth-first search candidate determinant sets. implementation DFD differs little algorithm presented original paper: attributes, attribute types, can designated, ahead time, candidate members determinant sets. reduces number candidate determinant sets searched, saving time searching determinant sets user remove later anyway. dependants can also trimmed similar fashion, although reduces search space linearly rather exponentially. Attributes single unique value, .e. constant, get attributed single empty determinant set. standard DFD algorithm, assigned non-excluded attributes length-one determinant sets. Assigning empty set distinguishes constant, allowing special treatment normalisation later steps. done original Python library, extra case seed generation discovered maximal non-dependencies. case, take single-attribute nodes, filter minimal dependencies usual. equivalent taking empty set single maximal non-dependency. three results checking whether candidate node minimal/maximal. TRUE indicates node minimal/maximal, usual. FALSE split FALSE NA. NA indicates can yet determine whether node minimal/maximal. FALSE indicates determined minimal/maximal, can set category . done checking whether adjacent subsets/supersets dependencies/non-dependencies, instead waiting exhaust adjacent subsets/supersets visit picking next node visit. yet keep hashmaps manage subset/superset relationships, described Section 3.5 original paper. skip_bijections allows additional optimisation finding functional dependencies pairwise-equivalent attributes. Missing values (NA) treated normal value, NA = NA true, x = NA false non-NA value x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"fdhits","dir":"Reference","previous_headings":"","what":"FDHits","title":"Dependency discovery with DFD — discover","text":"FDHits begins sampling pairs records attributes values differ (difference sets). difference sets render determinant-dependant pairings invalid, pruning search space. candidate pairing rendered invalid known difference sets, validated, resulting either confirmation minimal functional dependency, discovery new difference sets make invalid. two variants. FDHitsSep performs search dependant attribute separately, way DFD. FDHitsJoint handles dependant attributes time. implementation FDHits differs little algorithm presented original paper: attributes, attribute types, can designated, ahead time, candidate members determinant sets. reduces number candidate determinant sets searched, saving time searching determinant sets user remove later anyway. dependants can also trimmed similar fashion. search can limited determinant sets given size. also option DFD, useful FDHits, due search order. described paper, FDHitsSep FDHitsJoint branch search several child nodes: \\(\\mu_0\\) FDHitsJoint, \\(\\mu_1\\), \\(\\mu_2\\) etc. . paper implies latter nodes visited order. However, causes algorithm always work correctly: guaranteed correctness, must visited reverse order, \\(\\mu_0\\) able visited point. correction expected appear future paper. final algorithm paper automatically chooses FDHitsSep FDHits Joint, depending number initially-sampled difference sets. yet implemented.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"floating-point-variables","dir":"Reference","previous_headings":"","what":"Floating-point variables","title":"Dependency discovery with DFD — discover","text":"Numerical/complex values, .e. floating-point values, represent difficulties stating functional dependencies. fundamental condition stating functional dependencies can compare two values variable, equivalent equivalent. Usually, done checking equal – approach used discover – can use comparison equivalence relation. However, checking floating-point values equality simple. == appropriate, even comparing non-calculated values read file, given number converted float can vary computer architecture, meaning two values can considered equal one computer, equal another. can happen even using 64-bit R, even though R platforms work values conforming standard (see double). example, \\(8.54917750000000076227\\) \\(8.54917749999999898591\\) converted different floating-point representations x86, representation ARM, resulting inequality equality respectively. reasons, checking numerical/complex values (near-)equality R usually done .equal. determines values \\(x\\) \\(y\\) equal absolute/relative absolute difference within tolerance value. However, can use . Equivalence relations must transitive: values \\(x\\), \\(y\\), \\(z\\), \\(x\\) equivalent \\(y\\) \\(z\\), \\(y\\) \\(z\\) must also equivalent. tolerance-based equivalence transitive: reasonably straightforward set three values outer values far enough apart considered non-equivalent, middle value close enough considered equivalent . Using determine functional dependencies, therefore, easily result large number inconsistencies. means good option comparing numerical/complex values -equivalence, consistent results across different machines, must treat differently. three options: Round/truncate values, comparison, low degree precision; Coerce values another class passing discover; Read values characters reading data file. discover takes first option, default number significant digits low enough ensure consistency across different machines. However, user can also use options processing data passing discover. third option, particular, recommended reading data file.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"skipping-bijections","dir":"Reference","previous_headings":"","what":"Skipping bijections","title":"Dependency discovery with DFD — discover","text":"Skipping bijections allows skipping redundant searches. example, search discovers -> B B -> , one attributes considered remainder search. Since search time increases exponentially number attributes considered, can significantly speed search times. moment, done bijections single attributes, <-> B; <-> {B, C}, nothing skipped. Whether bijections skipped affect functional dependencies present output, might affect order. Skipping bijections approximate dependencies, .e. accuracy < 1, avoided: can result incorrect output, since approximate bijection imply equivalent approximate dependencies.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"limiting-the-determinant-set-size","dir":"Reference","previous_headings":"","what":"Limiting the determinant set size","title":"Dependency discovery with DFD — discover","text":"Setting detset_limit smaller largest-possible value different behaviour different search algorithms, result always discover(x, 1, detset_limit = n) equivalent full search, fds <- discover(x, 1), filtering determinant set size post-hoc, fds[lengths(detset(fds)) <= n]. DFD, naive way implement removing determinant sets larger limit search tree possible functional dependencies dependant. However, usually results search taking much time without limit. example, suppose search determinant sets dependant none (dependant key df, example). Using DFD, begin single attribute, add attributes one--one, since every set gives non-dependency. reach maximum-size set, can mark subsets also non-dependencies. default limit, one maximum-size set, containing available attributes. \\(n\\) candidate attributes determinants, search finishes visiting \\(n\\) sets. smaller limit \\(k\\), \\(\\binom{n}{k}\\) maximum-size sets explore. Since DFD search adds removes one attribute step, means search must take least \\(k - 2 + 2\\binom{n}{k}\\) steps, larger \\(n\\) non-trivial cases \\(0 < k \\leq n\\). therefore use different approach, determinant sets size limit allowed candidate seeds new search paths, discovered dependencies size limit discard end entire DFD search. means nodes determinant sets size limit visited order determine maximality non-dependencies within size limit. turns rare results significant speed-, never results search visit nodes without size limit, average search time never made worse. FDHits implements detset_limit naturally, since explores determinant sets increasing set size. Limiting size simply matter visiting new nodes determinant set within given size limit.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Dependency discovery with DFD — discover","text":"DFD: Abedjan Z., Schulze P., Naumann F. (2014) DFD: efficient functional dependency discovery. Proceedings 23rd ACM International Conference Conference Information Knowledge Management (CIKM '14). New York, U.S.., 949–958. FDHits: Bleifuss T., Papenbrock T., Bläsius T., Schirneck M, Naumann F. (2024) Discovering Functional Dependencies Hitting Set Enumeration. Proc. ACM Manag. Data, 2, 1, 43:1–24.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dependency discovery with DFD — discover","text":"","code":"# simple example discover(ChickWeight) #> 2 functional dependencies #> 4 attributes: weight, Time, Chick, Diet #> Time, Chick -> weight #>       Chick -> Diet  # example with spurious dependencies discover(CO2) #> 5 functional dependencies #> 5 attributes: Plant, Type, Treatment, conc, uptake #> Treatment, conc, uptake -> Plant #>            conc, uptake -> Type #>                   Plant -> Type #>                   Plant -> Treatment #>             Plant, conc -> uptake # exclude attributes that can't be determinants. # in this case, the numeric attributes are now # not determined by anything, because of repeat measurements # with no variable to mark them as such. discover(CO2, exclude_class = \"numeric\") #> 2 functional dependencies #> 5 attributes: Plant, Type, Treatment, conc, uptake #> Plant -> Type #> Plant -> Treatment # include only dependencies with dependants of interest. discover(CO2, dependants = c(\"Treatment\", \"uptake\")) #> 2 functional dependencies #> 5 attributes: Plant, Type, Treatment, conc, uptake #>       Plant -> Treatment #> Plant, conc -> uptake # approximate dependencies, that hold if we remove up to 20% of the rows # (these need not agree on which rows are removed) discover(CO2, method = \"DFD\", accuracy = 0.8) #> 7 functional dependencies #> 5 attributes: Plant, Type, Treatment, conc, uptake #>      uptake -> Plant #>       Plant -> Type #>      uptake -> Type #>       Plant -> Treatment #>      uptake -> Treatment #>      uptake -> conc #> Plant, conc -> uptake"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional dependency vectors — functional_dependency","title":"Functional dependency vectors — functional_dependency","text":"Creates set functional dependencies length-one dependants.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional dependency vectors — functional_dependency","text":"","code":"functional_dependency(FDs, attrs_order, unique = TRUE)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional dependency vectors — functional_dependency","text":"FDs list functional dependencies, form two-elements lists: first element contains character vector attributes determinant set, second element contains single dependent attribute (dependant). attrs_order character vector, giving names attributes. need present FDs, attributes FDs must present attrs. unique logical, TRUE default, whether remove duplicate dependencies.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional dependency vectors — functional_dependency","text":"functional_dependency object, containing list given FDs, attrs_order attribute name. Functional dependencies returned determinant sets sorted according attribute order attrs. duplicates found sorting removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional dependency vectors — functional_dependency","text":"several sets functional dependencies concatenated, attrs_order attributes merged, preserve original attribute orders, possible. possible, orderings disagree, returned value attrs_order attribute union instead.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional dependency vectors — functional_dependency","text":"","code":"fds <- functional_dependency(   list(list(c(\"a\", \"b\"), \"c\"), list(character(), \"d\")),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) print(fds) #> 2 functional dependencies #> 4 attributes: a, b, c, d #> a, b -> c #>      -> d detset(fds) #> [[1]] #> [1] \"a\" \"b\" #>  #> [[2]] #> character(0) #>  dependant(fds) #> [1] \"c\" \"d\" attrs_order(fds) #> [1] \"a\" \"b\" \"c\" \"d\"  # vector operations fds2 <- functional_dependency(list(list(\"e\", \"a\")), c(\"a\", \"e\")) c(fds, fds2) # attrs_order attributes are merged #> 3 functional dependencies #> 5 attributes: a, b, c, d, e #> a, b -> c #>      -> d #>    e -> a unique(c(fds, fds)) #> 2 functional dependencies #> 4 attributes: a, b, c, d #> a, b -> c #>      -> d  # subsetting fds[1] #> 1 functional dependency #> 4 attributes: a, b, c, d #> a, b -> c fds[c(1, 2, 1)] #> 3 functional dependencies #> 4 attributes: a, b, c, d #> a, b -> c #>      -> d #> a, b -> c stopifnot(identical(fds[[2]], fds[2]))  # reassignment fds3 <- fds fds3[2] <- functional_dependency(list(list(\"a\", \"c\")), attrs_order(fds3)) print(fds3) #> 2 functional dependencies #> 4 attributes: a, b, c, d #> a, b -> c #>    a -> c detset(fds3)[[2]] <- character() dependant(fds3)[[2]] <- \"d\" stopifnot(identical(fds3, fds)) # changing appearance priority for attributes attrs_order(fds3) <- rev(attrs_order(fds3)) fds3 #> 2 functional dependencies #> 4 attributes: d, c, b, a #> b, a -> c #>      -> d  # reconstructing from components fds_recon <- functional_dependency(  Map(list, detset(fds), dependant(fds)),  attrs_order(fds) ) stopifnot(identical(fds_recon, fds))  # can be a data frame column data.frame(id = 1:2, fd = fds) #>   id        fd #> 1  1 a, b -> c #> 2  2      -> d  # (in)equality ignores header stopifnot(all(fds3 == fds)) stopifnot(!any(fds != fds))"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot a data frame — gv.data.frame","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"Produces text input Graphviz make HTML diagram given data frame.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"","code":"# S3 method for class 'data.frame' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"x data.frame. name character scalar, giving name record, . name must non-empty, since also used name single table plot. Defaults NA: left missing, set \"data\". ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"rows plotted data frame include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot databases — gv.database","title":"Generate Graphviz input text to plot databases — gv.database","text":"Produces text input Graphviz make HTML diagram given database.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot databases — gv.database","text":"","code":"# S3 method for class 'database' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot databases — gv.database","text":"x database, returned autoref autodb. name scalar character, giving name database, . name used resulting graph, allow easier combining graphs single diagram required. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot databases — gv.database","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot databases — gv.database","text":"relation database presented set rows, one attribute relation. rows include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot database schemas — gv.database_schema","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"Produces text input Graphviz make HTML diagram given database schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"","code":"# S3 method for class 'database_schema' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"x database schema, given normalise, synthesise, autoref. name character scalar, giving name schema, . ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"relation schema presented set rows, one attribute relation. rows include information attribute classes. foreign key references represented arrows attribute pairs.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot objects — gv","title":"Generate Graphviz input text to plot objects — gv","text":"Produces text input Graphviz make HTML diagram given object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot objects — gv","text":"","code":"gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot objects — gv","text":"x object plotted. name scalar character, giving name object, . name used resulting graph, allow easier combining graphs single diagram required. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot objects — gv","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot objects — gv","text":"Details plotted given individual methods. expected commonalities, described . object expected one following: object whose elements length. Examples data frames, matrices, objects can represent relations, names elements, optional name object . graph sub-objects, represent relation described , possibly connections objects, optional name graph whole. relation presented record-like shape, following elements: optional header relation's name, number (unique) records. set rows, one attribute relation. rows following contents: attribute names. depiction relation's (candidate) keys. column represents key, filled cell indicates attribute row key. keys given lexical order, precedence given keys fewer attributes, keys attributes appear earlier original data frame's attribute order. Default output package functions thus primary key given first. future, changed always give primary key first. optionally, attribute types: specifically, first element passing attribute's values class. foreign key references relations represented one-way arrows, one per attribute foreign key. object name, name attached resulting graph Graphviz. allow easier combination several graphs single image, user wishes .","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Graphviz input text to plot objects — gv","text":"","code":"# simple data.frame example txt_df <- gv(ChickWeight, \"chick\") cat(txt_df) #> digraph \"chick\" { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">chick (578 rows)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD PORT=\"FROM_weight\">numeric<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD PORT=\"FROM_time\">numeric<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD PORT=\"FROM_diet\">factor<\/TD><\/TR> #>     <\/TABLE>>]; #> } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   DiagrammeR::grViz(txt_df) }  {\"x\":{\"diagram\":\"digraph \\\"chick\\\" {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">chick (578 rows)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD PORT=\\\"FROM_weight\\\">numeric<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD PORT=\\\"FROM_time\\\">numeric<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\">ordered<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD PORT=\\\"FROM_diet\\\">factor<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}# simple database example db <- autodb(ChickWeight) txt_db <- gv(db) cat(txt_db) #> digraph { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Chick (50 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD><\/TD><TD PORT=\"FROM_diet\">factor<\/TD><\/TR> #>     <\/TABLE>>]; #>   \"Time_Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Time_Chick (578 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_time\">numeric<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD><\/TD><TD PORT=\"FROM_weight\">numeric<\/TD><\/TR> #>     <\/TABLE>>]; #>  #>   \"Time_Chick\":FROM_chick -> \"Chick\":TO_chick; #> } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   DiagrammeR::grViz(txt_db) }  {\"x\":{\"diagram\":\"digraph {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"3\\\">Chick (50 records)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_chick\\\">ordered<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD><\\/TD><TD PORT=\\\"FROM_diet\\\">factor<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n  \\\"Time_Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"3\\\">Time_Chick (578 records)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_time\\\">numeric<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_chick\\\">ordered<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD><\\/TD><TD PORT=\\\"FROM_weight\\\">numeric<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n\\n  \\\"Time_Chick\\\":FROM_chick -> \\\"Chick\\\":TO_chick;\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}# simple relation schemas rschema <- synthesise(discover(ChickWeight)) txt_rschema <- gv(rschema) cat(txt_rschema) #> digraph { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">Chick<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD PORT=\"FROM_diet\"><\/TD><\/TR> #>     <\/TABLE>>]; #>   \"Time_Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">Time_Chick<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD PORT=\"FROM_time\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD PORT=\"FROM_weight\"><\/TD><\/TR> #>     <\/TABLE>>]; #> } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   DiagrammeR::grViz(txt_rschema) }  {\"x\":{\"diagram\":\"digraph {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">Chick<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD PORT=\\\"FROM_diet\\\"><\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n  \\\"Time_Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">Time_Chick<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD PORT=\\\"FROM_time\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD PORT=\\\"FROM_weight\\\"><\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}# simple database schema dschema <- normalise(discover(ChickWeight)) txt_dschema <- gv(dschema) cat(txt_dschema) #> digraph { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">Chick<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD PORT=\"FROM_diet\"><\/TD><\/TR> #>     <\/TABLE>>]; #>   \"Time_Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">Time_Chick<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD PORT=\"FROM_time\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD PORT=\"FROM_weight\"><\/TD><\/TR> #>     <\/TABLE>>]; #>  #>   \"Time_Chick\":FROM_chick -> \"Chick\":TO_chick; #> } DiagrammeR::grViz(txt_dschema)  {\"x\":{\"diagram\":\"digraph {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">Chick<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD PORT=\\\"FROM_diet\\\"><\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n  \\\"Time_Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">Time_Chick<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD PORT=\\\"FROM_time\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD PORT=\\\"FROM_weight\\\"><\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n\\n  \\\"Time_Chick\\\":FROM_chick -> \\\"Chick\\\":TO_chick;\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}# simple relations rel <- create(synthesise(discover(ChickWeight))) txt_rel <- gv(rel) cat(txt_rel) #> digraph { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Chick (0 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">logical<\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD><\/TD><TD PORT=\"FROM_diet\">logical<\/TD><\/TR> #>     <\/TABLE>>]; #>   \"Time_Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Time_Chick (0 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_time\">logical<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">logical<\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD><\/TD><TD PORT=\"FROM_weight\">logical<\/TD><\/TR> #>     <\/TABLE>>]; #> } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   DiagrammeR::grViz(txt_rel) }  {\"x\":{\"diagram\":\"digraph {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"3\\\">Chick (0 records)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_chick\\\">logical<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD><\\/TD><TD PORT=\\\"FROM_diet\\\">logical<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n  \\\"Time_Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"3\\\">Time_Chick (0 records)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_time\\\">logical<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_chick\\\">logical<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD><\\/TD><TD PORT=\\\"FROM_weight\\\">logical<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot relations — gv.relation","title":"Generate Graphviz input text to plot relations — gv.relation","text":"Produces text input Graphviz make HTML diagram given relation.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot relations — gv.relation","text":"","code":"# S3 method for class 'relation' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot relations — gv.relation","text":"x relation. name character scalar, giving name schema, . ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot relations — gv.relation","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot relations — gv.relation","text":"relation presented set rows, one attribute relation. rows include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"Produces text input Graphviz make HTML diagram given relation schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"","code":"# S3 method for class 'relation_schema' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"x relation schema, given relation_schema synthesise. name character scalar, giving name schema, . ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"relation schema presented set rows, one attribute relation. rows include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert data — insert","title":"Insert data — insert","text":"Generic function inserting data frame data object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert data — insert","text":"","code":"insert(   x,   vals,   relations = names(x),   all = FALSE,   keep_rownames = FALSE,   digits = getOption(\"digits\"),   ... )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert data — insert","text":"x relational data object, insert data, relation database object. vals data frame, containing data insert. Column names must unique. relations character vector, containing names elements x insert data. default, insert attempts insert data every element. logical, indicating whether vals required contain attributes elements x[relations]. default, , data inserted elements x[relations] whose attributes present vals. keep_rownames logical string, indicating whether include row names column. string given, used name column, otherwise column named \"row\". Set FALSE default. digits positive integer, indicating many significant digits used numeric complex variables. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See \"Floating-point variables\" section discover rounding necessary consistent results across different machines. See note print.default digits >= 16. ... arguments pass methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Insert data — insert","text":"R object class x, containing additional new data.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Insert data — insert","text":"function intended inserting object comprised data frames, relation database. given methods following behaviour: empty set data inserted, non-empty object element, nothing happens. empty set data inserted empty object element, resulting element also empty, takes attribute/column classes inserted data. done prevent know attribute classes object creation. Insertion can fail inserting violate object constraints. example, databases data inserted violate candidate/foreign key constraints. cases, data inserted object element way using rbind, followed unique. key violations prevent insertion, re-insertion existing records object element . makes insertion equivalent INSERT IGNORE expression SQL. particular, somewhat like using expression SQLite, since implementation uses dynamic typing. vals contains attributes included attrs_order(x), insert throws error, since attributes inserted. partial set attributes inserted, FALSE, data inserted components x[relations] whose required attributes present vals. TRUE, insert returns error instead. useful specifying relations: case, often intend insert specified elements, including required attributes mistake, = TRUE prevents . TRUE, insert throws error case: ensures insert members specified value relations.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational data keys — keys","title":"Relational data keys — keys","text":"Generic function, given method fetching candidate key lists relation schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational data keys — keys","text":"","code":"keys(x, ...)  keys(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational data keys — keys","text":"x relational schema object, relation_schema database_schema object, relational data object, relation database object. ... arguments passed methods. value list lists character vectors, length keys(x, ...). number keys element x can changed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational data keys — keys","text":"list containing lists unique character vectors, representing candidate keys element x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge relation schemas with empty keys — merge_empty_keys","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"Merges object's schemas empty keys. remaining schema contains attributes contained schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"","code":"merge_empty_keys(x)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"x relational schema object, relation_schema database_schema object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"R object class x, relations empty key merged single relation.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"function generic, makes use generic functions keys merge_schemas. input class valid methods generic functions can passed function. database_schema objects, references involving schemas empty keys updated refer merged schema.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge relation schemas in given pairs — merge_schemas","title":"Merge relation schemas in given pairs — merge_schemas","text":"Generic function merges pairs object's schemas matching sets keys. remaining schemas contain attributes schemas merged .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge relation schemas in given pairs — merge_schemas","text":"","code":"merge_schemas(x, to_remove, merge_into, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge relation schemas in given pairs — merge_schemas","text":"x relational schema object, relation_schema database_schema object. to_remove integer vector, giving indices schemas merged schemas, removed. merge_into integer vector length to_remove, giving indices schemas merge. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge relation schemas in given pairs — merge_schemas","text":"R object class x, relations merged indicated.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge relation schemas in given pairs — merge_schemas","text":"","code":"rs <- relation_schema(   list(     a = list(c(\"a\", \"b\"), list(\"a\")),     b = list(c(\"b\", \"c\"), list(\"b\")),     b.1 = list(c(\"b\", \"d\"), list(\"b\")),     d = list(c(\"d\", \"e\"), list(\"d\", \"e\"))   ),   letters[1:5] ) ds <- database_schema(   rs,   list(     list(\"a\", \"b\", \"b\", \"b\"),     list(\"b.1\", \"d\", \"d\", \"d\")    ) ) merge_schemas(rs, 3, 2) # merging b and b.1 #> 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c, d #>   key 1: b #> schema d: d, e #>   key 1: d #>   key 2: e merge_schemas(ds, 3, 2) # also merging their references #> database schema with 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c, d #>   key 1: b #> schema d: d, e #>   key 1: d #>   key 2: e #> references: #> a.{b} -> b.{b} #> b.{d} -> d.{d}  # merging a schema into itself just removes it merge_schemas(rs, 3, 3) #> 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #> schema d: d, e #>   key 1: d #>   key 2: e merge_schemas(ds, 3, 3) #> database schema with 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #> schema d: d, e #>   key 1: d #>   key 2: e #> references: #> a.{b} -> b.{b}"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":null,"dir":"Reference","previous_headings":"","what":"Create normalised database schemas from functional dependencies — normalise","title":"Create normalised database schemas from functional dependencies — normalise","text":"Creates database schema given functional dependencies, satisfying least third normal form, using Bernstein's synthesis.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create normalised database schemas from functional dependencies — normalise","text":"","code":"normalise(   dependencies,   single_ref = FALSE,   ensure_lossless = TRUE,   reduce_attributes = TRUE,   remove_avoidable = FALSE,   constants_name = \"constants\",   progress = FALSE,   progress_file = \"\" )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create normalised database schemas from functional dependencies — normalise","text":"dependencies functional_dependency object, given discover. single_ref logical, FALSE default. TRUE, one reference relation pair kept generating foreign key references. pair multiple references, kept reference refers earliest key child relation, sorted priority order. ensure_lossless logical, TRUE default. TRUE, decomposition lossless, extra relation added make decomposition lossless. reduce_attributes logical, TRUE default. TRUE, dependencies checked determinant attributes made redundant dependencies. redundant dependencies output discover, since redundant attributes. remove_avoidable logical, indicating whether remove avoidable attributes relations. , attribute removed relations keys can changed needed preserve given functional dependencies. constants_name scalar character, giving name relation created store constant attributes. generated relation name, changed, warning, ensure relations unique name. progress logical, whether display progress user dependency search discover. progress_file scalar character connection. progress non-zero, determines progress written , way file argument cat.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create normalised database schemas from functional dependencies — normalise","text":"database_schema object, containing synthesis relation schemas created foreign key references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create normalised database schemas from functional dependencies — normalise","text":"wrapper function applying synthesise autoref, order. creating relation schemas foreign key references separately, use functions directly. See functions examples. details synthesis algorithm used, see synthesise.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":null,"dir":"Reference","previous_headings":"","what":"Nudge meta-analysis data — nudge","title":"Nudge meta-analysis data — nudge","text":"Data used meta-analysis effectiveness nudges, .e. choice architecture interventions.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nudge meta-analysis data — nudge","text":"","code":"nudge"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Nudge meta-analysis data — nudge","text":"data frame 447 effect size measurements 25 columns: publication_id, integer ID number publication. Note two publications erroneously assigned ID number, unique publication identifier. study_id, integer ID number study. es_id, integer ID number effect size measured. reference, publication citation \"Author(s) (year)\" format. Due two publications assigned reference, also unique publication identifier. title, title publication. Due error assigning publication ID numbers, unique publication identifier within data set. year, year publication. location, geographical location intervention. given factor, rather integer, using information provided codebook. domain, factor giving intervention's behavioural domain. intervention_category, factor giving intervention's category, based taxonomy Münscher et al. (2016). intervention_technique, factor giving intervention's technique, based taxonomy Münscher et al. (2016). type_experiment, factor giving type experiment, defined Harrison List (2004). population, factor giving intervention's target population. given factor, rather integer, using information provided codebook. n_study, sample size overall study. n_comparison, combined sample size control intervention measured effect size. n_control, sample size control condition measured effect size. n_intervention, sample size intervention condition measured effect size. binary_outcome, logical whether outcome scale binary continuous. mean_control, mean outcome control condition. sd_control, SD outcome control condition. mean_intervention, mean outcome intervention condition. sd_intervention, SD outcome intervention condition. cohens_d, extracted effect size intervention. variance_d, variance extracted effect size. approximation, logical whether effect size extraction involved approximation. wansink, logical whether study (co-)authored Brian Wansink. added revision, , years publication, Wansink many papers retracted corrected, due various questionable practices, resulting Wansink determined committed scientific misconduct. column added check whether findings robust exclusion non-retracted studies Cornell Food Brand Laboratory, Wansink director.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Nudge meta-analysis data — nudge","text":"https://osf.io/fywae/","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nudge meta-analysis data — nudge","text":"Mertens S., Herberz M., Hahnel U. J. J., Brosch T. (2022) effectiveness nudging: meta-analysis choice architecture interventions across behavioral domains. Proc. Natl. Acad. Sci. U.S.., 4, 119(1).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational data records — records","title":"Relational data records — records","text":"Generic function, retrieving data contained database-like structure. particular, intended structures individual relations accessed subsetting.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational data records — records","text":"","code":"records(x, ...)  records(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational data records — records","text":"x relational data object, relation database object. ... arguments passed methods. value list data frames length records(x,   ...), data frame column names replace, order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational data records — records","text":"list containing data frames, elements named respective relations.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relational data records — records","text":"Since relational data objects autodb, relation database, subsetting methods return relational data objects, data contained within accessed subsetting. function intended accessing instead. recommended call records subsetting, since subsetting relation data object work thrown away, subsetting database checking whether foreign key references removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational data records — records","text":"","code":"db <- autodb(ChickWeight) records(db) # data for Chick and Time_Chick relations #> $Chick #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4 #>  #> $Time_Chick #>     Time Chick weight #> 1      0     1     42 #> 2      2     1     51 #> 3      4     1     59 #> 4      6     1     64 #> 5      8     1     76 #> 6     10     1     93 #> 7     12     1    106 #> 8     14     1    125 #> 9     16     1    149 #> 10    18     1    171 #> 11    20     1    199 #> 12    21     1    205 #> 13     0     2     40 #> 14     2     2     49 #> 15     4     2     58 #> 16     6     2     72 #> 17     8     2     84 #> 18    10     2    103 #> 19    12     2    122 #> 20    14     2    138 #> 21    16     2    162 #> 22    18     2    187 #> 23    20     2    209 #> 24    21     2    215 #> 25     0     3     43 #> 26     2     3     39 #> 27     4     3     55 #> 28     6     3     67 #> 29     8     3     84 #> 30    10     3     99 #> 31    12     3    115 #> 32    14     3    138 #> 33    16     3    163 #> 34    18     3    187 #> 35    20     3    198 #> 36    21     3    202 #> 37     0     4     42 #> 38     2     4     49 #> 39     4     4     56 #> 40     6     4     67 #> 41     8     4     74 #> 42    10     4     87 #> 43    12     4    102 #> 44    14     4    108 #> 45    16     4    136 #> 46    18     4    154 #> 47    20     4    160 #> 48    21     4    157 #> 49     0     5     41 #> 50     2     5     42 #> 51     4     5     48 #> 52     6     5     60 #> 53     8     5     79 #> 54    10     5    106 #> 55    12     5    141 #> 56    14     5    164 #> 57    16     5    197 #> 58    18     5    199 #> 59    20     5    220 #> 60    21     5    223 #> 61     0     6     41 #> 62     2     6     49 #> 63     4     6     59 #> 64     6     6     74 #> 65     8     6     97 #> 66    10     6    124 #> 67    12     6    141 #> 68    14     6    148 #> 69    16     6    155 #> 70    18     6    160 #> 71    20     6    160 #> 72    21     6    157 #> 73     0     7     41 #> 74     2     7     49 #> 75     4     7     57 #> 76     6     7     71 #> 77     8     7     89 #> 78    10     7    112 #> 79    12     7    146 #> 80    14     7    174 #> 81    16     7    218 #> 82    18     7    250 #> 83    20     7    288 #> 84    21     7    305 #> 85     0     8     42 #> 86     2     8     50 #> 87     4     8     61 #> 88     6     8     71 #> 89     8     8     84 #> 90    10     8     93 #> 91    12     8    110 #> 92    14     8    116 #> 93    16     8    126 #> 94    18     8    134 #> 95    20     8    125 #> 96     0     9     42 #> 97     2     9     51 #> 98     4     9     59 #> 99     6     9     68 #> 100    8     9     85 #> 101   10     9     96 #> 102   12     9     90 #> 103   14     9     92 #> 104   16     9     93 #> 105   18     9    100 #> 106   20     9    100 #> 107   21     9     98 #> 108    0    10     41 #> 109    2    10     44 #> 110    4    10     52 #> 111    6    10     63 #> 112    8    10     74 #> 113   10    10     81 #> 114   12    10     89 #> 115   14    10     96 #> 116   16    10    101 #> 117   18    10    112 #> 118   20    10    120 #> 119   21    10    124 #> 120    0    11     43 #> 121    2    11     51 #> 122    4    11     63 #> 123    6    11     84 #> 124    8    11    112 #> 125   10    11    139 #> 126   12    11    168 #> 127   14    11    177 #> 128   16    11    182 #> 129   18    11    184 #> 130   20    11    181 #> 131   21    11    175 #> 132    0    12     41 #> 133    2    12     49 #> 134    4    12     56 #> 135    6    12     62 #> 136    8    12     72 #> 137   10    12     88 #> 138   12    12    119 #> 139   14    12    135 #> 140   16    12    162 #> 141   18    12    185 #> 142   20    12    195 #> 143   21    12    205 #> 144    0    13     41 #> 145    2    13     48 #> 146    4    13     53 #> 147    6    13     60 #> 148    8    13     65 #> 149   10    13     67 #> 150   12    13     71 #> 151   14    13     70 #> 152   16    13     71 #> 153   18    13     81 #> 154   20    13     91 #> 155   21    13     96 #> 156    0    14     41 #> 157    2    14     49 #> 158    4    14     62 #> 159    6    14     79 #> 160    8    14    101 #> 161   10    14    128 #> 162   12    14    164 #> 163   14    14    192 #> 164   16    14    227 #> 165   18    14    248 #> 166   20    14    259 #> 167   21    14    266 #> 168    0    15     41 #> 169    2    15     49 #> 170    4    15     56 #> 171    6    15     64 #> 172    8    15     68 #> 173   10    15     68 #> 174   12    15     67 #> 175   14    15     68 #> 176    0    16     41 #> 177    2    16     45 #> 178    4    16     49 #> 179    6    16     51 #> 180    8    16     57 #> 181   10    16     51 #> 182   12    16     54 #> 183    0    17     42 #> 184    2    17     51 #> 185    4    17     61 #> 186    6    17     72 #> 187    8    17     83 #> 188   10    17     89 #> 189   12    17     98 #> 190   14    17    103 #> 191   16    17    113 #> 192   18    17    123 #> 193   20    17    133 #> 194   21    17    142 #> 195    0    18     39 #> 196    2    18     35 #> 197    0    19     43 #> 198    2    19     48 #> 199    4    19     55 #> 200    6    19     62 #> 201    8    19     65 #> 202   10    19     71 #> 203   12    19     82 #> 204   14    19     88 #> 205   16    19    106 #> 206   18    19    120 #> 207   20    19    144 #> 208   21    19    157 #> 209    0    20     41 #> 210    2    20     47 #> 211    4    20     54 #> 212    6    20     58 #> 213    8    20     65 #> 214   10    20     73 #> 215   12    20     77 #> 216   14    20     89 #> 217   16    20     98 #> 218   18    20    107 #> 219   20    20    115 #> 220   21    20    117 #> 221    0    21     40 #> 222    2    21     50 #> 223    4    21     62 #> 224    6    21     86 #> 225    8    21    125 #> 226   10    21    163 #> 227   12    21    217 #> 228   14    21    240 #> 229   16    21    275 #> 230   18    21    307 #> 231   20    21    318 #> 232   21    21    331 #> 233    0    22     41 #> 234    2    22     55 #> 235    4    22     64 #> 236    6    22     77 #> 237    8    22     90 #> 238   10    22     95 #> 239   12    22    108 #> 240   14    22    111 #> 241   16    22    131 #> 242   18    22    148 #> 243   20    22    164 #> 244   21    22    167 #> 245    0    23     43 #> 246    2    23     52 #> 247    4    23     61 #> 248    6    23     73 #> 249    8    23     90 #> 250   10    23    103 #> 251   12    23    127 #> 252   14    23    135 #> 253   16    23    145 #> 254   18    23    163 #> 255   20    23    170 #> 256   21    23    175 #> 257    0    24     42 #> 258    2    24     52 #> 259    4    24     58 #> 260    6    24     74 #> 261    8    24     66 #> 262   10    24     68 #> 263   12    24     70 #> 264   14    24     71 #> 265   16    24     72 #> 266   18    24     72 #> 267   20    24     76 #> 268   21    24     74 #> 269    0    25     40 #> 270    2    25     49 #> 271    4    25     62 #> 272    6    25     78 #> 273    8    25    102 #> 274   10    25    124 #> 275   12    25    146 #> 276   14    25    164 #> 277   16    25    197 #> 278   18    25    231 #> 279   20    25    259 #> 280   21    25    265 #> 281    0    26     42 #> 282    2    26     48 #> 283    4    26     57 #> 284    6    26     74 #> 285    8    26     93 #> 286   10    26    114 #> 287   12    26    136 #> 288   14    26    147 #> 289   16    26    169 #> 290   18    26    205 #> 291   20    26    236 #> 292   21    26    251 #> 293    0    27     39 #> 294    2    27     46 #> 295    4    27     58 #> 296    6    27     73 #> 297    8    27     87 #> 298   10    27    100 #> 299   12    27    115 #> 300   14    27    123 #> 301   16    27    144 #> 302   18    27    163 #> 303   20    27    185 #> 304   21    27    192 #> 305    0    28     39 #> 306    2    28     46 #> 307    4    28     58 #> 308    6    28     73 #> 309    8    28     92 #> 310   10    28    114 #> 311   12    28    145 #> 312   14    28    156 #> 313   16    28    184 #> 314   18    28    207 #> 315   20    28    212 #> 316   21    28    233 #> 317    0    29     39 #> 318    2    29     48 #> 319    4    29     59 #> 320    6    29     74 #> 321    8    29     87 #> 322   10    29    106 #> 323   12    29    134 #> 324   14    29    150 #> 325   16    29    187 #> 326   18    29    230 #> 327   20    29    279 #> 328   21    29    309 #> 329    0    30     42 #> 330    2    30     48 #> 331    4    30     59 #> 332    6    30     72 #> 333    8    30     85 #> 334   10    30     98 #> 335   12    30    115 #> 336   14    30    122 #> 337   16    30    143 #> 338   18    30    151 #> 339   20    30    157 #> 340   21    30    150 #> 341    0    31     42 #> 342    2    31     53 #> 343    4    31     62 #> 344    6    31     73 #> 345    8    31     85 #> 346   10    31    102 #> 347   12    31    123 #> 348   14    31    138 #> 349   16    31    170 #> 350   18    31    204 #> 351   20    31    235 #> 352   21    31    256 #> 353    0    32     41 #> 354    2    32     49 #> 355    4    32     65 #> 356    6    32     82 #> 357    8    32    107 #> 358   10    32    129 #> 359   12    32    159 #> 360   14    32    179 #> 361   16    32    221 #> 362   18    32    263 #> 363   20    32    291 #> 364   21    32    305 #> 365    0    33     39 #> 366    2    33     50 #> 367    4    33     63 #> 368    6    33     77 #> 369    8    33     96 #> 370   10    33    111 #> 371   12    33    137 #> 372   14    33    144 #> 373   16    33    151 #> 374   18    33    146 #> 375   20    33    156 #> 376   21    33    147 #> 377    0    34     41 #> 378    2    34     49 #> 379    4    34     63 #> 380    6    34     85 #> 381    8    34    107 #> 382   10    34    134 #> 383   12    34    164 #> 384   14    34    186 #> 385   16    34    235 #> 386   18    34    294 #> 387   20    34    327 #> 388   21    34    341 #> 389    0    35     41 #> 390    2    35     53 #> 391    4    35     64 #> 392    6    35     87 #> 393    8    35    123 #> 394   10    35    158 #> 395   12    35    201 #> 396   14    35    238 #> 397   16    35    287 #> 398   18    35    332 #> 399   20    35    361 #> 400   21    35    373 #> 401    0    36     39 #> 402    2    36     48 #> 403    4    36     61 #> 404    6    36     76 #> 405    8    36     98 #> 406   10    36    116 #> 407   12    36    145 #> 408   14    36    166 #> 409   16    36    198 #> 410   18    36    227 #> 411   20    36    225 #> 412   21    36    220 #> 413    0    37     41 #> 414    2    37     48 #> 415    4    37     56 #> 416    6    37     68 #> 417    8    37     80 #> 418   10    37     83 #> 419   12    37    103 #> 420   14    37    112 #> 421   16    37    135 #> 422   18    37    157 #> 423   20    37    169 #> 424   21    37    178 #> 425    0    38     41 #> 426    2    38     49 #> 427    4    38     61 #> 428    6    38     74 #> 429    8    38     98 #> 430   10    38    109 #> 431   12    38    128 #> 432   14    38    154 #> 433   16    38    192 #> 434   18    38    232 #> 435   20    38    280 #> 436   21    38    290 #> 437    0    39     42 #> 438    2    39     50 #> 439    4    39     61 #> 440    6    39     78 #> 441    8    39     89 #> 442   10    39    109 #> 443   12    39    130 #> 444   14    39    146 #> 445   16    39    170 #> 446   18    39    214 #> 447   20    39    250 #> 448   21    39    272 #> 449    0    40     41 #> 450    2    40     55 #> 451    4    40     66 #> 452    6    40     79 #> 453    8    40    101 #> 454   10    40    120 #> 455   12    40    154 #> 456   14    40    182 #> 457   16    40    215 #> 458   18    40    262 #> 459   20    40    295 #> 460   21    40    321 #> 461    0    41     42 #> 462    2    41     51 #> 463    4    41     66 #> 464    6    41     85 #> 465    8    41    103 #> 466   10    41    124 #> 467   12    41    155 #> 468   14    41    153 #> 469   16    41    175 #> 470   18    41    184 #> 471   20    41    199 #> 472   21    41    204 #> 473    0    42     42 #> 474    2    42     49 #> 475    4    42     63 #> 476    6    42     84 #> 477    8    42    103 #> 478   10    42    126 #> 479   12    42    160 #> 480   14    42    174 #> 481   16    42    204 #> 482   18    42    234 #> 483   20    42    269 #> 484   21    42    281 #> 485    0    43     42 #> 486    2    43     55 #> 487    4    43     69 #> 488    6    43     96 #> 489    8    43    131 #> 490   10    43    157 #> 491   12    43    184 #> 492   14    43    188 #> 493   16    43    197 #> 494   18    43    198 #> 495   20    43    199 #> 496   21    43    200 #> 497    0    44     42 #> 498    2    44     51 #> 499    4    44     65 #> 500    6    44     86 #> 501    8    44    103 #> 502   10    44    118 #> 503   12    44    127 #> 504   14    44    138 #> 505   16    44    145 #> 506   18    44    146 #> 507    0    45     41 #> 508    2    45     50 #> 509    4    45     61 #> 510    6    45     78 #> 511    8    45     98 #> 512   10    45    117 #> 513   12    45    135 #> 514   14    45    141 #> 515   16    45    147 #> 516   18    45    174 #> 517   20    45    197 #> 518   21    45    196 #> 519    0    46     40 #> 520    2    46     52 #> 521    4    46     62 #> 522    6    46     82 #> 523    8    46    101 #> 524   10    46    120 #> 525   12    46    144 #> 526   14    46    156 #> 527   16    46    173 #> 528   18    46    210 #> 529   20    46    231 #> 530   21    46    238 #> 531    0    47     41 #> 532    2    47     53 #> 533    4    47     66 #> 534    6    47     79 #> 535    8    47    100 #> 536   10    47    123 #> 537   12    47    148 #> 538   14    47    157 #> 539   16    47    168 #> 540   18    47    185 #> 541   20    47    210 #> 542   21    47    205 #> 543    0    48     39 #> 544    2    48     50 #> 545    4    48     62 #> 546    6    48     80 #> 547    8    48    104 #> 548   10    48    125 #> 549   12    48    154 #> 550   14    48    170 #> 551   16    48    222 #> 552   18    48    261 #> 553   20    48    303 #> 554   21    48    322 #> 555    0    49     40 #> 556    2    49     53 #> 557    4    49     64 #> 558    6    49     85 #> 559    8    49    108 #> 560   10    49    128 #> 561   12    49    152 #> 562   14    49    166 #> 563   16    49    184 #> 564   18    49    203 #> 565   20    49    233 #> 566   21    49    237 #> 567    0    50     41 #> 568    2    50     54 #> 569    4    50     67 #> 570    6    50     84 #> 571    8    50    105 #> 572   10    50    122 #> 573   12    50    155 #> 574   14    50    175 #> 575   16    50    205 #> 576   18    50    234 #> 577   20    50    264 #> 578   21    50    264 #>   # ways to get data for subsets records(db)[c(1, 2)] #> $Chick #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4 #>  #> $Time_Chick #>     Time Chick weight #> 1      0     1     42 #> 2      2     1     51 #> 3      4     1     59 #> 4      6     1     64 #> 5      8     1     76 #> 6     10     1     93 #> 7     12     1    106 #> 8     14     1    125 #> 9     16     1    149 #> 10    18     1    171 #> 11    20     1    199 #> 12    21     1    205 #> 13     0     2     40 #> 14     2     2     49 #> 15     4     2     58 #> 16     6     2     72 #> 17     8     2     84 #> 18    10     2    103 #> 19    12     2    122 #> 20    14     2    138 #> 21    16     2    162 #> 22    18     2    187 #> 23    20     2    209 #> 24    21     2    215 #> 25     0     3     43 #> 26     2     3     39 #> 27     4     3     55 #> 28     6     3     67 #> 29     8     3     84 #> 30    10     3     99 #> 31    12     3    115 #> 32    14     3    138 #> 33    16     3    163 #> 34    18     3    187 #> 35    20     3    198 #> 36    21     3    202 #> 37     0     4     42 #> 38     2     4     49 #> 39     4     4     56 #> 40     6     4     67 #> 41     8     4     74 #> 42    10     4     87 #> 43    12     4    102 #> 44    14     4    108 #> 45    16     4    136 #> 46    18     4    154 #> 47    20     4    160 #> 48    21     4    157 #> 49     0     5     41 #> 50     2     5     42 #> 51     4     5     48 #> 52     6     5     60 #> 53     8     5     79 #> 54    10     5    106 #> 55    12     5    141 #> 56    14     5    164 #> 57    16     5    197 #> 58    18     5    199 #> 59    20     5    220 #> 60    21     5    223 #> 61     0     6     41 #> 62     2     6     49 #> 63     4     6     59 #> 64     6     6     74 #> 65     8     6     97 #> 66    10     6    124 #> 67    12     6    141 #> 68    14     6    148 #> 69    16     6    155 #> 70    18     6    160 #> 71    20     6    160 #> 72    21     6    157 #> 73     0     7     41 #> 74     2     7     49 #> 75     4     7     57 #> 76     6     7     71 #> 77     8     7     89 #> 78    10     7    112 #> 79    12     7    146 #> 80    14     7    174 #> 81    16     7    218 #> 82    18     7    250 #> 83    20     7    288 #> 84    21     7    305 #> 85     0     8     42 #> 86     2     8     50 #> 87     4     8     61 #> 88     6     8     71 #> 89     8     8     84 #> 90    10     8     93 #> 91    12     8    110 #> 92    14     8    116 #> 93    16     8    126 #> 94    18     8    134 #> 95    20     8    125 #> 96     0     9     42 #> 97     2     9     51 #> 98     4     9     59 #> 99     6     9     68 #> 100    8     9     85 #> 101   10     9     96 #> 102   12     9     90 #> 103   14     9     92 #> 104   16     9     93 #> 105   18     9    100 #> 106   20     9    100 #> 107   21     9     98 #> 108    0    10     41 #> 109    2    10     44 #> 110    4    10     52 #> 111    6    10     63 #> 112    8    10     74 #> 113   10    10     81 #> 114   12    10     89 #> 115   14    10     96 #> 116   16    10    101 #> 117   18    10    112 #> 118   20    10    120 #> 119   21    10    124 #> 120    0    11     43 #> 121    2    11     51 #> 122    4    11     63 #> 123    6    11     84 #> 124    8    11    112 #> 125   10    11    139 #> 126   12    11    168 #> 127   14    11    177 #> 128   16    11    182 #> 129   18    11    184 #> 130   20    11    181 #> 131   21    11    175 #> 132    0    12     41 #> 133    2    12     49 #> 134    4    12     56 #> 135    6    12     62 #> 136    8    12     72 #> 137   10    12     88 #> 138   12    12    119 #> 139   14    12    135 #> 140   16    12    162 #> 141   18    12    185 #> 142   20    12    195 #> 143   21    12    205 #> 144    0    13     41 #> 145    2    13     48 #> 146    4    13     53 #> 147    6    13     60 #> 148    8    13     65 #> 149   10    13     67 #> 150   12    13     71 #> 151   14    13     70 #> 152   16    13     71 #> 153   18    13     81 #> 154   20    13     91 #> 155   21    13     96 #> 156    0    14     41 #> 157    2    14     49 #> 158    4    14     62 #> 159    6    14     79 #> 160    8    14    101 #> 161   10    14    128 #> 162   12    14    164 #> 163   14    14    192 #> 164   16    14    227 #> 165   18    14    248 #> 166   20    14    259 #> 167   21    14    266 #> 168    0    15     41 #> 169    2    15     49 #> 170    4    15     56 #> 171    6    15     64 #> 172    8    15     68 #> 173   10    15     68 #> 174   12    15     67 #> 175   14    15     68 #> 176    0    16     41 #> 177    2    16     45 #> 178    4    16     49 #> 179    6    16     51 #> 180    8    16     57 #> 181   10    16     51 #> 182   12    16     54 #> 183    0    17     42 #> 184    2    17     51 #> 185    4    17     61 #> 186    6    17     72 #> 187    8    17     83 #> 188   10    17     89 #> 189   12    17     98 #> 190   14    17    103 #> 191   16    17    113 #> 192   18    17    123 #> 193   20    17    133 #> 194   21    17    142 #> 195    0    18     39 #> 196    2    18     35 #> 197    0    19     43 #> 198    2    19     48 #> 199    4    19     55 #> 200    6    19     62 #> 201    8    19     65 #> 202   10    19     71 #> 203   12    19     82 #> 204   14    19     88 #> 205   16    19    106 #> 206   18    19    120 #> 207   20    19    144 #> 208   21    19    157 #> 209    0    20     41 #> 210    2    20     47 #> 211    4    20     54 #> 212    6    20     58 #> 213    8    20     65 #> 214   10    20     73 #> 215   12    20     77 #> 216   14    20     89 #> 217   16    20     98 #> 218   18    20    107 #> 219   20    20    115 #> 220   21    20    117 #> 221    0    21     40 #> 222    2    21     50 #> 223    4    21     62 #> 224    6    21     86 #> 225    8    21    125 #> 226   10    21    163 #> 227   12    21    217 #> 228   14    21    240 #> 229   16    21    275 #> 230   18    21    307 #> 231   20    21    318 #> 232   21    21    331 #> 233    0    22     41 #> 234    2    22     55 #> 235    4    22     64 #> 236    6    22     77 #> 237    8    22     90 #> 238   10    22     95 #> 239   12    22    108 #> 240   14    22    111 #> 241   16    22    131 #> 242   18    22    148 #> 243   20    22    164 #> 244   21    22    167 #> 245    0    23     43 #> 246    2    23     52 #> 247    4    23     61 #> 248    6    23     73 #> 249    8    23     90 #> 250   10    23    103 #> 251   12    23    127 #> 252   14    23    135 #> 253   16    23    145 #> 254   18    23    163 #> 255   20    23    170 #> 256   21    23    175 #> 257    0    24     42 #> 258    2    24     52 #> 259    4    24     58 #> 260    6    24     74 #> 261    8    24     66 #> 262   10    24     68 #> 263   12    24     70 #> 264   14    24     71 #> 265   16    24     72 #> 266   18    24     72 #> 267   20    24     76 #> 268   21    24     74 #> 269    0    25     40 #> 270    2    25     49 #> 271    4    25     62 #> 272    6    25     78 #> 273    8    25    102 #> 274   10    25    124 #> 275   12    25    146 #> 276   14    25    164 #> 277   16    25    197 #> 278   18    25    231 #> 279   20    25    259 #> 280   21    25    265 #> 281    0    26     42 #> 282    2    26     48 #> 283    4    26     57 #> 284    6    26     74 #> 285    8    26     93 #> 286   10    26    114 #> 287   12    26    136 #> 288   14    26    147 #> 289   16    26    169 #> 290   18    26    205 #> 291   20    26    236 #> 292   21    26    251 #> 293    0    27     39 #> 294    2    27     46 #> 295    4    27     58 #> 296    6    27     73 #> 297    8    27     87 #> 298   10    27    100 #> 299   12    27    115 #> 300   14    27    123 #> 301   16    27    144 #> 302   18    27    163 #> 303   20    27    185 #> 304   21    27    192 #> 305    0    28     39 #> 306    2    28     46 #> 307    4    28     58 #> 308    6    28     73 #> 309    8    28     92 #> 310   10    28    114 #> 311   12    28    145 #> 312   14    28    156 #> 313   16    28    184 #> 314   18    28    207 #> 315   20    28    212 #> 316   21    28    233 #> 317    0    29     39 #> 318    2    29     48 #> 319    4    29     59 #> 320    6    29     74 #> 321    8    29     87 #> 322   10    29    106 #> 323   12    29    134 #> 324   14    29    150 #> 325   16    29    187 #> 326   18    29    230 #> 327   20    29    279 #> 328   21    29    309 #> 329    0    30     42 #> 330    2    30     48 #> 331    4    30     59 #> 332    6    30     72 #> 333    8    30     85 #> 334   10    30     98 #> 335   12    30    115 #> 336   14    30    122 #> 337   16    30    143 #> 338   18    30    151 #> 339   20    30    157 #> 340   21    30    150 #> 341    0    31     42 #> 342    2    31     53 #> 343    4    31     62 #> 344    6    31     73 #> 345    8    31     85 #> 346   10    31    102 #> 347   12    31    123 #> 348   14    31    138 #> 349   16    31    170 #> 350   18    31    204 #> 351   20    31    235 #> 352   21    31    256 #> 353    0    32     41 #> 354    2    32     49 #> 355    4    32     65 #> 356    6    32     82 #> 357    8    32    107 #> 358   10    32    129 #> 359   12    32    159 #> 360   14    32    179 #> 361   16    32    221 #> 362   18    32    263 #> 363   20    32    291 #> 364   21    32    305 #> 365    0    33     39 #> 366    2    33     50 #> 367    4    33     63 #> 368    6    33     77 #> 369    8    33     96 #> 370   10    33    111 #> 371   12    33    137 #> 372   14    33    144 #> 373   16    33    151 #> 374   18    33    146 #> 375   20    33    156 #> 376   21    33    147 #> 377    0    34     41 #> 378    2    34     49 #> 379    4    34     63 #> 380    6    34     85 #> 381    8    34    107 #> 382   10    34    134 #> 383   12    34    164 #> 384   14    34    186 #> 385   16    34    235 #> 386   18    34    294 #> 387   20    34    327 #> 388   21    34    341 #> 389    0    35     41 #> 390    2    35     53 #> 391    4    35     64 #> 392    6    35     87 #> 393    8    35    123 #> 394   10    35    158 #> 395   12    35    201 #> 396   14    35    238 #> 397   16    35    287 #> 398   18    35    332 #> 399   20    35    361 #> 400   21    35    373 #> 401    0    36     39 #> 402    2    36     48 #> 403    4    36     61 #> 404    6    36     76 #> 405    8    36     98 #> 406   10    36    116 #> 407   12    36    145 #> 408   14    36    166 #> 409   16    36    198 #> 410   18    36    227 #> 411   20    36    225 #> 412   21    36    220 #> 413    0    37     41 #> 414    2    37     48 #> 415    4    37     56 #> 416    6    37     68 #> 417    8    37     80 #> 418   10    37     83 #> 419   12    37    103 #> 420   14    37    112 #> 421   16    37    135 #> 422   18    37    157 #> 423   20    37    169 #> 424   21    37    178 #> 425    0    38     41 #> 426    2    38     49 #> 427    4    38     61 #> 428    6    38     74 #> 429    8    38     98 #> 430   10    38    109 #> 431   12    38    128 #> 432   14    38    154 #> 433   16    38    192 #> 434   18    38    232 #> 435   20    38    280 #> 436   21    38    290 #> 437    0    39     42 #> 438    2    39     50 #> 439    4    39     61 #> 440    6    39     78 #> 441    8    39     89 #> 442   10    39    109 #> 443   12    39    130 #> 444   14    39    146 #> 445   16    39    170 #> 446   18    39    214 #> 447   20    39    250 #> 448   21    39    272 #> 449    0    40     41 #> 450    2    40     55 #> 451    4    40     66 #> 452    6    40     79 #> 453    8    40    101 #> 454   10    40    120 #> 455   12    40    154 #> 456   14    40    182 #> 457   16    40    215 #> 458   18    40    262 #> 459   20    40    295 #> 460   21    40    321 #> 461    0    41     42 #> 462    2    41     51 #> 463    4    41     66 #> 464    6    41     85 #> 465    8    41    103 #> 466   10    41    124 #> 467   12    41    155 #> 468   14    41    153 #> 469   16    41    175 #> 470   18    41    184 #> 471   20    41    199 #> 472   21    41    204 #> 473    0    42     42 #> 474    2    42     49 #> 475    4    42     63 #> 476    6    42     84 #> 477    8    42    103 #> 478   10    42    126 #> 479   12    42    160 #> 480   14    42    174 #> 481   16    42    204 #> 482   18    42    234 #> 483   20    42    269 #> 484   21    42    281 #> 485    0    43     42 #> 486    2    43     55 #> 487    4    43     69 #> 488    6    43     96 #> 489    8    43    131 #> 490   10    43    157 #> 491   12    43    184 #> 492   14    43    188 #> 493   16    43    197 #> 494   18    43    198 #> 495   20    43    199 #> 496   21    43    200 #> 497    0    44     42 #> 498    2    44     51 #> 499    4    44     65 #> 500    6    44     86 #> 501    8    44    103 #> 502   10    44    118 #> 503   12    44    127 #> 504   14    44    138 #> 505   16    44    145 #> 506   18    44    146 #> 507    0    45     41 #> 508    2    45     50 #> 509    4    45     61 #> 510    6    45     78 #> 511    8    45     98 #> 512   10    45    117 #> 513   12    45    135 #> 514   14    45    141 #> 515   16    45    147 #> 516   18    45    174 #> 517   20    45    197 #> 518   21    45    196 #> 519    0    46     40 #> 520    2    46     52 #> 521    4    46     62 #> 522    6    46     82 #> 523    8    46    101 #> 524   10    46    120 #> 525   12    46    144 #> 526   14    46    156 #> 527   16    46    173 #> 528   18    46    210 #> 529   20    46    231 #> 530   21    46    238 #> 531    0    47     41 #> 532    2    47     53 #> 533    4    47     66 #> 534    6    47     79 #> 535    8    47    100 #> 536   10    47    123 #> 537   12    47    148 #> 538   14    47    157 #> 539   16    47    168 #> 540   18    47    185 #> 541   20    47    210 #> 542   21    47    205 #> 543    0    48     39 #> 544    2    48     50 #> 545    4    48     62 #> 546    6    48     80 #> 547    8    48    104 #> 548   10    48    125 #> 549   12    48    154 #> 550   14    48    170 #> 551   16    48    222 #> 552   18    48    261 #> 553   20    48    303 #> 554   21    48    322 #> 555    0    49     40 #> 556    2    49     53 #> 557    4    49     64 #> 558    6    49     85 #> 559    8    49    108 #> 560   10    49    128 #> 561   12    49    152 #> 562   14    49    166 #> 563   16    49    184 #> 564   18    49    203 #> 565   20    49    233 #> 566   21    49    237 #> 567    0    50     41 #> 568    2    50     54 #> 569    4    50     67 #> 570    6    50     84 #> 571    8    50    105 #> 572   10    50    122 #> 573   12    50    155 #> 574   14    50    175 #> 575   16    50    205 #> 576   18    50    234 #> 577   20    50    264 #> 578   21    50    264 #>  records(db)[[1]] #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4 records(db)$Chick #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4  # subsetting first isn't recommended: removes foreign key # reference as mentions, and you need to subset again anyway records(db[[1]])[[1]] #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove database relations not linked to the main relations — reduce.database","title":"Remove database relations not linked to the main relations — reduce.database","text":"Filters database's relations, keeping main relations, considered ancestors via foreign key references. Foreign key references involving removed relations also removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove database relations not linked to the main relations — reduce.database","text":"","code":"# S3 method for class 'database' reduce(x, main, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove database relations not linked to the main relations — reduce.database","text":"x database, whose relations filtered. main character vector, containing names relations considered \"main\" relations. missing, taken names relations largest record count. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove database relations not linked to the main relations — reduce.database","text":"database, auxiliary relations foreign key references removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove database relations not linked to the main relations — reduce.database","text":"main relations considered relations largest number records. Using rejoin database resulting reduce likely fail return incomplete results.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove database schema relations not linked to the given relations — reduce.database_schema","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"Filters database schema's relations, keeping given relations, considered ancestors via foreign key references. Foreign key references involving removed relations also removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"","code":"# S3 method for class 'database_schema' reduce(x, main, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"x database schema, whose relations filtered. main character vector, containing names relations considered \"main\" relations. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"database schema, auxiliary relations foreign key references removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"method takes given set main relations, rather inferring . Using rejoin database resulting decomposing data frame reduced schema likely fail return incomplete results.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove relations not linked to the main relations — reduce","title":"Remove relations not linked to the main relations — reduce","text":"Filters object's relations, keeping main relations, considered ancestors via foreign key references. Foreign key references involving removed relations also removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove relations not linked to the main relations — reduce","text":"","code":"reduce(x, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove relations not linked to the main relations — reduce","text":"x object whose relations filtered. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove relations not linked to the main relations — reduce","text":"object class x, auxiliary relations foreign key references removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove relations not linked to the main relations — reduce","text":"Details main tables chosen given individual methods. function mostly intended simplifying database, database schema, purposes exploration, particularly examining plots. filtering might remove important auxiliary relations, also likely remove based spurious dependencies, databases can contain many.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/references.html","id":null,"dir":"Reference","previous_headings":"","what":"Schema references — references","title":"Schema references — references","text":"Generic function, returning present (foreign key) references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/references.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Schema references — references","text":"","code":"references(x, ...)  references(x) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/references.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Schema references — references","text":"x R object references, database_schema database object. ... arguments passed methods. value list, length references(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/references.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Schema references — references","text":"list, giving references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":null,"dir":"Reference","previous_headings":"","what":"Join a database into a data frame — rejoin","title":"Join a database into a data frame — rejoin","text":"Rejoins relations database single data frame, possible. inverse calling autodb, except rows might returned different order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join a database into a data frame — rejoin","text":"","code":"rejoin(database)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join a database into a data frame — rejoin","text":"database database containing data rejoined, returned decompose.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Join a database into a data frame — rejoin","text":"data frame, containing information contained database lossless self-consistent.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Join a database into a data frame — rejoin","text":"rejoining algorithm might use given relations: begins relation largest number records, joins enough relations contain present attributes. limited relations starting relation linked foreign keys, limited either, since cases constraint make impossible rejoin present attributes. Since algorithm may use given relations, algorithm may ignore types database inconsistency, different relations hold data inconsistent . case, rejoining lossy. Rejoining results reduce can also lossy. Due issues, algorithm changed use relations future. databases can represented single data frame. simple example database attribute name used several difference sources data, since rejoining results inappropriate merges.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Join a database into a data frame — rejoin","text":"","code":"# simple example db <- autodb(ChickWeight) rj <- rejoin(db) rj <- rj[order(as.integer(rownames(rj))), ] all(rj == ChickWeight) # TRUE #> [1] TRUE  # showing rejoin() doesn't check for inconsistency: # add another Chick table with the diets swapped db2 <- db[c(1, 2, 1)] records(db2)[[3]]$Diet <- rev(records(db2)[[3]]$Diet) rj2 <- rejoin(db2) rj2 <- rj2[order(as.integer(rownames(rj2))), ] all(rj2 == ChickWeight) # TRUE #> [1] TRUE"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":null,"dir":"Reference","previous_headings":"","what":"Relation vectors — relation","title":"Relation vectors — relation","text":"Creates set relation schemas, including relation's attributes candidate keys.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relation vectors — relation","text":"","code":"relation(relations, attrs_order)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relation vectors — relation","text":"relations named list relations, form two-element lists: first element contains data frame, column names attributes associated schema, second element contains list character vectors, representing candidate key. attrs_order character vector, giving names attributes. need present schemas, attributes schemas must present attrs_order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relation vectors — relation","text":"relation object, containing list given relations, attrs_order stored attribute name. Relation schemas returned keys' attributes sorted according attribute order attrs_order, keys sorted priority order. Attributes data frame also sorted, first order appearance sorted keys, order attrs_order non-prime attributes.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relation vectors — relation","text":"Relation vectors unlikely needed user directly, since essentially database objects foreign key references. mostly used mirror use vector-like relation_schema class database_schema class wrapper around. makes creating database relation_schema two-step process, two steps can done either order: creation create insert, adding references database_schema database. Duplicate schemas, ordering attribute, allowed, can removed unique. several sets relation schemas concatenated, attrs_order attributes merged, preserve original attribute orders, possible. possible, orderings disagree, returned value attrs_order attribute union instead.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relation vectors — relation","text":"","code":"rels <- relation(   list(     a = list(       df = data.frame(a = logical(), b = logical()),       keys = list(\"a\")     ),     b = list(       df = data.frame(b = logical(), c = logical()),       keys = list(\"b\", \"c\")     )   ),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) print(rels) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c records(rels) #> $a #> [1] a b #> <0 rows> (or 0-length row.names) #>  #> $b #> [1] b c #> <0 rows> (or 0-length row.names) #>  attrs(rels) #> $a #> [1] \"a\" \"b\" #>  #> $b #> [1] \"b\" \"c\" #>  stopifnot(identical(   attrs(rels),   lapply(records(rels), names) )) keys(rels) #> $a #> $a[[1]] #> [1] \"a\" #>  #>  #> $b #> $b[[1]] #> [1] \"b\" #>  #> $b[[2]] #> [1] \"c\" #>  #>  attrs_order(rels) #> [1] \"a\" \"b\" \"c\" \"d\" names(rels) #> [1] \"a\" \"b\"  # inserting data insert(rels, data.frame(a = 1L, b = 2L, c = 3L, d = 4L)) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c # data is only inserted into relations where all columns are given... insert(rels, data.frame(a = 1L, b = 2L, c = 3L)) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c # and that are listed in relations argument insert(   rels,   data.frame(a = 1L, b = 2L, c = 3L, d = 4L),   relations = \"a\" ) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c  # vector operations rels2 <- relation(   list(     e = list(       df = data.frame(a = logical(), e = logical()),       keys = list(\"e\")     )   ),   attrs_order = c(\"a\", \"e\") ) c(rels, rels2) # attrs_order attributes are merged #> 3 relations #> 5 attributes: a, b, c, d, e #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation e: e, a; 0 records #>   key 1: e unique(c(rels, rels)) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c  # subsetting rels[1] #> 1 relation #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a rels[c(1, 2, 1)] #> 3 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation a.1: a, b; 0 records #>   key 1: a stopifnot(identical(rels[[1]], rels[1]))  # reassignment rels3 <- rels rels3[2] <- relation(   list(     d = list(       df = data.frame(d = logical(), c = logical()),       keys = list(\"d\")     )   ),   attrs_order(rels3) ) print(rels3) # note the relation's name doesn't change #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: d, c; 0 records #>   key 1: d # names(rels3)[2] <- \"d\" # this would change the name keys(rels3)[[2]] <- list(character()) # removing keys first... # for a relation_schema, we could then change the attrs for # the second relation. For a created relation, this is not # allowed. if (FALSE) { # \\dontrun{   attrs(rels3)[[2]] <- c(\"b\", \"c\")   names(records(rels3)[[2]]) <- c(\"b\", \"c\") } # }  # changing appearance priority for attributes rels4 <- rels attrs_order(rels4) <- c(\"d\", \"c\", \"b\", \"a\") print(rels4) #> 2 relations #> 4 attributes: d, c, b, a #> relation a: a, b; 0 records #>   key 1: a #> relation b: c, b; 0 records #>   key 1: c #>   key 2: b  # reconstructing from components rels_recon <- relation(   Map(list, df = records(rels), keys = keys(rels)),   attrs_order(rels) ) stopifnot(identical(rels_recon, rels))  # can be a data frame column data.frame(id = 1:2, relation = rels) #>   id               relation #> 1  1 relation a (0 records) #> 2  2 relation b (0 records)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Relation schema vectors — relation_schema","title":"Relation schema vectors — relation_schema","text":"Creates set relation schemas, including relation's attributes candidate keys.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relation schema vectors — relation_schema","text":"","code":"relation_schema(schemas, attrs_order)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relation schema vectors — relation_schema","text":"schemas named list schemas, form two-element lists: first element contains character vector attributes relation schema, second element contains list character vectors, representing candidate key. attrs_order character vector, giving names attributes. need present schemas, attributes schemas must present attrs_order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relation schema vectors — relation_schema","text":"relation_schema object, containing list given schemas, attrs_order stored attribute name. Relation schemas returned keys' attributes sorted according attribute order attrs_order, keys sorted priority order. Attributes schema also sorted, first order appearance sorted keys, order attrs_order non-prime attributes.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relation schema vectors — relation_schema","text":"Duplicate schemas, ordering attribute, allowed, can removed \\code{\\link{unique}}. several sets relation schemas concatenated, attrs_order attributes merged, preserve original attribute orders, possible. possible, orderings disagree, returned value attrs_order attribute union instead.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relation schema vectors — relation_schema","text":"","code":"schemas <- relation_schema(   list(     a = list(c(\"a\", \"b\"), list(\"a\")),     b = list(c(\"b\", \"c\"), list(\"b\", \"c\"))   ),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) print(schemas) #> 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c attrs(schemas) #> $a #> [1] \"a\" \"b\" #>  #> $b #> [1] \"b\" \"c\" #>  keys(schemas) #> $a #> $a[[1]] #> [1] \"a\" #>  #>  #> $b #> $b[[1]] #> [1] \"b\" #>  #> $b[[2]] #> [1] \"c\" #>  #>  attrs_order(schemas) #> [1] \"a\" \"b\" \"c\" \"d\" names(schemas) #> [1] \"a\" \"b\"  # vector operations schemas2 <- relation_schema(   list(     e = list(c(\"a\", \"e\"), list(\"e\"))   ),   attrs_order = c(\"a\", \"e\") ) c(schemas, schemas2) # attrs_order attributes are merged #> 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema e: e, a #>   key 1: e unique(c(schemas, schemas)) #> 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c  # subsetting schemas[1] #> 1 relation schema #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a schemas[c(1, 2, 1)] #> 3 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema a.1: a, b #>   key 1: a stopifnot(identical(schemas[[1]], schemas[1]))  # reassignment schemas3 <- schemas schemas3[2] <- relation_schema(   list(d = list(c(\"d\", \"c\"), list(\"d\"))),   attrs_order(schemas3) ) print(schemas3) # note the schema's name doesn't change #> 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: d, c #>   key 1: d # names(schemas3)[2] <- \"d\" # this would change the name keys(schemas3)[[2]] <- list(character()) # removing keys first... attrs(schemas3)[[2]] <- c(\"b\", \"c\") # so we can change the attrs legally keys(schemas3)[[2]] <- list(\"b\", \"c\") # add the new keys stopifnot(identical(schemas3, schemas))  # changing appearance priority for attributes attrs_order(schemas3) <- c(\"d\", \"c\", \"b\", \"a\") print(schemas3) #> 2 relation schemas #> 4 attributes: d, c, b, a #> schema a: a, b #>   key 1: a #> schema b: c, b #>   key 1: c #>   key 2: b  # reconstructing from components schemas_recon <- relation_schema(   Map(list, attrs(schemas), keys(schemas)),   attrs_order(schemas) ) stopifnot(identical(schemas_recon, schemas))  # can be a data frame column data.frame(id = 1:2, schema = schemas) #>   id   schema #> 1  1 schema a #> 2  2 schema b"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":null,"dir":"Reference","previous_headings":"","what":"Rename relational data attributes — rename_attrs","title":"Rename relational data attributes — rename_attrs","text":"Generic function, renaming attributes present database-like structure.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rename relational data attributes — rename_attrs","text":"","code":"rename_attrs(x, names, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rename relational data attributes — rename_attrs","text":"x object attrs_order attribute. includes relational schema objects, relation_schema database_schema object, relational data objects, relation database object, functional_dependency objects. names character vector length attrs_order(x), duplicated elements, used new attribute names. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rename relational data attributes — rename_attrs","text":"relational object type x, attributes renamed consistently across whole object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rename relational data attributes — rename_attrs","text":"function different intended use re-assigning attrs_order: intended rearranging order attributes, without renaming . intended renaming attributes without re-ordering .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subrelations.html","id":null,"dir":"Reference","previous_headings":"","what":"Database subrelations — subrelations","title":"Database subrelations — subrelations","text":"Generic function, returning subrelations x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subrelations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Database subrelations — subrelations","text":"","code":"subrelations(x, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subrelations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Database subrelations — subrelations","text":"x R object, intended sort database-like object contains relations, database object. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subrelations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Database subrelations — subrelations","text":"relation-type object, list relation-type objects subrelation vectorised. example, x database, result contained relation.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subschemas.html","id":null,"dir":"Reference","previous_headings":"","what":"Schema subschemas — subschemas","title":"Schema subschemas — subschemas","text":"Generic function, returning subschemas x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subschemas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Schema subschemas — subschemas","text":"","code":"subschemas(x, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subschemas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Schema subschemas — subschemas","text":"x R object, intended sort schema contains schemas, database_schema object. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subschemas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Schema subschemas — subschemas","text":"schema-type object, list schema-type objects subschema vectorised. example, x database_schema, result contained relation_schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthesise relation schemas from functional dependencies — synthesise","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"Synthesises dependency relationships dependencies database schema satisfying least third normal form, using Bernstein's synthesis.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"","code":"synthesise(   dependencies,   ensure_lossless = TRUE,   reduce_attributes = TRUE,   remove_avoidable = FALSE,   constants_name = \"constants\",   progress = FALSE,   progress_file = \"\" )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"dependencies functional_dependency object, given discover. ensure_lossless logical, TRUE default. TRUE, decomposition lossless, extra relation added make decomposition lossless. reduce_attributes logical, TRUE default. TRUE, dependencies checked determinant attributes made redundant dependencies. redundant dependencies output discover, since redundant attributes. remove_avoidable logical, indicating whether remove avoidable attributes relations. , attribute removed relations keys can changed needed preserve given functional dependencies. constants_name scalar character, giving name relation created store constant attributes. generated relation name, changed, warning, ensure relations unique name. progress logical, whether display progress user dependency search discover. progress_file scalar character connection. progress non-zero, determines progress written , way file argument cat.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"relation_schema object, containing synthesised relation schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"Bernstein's synthesis synthesis algorithm normalisation set dependencies set relations third normal form. implementation based version given referenced paper. implementation also includes common additional step, ensure resulting decomposition lossless, .e. relation satisfying given dependencies can perfectly reconstructed relations given decomposition. done adding additional relation, containing key original attributes, one already present. additional optional step, schemas checked \"avoidable\" attributes, can removed without loss information. Constant attributes, .e. whose determinant set empty, get assigned relation keys. Output independent order input dependencies: schemas sorted according simplest keys. Schemas sorted ensuring losslessness, removing avoidable attributes. result, neither optional step changes order schemas, ensuring losslessness can add extra schema end output vector.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"3NF synthesis algorithm: Bernstein P. . (1976) Synthesizing third normal form relations functional dependencies. ACM Trans. Database Syst., 1, 4, 277–298. Removal avoidable attributes: Ling T., Tompa F. W., Kameda T. (1981) improved third normal form relational databases. ACM Trans. Database Syst., 6, 2, 329–346.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"","code":"# example 6.24 from The Theory of Relational Databases by David Maier # A <-> B, AC -> D, AC -> E, BD -> C deps <- functional_dependency(   list(     list(\"A\", \"B\"),     list(\"B\", \"A\"),     list(c(\"A\", \"C\"), \"D\"),     list(c(\"A\", \"C\"), \"E\"),     list(c(\"B\", \"D\"), \"C\")   ),   attrs_order = c(\"A\", \"B\", \"C\", \"D\", \"E\") ) synthesise(deps, remove_avoidable = FALSE) #> 2 relation schemas #> 5 attributes: A, B, C, D, E #> schema A: A, B #>   key 1: A #>   key 2: B #> schema A_C: A, C, B, D, E #>   key 1: A, C #>   key 2: B, D synthesise(deps, remove_avoidable = TRUE) #> 2 relation schemas #> 5 attributes: A, B, C, D, E #> schema A: A, B #>   key 1: A #>   key 2: B #> schema A_C: A, C, D, E #>   key 1: A, C #>   key 2: A, D"},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-development-version","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb (development version)","text":"Added d2, converter D2 plotting language, similar gv GraphViz. Removed partial match warnings (thanks Hadley Wickham pull request). now several smaller vignettes, instead single larger one, hopefully little easier read.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-310","dir":"Changelog","previous_headings":"","what":"autodb 3.1.0","title":"autodb 3.1.0","text":"CRAN release: 2025-09-18","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-3-1-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 3.1.0","text":"Changed autoref (normalise) spend less time removing extraneous references. Changed autodb (optionally database) check foreign key references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-300","dir":"Changelog","previous_headings":"","what":"autodb 3.0.0","title":"autodb 3.0.0","text":"CRAN release: 2025-06-25","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"breaking-changes-3-0-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"autodb 3.0.0","text":"accuracy argument now optional, defaulting one exact dependency search. reflects reduced focus approximate dependencies: main autodb function doesn’t allow anyway, new FDHits search algorithms can search exact dependencies. Arguments specific DFD algorithm, including accuracy, moved back list, since lesser priority. skip_bijections argument now first DFD-specific arguments, since setting non-default value speeds search, whereas non-accuracy parameters slows . insert methods longer allow inserting data duplicate column names, since makes expected result ambiguous.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-3-0-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 3.0.0","text":"package remaining package dependencies; packages Suggests purely used vignettes testing. still implicit dependency GraphViz, use gv export plotting code. discover two variants FDHits search algorithm, alternatives DFD. FDHitsSep now default algorithm, since ’s currently quickest general. relation database methods rename_attrs gv now run significantly quickly large data sets, due re-running key validity checks. database method reduce unnecessary validity checks removed, runs quickly, especially databases large number records. database_schema database methods [ unnecessary validity checks removed. normalise unnecessary closure calculations removed. normalise, synthesise, autoref, rejoin improved performance, due efficient closure checks. decompose new check parameter, allow skipping validity checks data frame decompose one used create schema. Values now rounded significant digits, intended, rather decimal places. addition autodb, discover, df_equiv, values now also rounded insert decompose. relation error messages informative. database method reduce main argument, like database_schema method. previous behaviour, taking names relations records, main’s default. autodb, discover, decompose, insert keep_rownames argument, allow including row names column, instead user including manually.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-3-0-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 3.0.0","text":"format method relation now describes elements relations, rather schemas. autodb passes progress_file argument discover; previously passed ““, progress messages discover printed stdout.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-231","dir":"Changelog","previous_headings":"","what":"autodb 2.3.1","title":"autodb 2.3.1","text":"CRAN release: 2025-03-19 minor changes tests, part re-submission CRAN.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-230","dir":"Changelog","previous_headings":"","what":"autodb 2.3.0","title":"autodb 2.3.0","text":"performance improvements, part re-submission CRAN.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-2-3-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 2.3.0","text":"Added convenience function called df_records, converting data frame list row values. sometimes useful data frames, e.g. checking rows data frame present another one. Improved run time database larger data sets, specifically validity checks data satisfying foreign key references. Improved run time create relation_schema database_schema, removing validity checks. input valid, redundant. Improved run time autodb, skipping removal extraneous attributes. done results discover, won’t .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-2-3-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 2.3.0","text":"CRAN fixes DESCRIPTION. Fixes documentation.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-2-2-1","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 2.2.1","text":"CRAN fixes DESCRIPTION. Fixes documentation: PDF version manual now created successfully.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-220","dir":"Changelog","previous_headings":"","what":"autodb 2.2.0","title":"autodb 2.2.0","text":"Continuing efforts prepare submission CRAN.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-2-2-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 2.2.0","text":"Changed handling numerical/complex variables autodb, discover, df_equiv, round number significant digits. Due nature floating-point, definition functional dependency, floating-point values can’t compared using equality (==), .equal purposes functional dependency discovery / validation, result consistent different machines. , floating-point variables now rounded small level precision default processing. data frame loaded file, recommend reading numerical/complex variables character values (strings), ’s appropriate, avoid loss precision. df_equiv now checks rows exact matches, outside rounding mentioned . Previously, compared rows using match, gave control float precision. relation_schema, relation, database_schema, database now return name-based subset successfully given names exist object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-211","dir":"Changelog","previous_headings":"","what":"autodb 2.1.1","title":"autodb 2.1.1","text":"minor changes documentation tests, allow package updates submission CRAN.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-2-1-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 2.1.0","text":"Added format .data.frame methods functional_dependency, relation_schema, database_schema, relation, database. allows columns data frame initial construction. ’m sure ’d want put data frame column, ’s consistent idea objects classes mostly treatable vectors. warned: don’t currently work tibbles. Added .character method functional_dependency. optional align_arrows argument can add padding one side, order make arrows align ’re printed different lines. options used align arrows print method, format method printed data frame column. Added == != implementations functional_dependency. ignore differences attrs_order: differently-ordered determinant sets considered equal. Added rename_attrs method functional_dependency. Added dependants argument discover, limit functional dependency search dependant given set column names, defaulting . significantly speed searches dependants interest. Added detset_limit argument discover/autodb, limits FD search look dependencies determinant set size given limit. DFD, usually doesn’t significantly reduce search time, won’t make worse. useful search algorithms implemented. Added argument insert, FALSE default. TRUE, insert returns error data insert doesn’t include attribute elements inserted , rather skipping elements. helps prevent accidental -ops. Running discover() autodb() progress = TRUE now keeps output display date using console-based version R. DFD now checks single-attribute keys, excludes determinants main search, potentially reducing search time.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-2-1-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 2.1.0","text":"Fixed gv account Graphviz HTML-like labels requiring certain characters, namely set “<>&, escaped Graphviz HTML-like labels, removed completely attribute values. Fixed df_equiv properly handle data frames zero columns duplicate rows. Fixed database_schema database, reference re-assignments, allow references given referee’s key attribute order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-200","dir":"Changelog","previous_headings":"","what":"autodb 2.0.0","title":"autodb 2.0.0","text":"general theme version classes intermediate results: functional dependencies, schemas, databases now fleshed-classes, methods keep self-consistent. constructors, users create , instead generate given data frame.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"breaking-changes-2-0-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"autodb 2.0.0","text":"Renamed dfd discover, reflect generalisation allow use methods. moment, just includes DFD. Removed flatten exported functions, favour flattening functional dependencies dfd/discover instead. Since flatten usually called anyway, output readable since adding print method , little reason keep old dfd/discover output format, functional dependencies grouped dependant. Renamed cross_reference autoref, better reflect purpose generating foreign key references. Renamed normalise synthesise, reflect creating relation schemas, foreign key references. new function named normalise now calls wrapper synthesise autoref, since cases don’t need steps separately. Additionally, ensure_lossless now argument synthesise rather autoref: nature place put , since synthesise creates relations, autoref adds foreign key references. noted improvements, functional dependency objects now subsetting methods. particular, [[ method, code used [[ extract determinant sets dependants functional dependencies longer work. extracted new detset dependant functions instead. Similarly, database class subsetting methods, components must extracted records, keys, . database class longer assigns parents attribute relation, since duplicates foreign key reference information given references. database class longer name attribute. used name graph using gv function, now argument database method gv instead, bringing arguments line methods. relationships database_schema database objects now called references, better reflect foreign key constraints, stored format better reflects : instead element pair attributes foreign key, one element whole foreign key, containing involved attributes. Similarly, now printed format “child.{c1, c2, …} -> parent.{p1, p2, …}” instead “child.c1 -> parent.p1; child.c2 -> parent.p2; …”. cross_reference/autoref now defaults generating one foreign key reference per parent-child relation pair, rather keeping one first child key priority order. can result confusion plots, since references still plotted one attribute pair time.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-2-0-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 2.0.0","text":"Added functional_dependency class flattened functional dependency sets. attributes vector now stored attribute, dependencies can accessed simple list without list subsetting operators. also detset, dependant, attrs_order generic functions extracting relevant parts. detset dependant, particular, useful purposes filtering predicates. Added relation_schema class relational schema sets, returned synthesise. attributes keys now stored together named list, attrs_order vector attribute order stored attribute. functional_dependency, lets schemas accessed like vector. also merge_empty_keys combining schemas empty key, attrs, keys, attrs_order generic functions extracting relevant parts. Added database_schema class database schemas, returned normalise. inherits relation_schema, foreign key references additional references attribute. merge_empty_keys method conserves validity foreign key references. Additionally, names contained relation schemas changed using names<-, references changed use new names. Added relation class vectors relations containing data. Since database_schema just relation_schema vector foreign key references added, relation class added equivalent underlying vector database class. user package probably won’t need use . database now wrapper class around relation, adds foreign key references, handles separately methods. methods [, [[, – except functional_dependency – $ subsetting operators, along replacement equivalents, [<- etc., allow treating vectors relation schemas relations. Subsetting also removes foreign key references database_schema database objects longer relevant. methods prevent subsetting operators used access object’s internal components, many generic functions mentioned written allow access principled manner, requiring knowledge structure implemented. c method vector-like concatenation. two non-trivial aspects . Firstly, concatenating objects different attrs_order attributes, c merges orders keep consistent, possible. Secondly, database_schema database, foreign key references changed reflect changes made relation names keep unique. unique method vector-like removal duplicate schemas / relations. conserves validity foreign key references database_schema database objects. relation database objects, duplication doesn’t require records kept order. names<- method consistently changing relation (schema) names. particular, databases database schemas, ensures names also changed references. , except functional_dependency, rename_attrs method renaming attributes across whole object. renames schemas, relations, references, . Added create generic function, creating relation database objects relation_schema database_schema objects, respectively. created objects contain data. function roughly equivalent CREATE TABLE SQL, vectorised nature relation classes means several tables created . Added insert generic function relation database objects, takes data frame new data, inserts relation object whose attributes present new data. roughly equivalent SQL’s INSERT, works multiple relations , means ’s now way put data database outside decompose. Indeed, decompose now equivalent calling create, calling insert relations. Adjusted normalise prefer remove dependencies dependants determinant sets later table order, larger dependant sets. brings line similar decisions made package functions. Simplified internals dfd/discover improve computation time. Added skip_bijections option dfd/discover, speed functional dependency searches pairwise-equivalent attributes present.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-2-0-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 2.0.0","text":"Corrected vignette re: remove spurious dependencies . Corrected autodb documentation link page database format information. Corrected df_equiv work data.frame columns lists. Fixed dfd/discover treating similar numeric values equal, resulting data frames insertable schema. Fixed database checks handling doubles correctly. Specifically, foreign key reference checks involve merging tables together, merge operates doubles tolerance ’s set within internal method, merges can create duplicates need removed afterwards. Similarly, fixed rejoin case merges based doubles, sometimes resulting duplicates. Fixed normalise’s return output invariant given order functional_dependency input. Fixed normalise returning relations attributes wrong order certain cases remove_avoidable = TRUE. Fixed gv giving Graphviz code result incorrect diagrams: relation attribute names converted lower case, checked uniqueness afterwards. result incorrect foreign key references drawn. fix also accounts current bug Graphviz, edges HTML-style node ports ignore case port labels.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-110","dir":"Changelog","previous_headings":"","what":"autodb 1.1.0","title":"autodb 1.1.0","text":"Added NEWS.md file track changes package.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-1-1-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 1.1.0","text":"Added examples autodb, dfd, gv, rejoin. Added reference removing avoidable attributes enhanced third normal form. Changed decompose return error data.frame doesn’t satisfy functional dependencies implied schema. return error using decompose schema derived data.frame approximate dependencies included. Previously, using decompose dfd approximate dependencies result constructing database duplicate key values, since ’s currently handling approximate dependencies database construction, records ignored approximate dependencies kept. incorrect behaviour; decompose added back approximate dependencies package can properly handle . Made reduce generic, added method database schemas. Currently method requires explicitly naming main relations, rather inferring . Removed incorrect comment vignette needing foreign keys reconstruct original data frame database. Tidied nudge data documentation, improved commentary publication references vignette. Removed accuracy argument autodb, due approximate dependencies now returning error decompose.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-1-1-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 1.1.0","text":"Fixed print.database refer records instead rows. Fixed existing reference formatting. Fixed references missing-value implementation mockup vignette. Fixed bug normalise resulted relations duplicate keys. Fixed bug normalise, resulted schemas didn’t reproduce given functional dependencies. Fixed dfd’s data simplification step POSIXct datetimes, case two times differ standard/daylight-savings time (e.g. 1:00:00 EST vs. 1:00:00 EDT day). Fixed bug dfd cache = TRUE, data frame column names argument names paste can result error. Fixed decomposition tables zero columns (TABLE_DUM TABLE_DEE) allow lossless rejoin. Fixed bug output gv methods included Graphviz syntax errors given relations zero-length names. gv.data.frame now requires name non-empty; gv.database_schema gv.database replace zero-length names.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-100","dir":"Changelog","previous_headings":"","what":"autodb 1.0.0","title":"autodb 1.0.0","text":"Initial version","code":""}]
