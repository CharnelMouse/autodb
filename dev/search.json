[{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"terminology","dir":"Articles","previous_headings":"","what":"Terminology","title":"Using autodb","text":"avoid confusion, vignette consistent terminology: database consists relations, records attributes. line terms used relational model; Statistics, talk tables, rows values variables, column variable. original data set, flat table, refer data frame instead, also consists records attributes. talk type values attribute can take, talk class, relational model R, rather value type, many programming languages.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Using autodb","text":"autodb described DESCRIPTION file following way: Automatic normalisation data frame third normal form, intention easing process data cleaning. (Usage design actual database advised.)” Let us begin .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"for-data-cleaning","dir":"Articles","previous_headings":"Motivation","what":"For data cleaning","title":"Using autodb","text":"Database normalisation works principle data express piece information single place. done reduce chance modification accidentally change remove pieces information. Data cleaning works principle remove duplicate observations structural errors, clear understanding associations different observations, parts observations. done ensure high quality data used analysis, found equally important making sure understand domain hoping model. Normalisation helpful areas. usually use original, flat, “tidy” data analysis . However, checking data’s consistency, using data learn domain, normalised data often helpful, whether ’s used analysis . usually data checking following conditions: need store data normalised form. work normally consists one-analyses, won’t see data ’ve finished work. permanent data, better store data database designed hold , ’re able . Limited documentation. work, lucky given key data dictionary data set . , usually proves wrong somehow. makes even important data checking, just looking errors, also exercise understanding problem domain starting model . Data fits local memory. process done batches using streaming algorithm, advanced case. ’s context usually normalisation hand, like tool semi-automatically. package intended tool, using minimal amount additional libraries.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"not-for-database-design","dir":"Articles","previous_headings":"Motivation","what":"Not for database design","title":"Using autodb","text":"Good database design hard involved process, requires strong grasp domain database hold information . Please don’t try use package autopilot. particular, conditions described mean things differently good practice normalised relational databases: need handle constant attributes, value every record. real database, probably expect stay constant data added, know relation place . one-data checking, isn’t data coming, need handle attributes automatic way placing “constants” relation empty key, database designers probably frown . don’t care database design principles concerned avoiding errors deletion, modification, , data won’t change. means don’t care introducing artificial keys, unless think make data modelling convenient. Similarly, don’t care single-attribute reference relations, used make sure relations assign legal values relation’s attribute. “derived relations”, also known “views”, additional relations created others lookup convenience. expect using data frame modelling, rather database, lookups aren’t commonly necessary, left discretion user manually base R’s merge function.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"to-third-normal-form","dir":"Articles","previous_headings":"Motivation","what":"To third normal form","title":"Using autodb","text":"autodb gets given data frame third normal form: every attribute depends whole key(s), non-key attributes depend nothing key(s). chosen existing algorithm, Bernstein’s synthesis, normalising third normal form, ’s highest normal form attainable arbitrary original data frames. additional enhancement available option: see section avoidable attributes details.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"simple-examples","dir":"Articles","previous_headings":"","what":"Simple examples","title":"Using autodb","text":"simple examples, use ChickWeight dataset, included base R.","code":"summary(ChickWeight) #>      weight           Time           Chick     Diet    #>  Min.   : 35.0   Min.   : 0.00   13     : 12   1:220   #>  1st Qu.: 63.0   1st Qu.: 4.00   9      : 12   2:120   #>  Median :103.0   Median :10.00   20     : 12   3:120   #>  Mean   :121.8   Mean   :10.72   10     : 12   4:118   #>  3rd Qu.:163.8   3rd Qu.:16.00   17     : 12           #>  Max.   :373.0   Max.   :21.00   19     : 12           #>                                  (Other):506"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"normalisation-with-autodb","dir":"Articles","previous_headings":"Simple examples","what":"Normalisation with autodb","title":"Using autodb","text":"simplest way normalisation autodb function:","code":"db <- autodb(ChickWeight) db #> database with 2 relations #> 4 attributes: weight, Time, Chick, Diet #> relation Chick: Chick, Diet; 50 records #>   key 1: Chick #> relation Time_Chick: Time, Chick, weight; 578 records #>   key 1: Time, Chick #> references: #> Time_Chick.{Chick} -> Chick.{Chick}"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"plots","dir":"Articles","previous_headings":"Simple examples","what":"Plots","title":"Using autodb","text":"plotting method within autodb package . Instead, functions write normalised objects inputs Graphviz visualisation software, using DOT language. generic function gv, calls gv.database method database, db: can saved file passing Graphviz elsewhere, can passed R function renders Graphviz code, grViz DiagrammeR package: relation represented box, top row giving relation name number records, rows detailing attributes. middle grid cells: column cells represents (candidate) key relation, attributes key cell filled black. can see ChickWeight split two relations, weight unique combination Chick number time, Chick number determining diet. can also see number records relation, classes attributes relations. gv also methods data.frame, database_schema, introduced later.","code":"db_text <- gv(db) cat(db_text) #> digraph { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Chick (50 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD><\/TD><TD PORT=\"FROM_diet\">factor<\/TD><\/TR> #>     <\/TABLE>>]; #>   \"Time_Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Time_Chick (578 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_time\">numeric<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD><\/TD><TD PORT=\"FROM_weight\">numeric<\/TD><\/TR> #>     <\/TABLE>>]; #>  #>   \"Time_Chick\":FROM_chick -> \"Chick\":TO_chick; #> } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   show <- function(x) DiagrammeR::grViz(gv(x))   maybe_plot <- function(x) DiagrammeR::grViz(gv(x)) }else{   show <- print   maybe_plot <- function(x) invisible(NULL) } maybe_plot(db)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"finding-functional-dependencies","dir":"Articles","previous_headings":"Simple examples","what":"Finding functional dependencies","title":"Using autodb","text":"looked final result first, now look individual steps. first step find (non-trivial minimal) dependencies present given data frame. various ways ; default, package uses FDHitsSep, depth-first search algorithm. run using discover function, setting progress TRUE see steps taken: simplifying data something quicker iterate – specifically, converting attributes integer values – algorithm takes attribute turn possible dependant, finds sets attributes determine . result list functional dependencies, format determinant set -> dependant, attribute named attrs_order gives attribute names original order. three parts (generic) extraction function: former two, especially, useful filtering, ’ll see later.","code":"deps <- discover(ChickWeight, progress = TRUE) #> formatting numerical/complex variables with 7 significant digits #> simplifying data types #> calculating single-attribute PLIs #> sampling difference sets #> 7 initial diffsets #>  #> dependant weight #> dependant Time #> dependant Chick #> dependant Diet #>  #> FDHitsSep complete #> 9 final diffsets #> 10 nodes visited #> 7 partitions cached deps #> 2 functional dependencies #> 4 attributes: weight, Time, Chick, Diet #> Time, Chick -> weight #>       Chick -> Diet detset(deps) #> [[1]] #> [1] \"Time\"  \"Chick\" #>  #> [[2]] #> [1] \"Chick\" dependant(deps) #> [1] \"weight\" \"Diet\" attrs_order(deps) #> [1] \"weight\" \"Time\"   \"Chick\"  \"Diet\""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"normalisation","dir":"Articles","previous_headings":"Simple examples","what":"Normalisation","title":"Using autodb","text":"Now list discovered dependencies, can construct database schema, relation schemas normalised third normal form. done using version Bernstein’s synthesis. Like database , can also plot database schema: similar database plot given , information present, requires data frame . class information attributes, extracted data frame dependency discovery, record counts individual relation schemas. However, automatically-generated names individual relations. Additionally, point connections relation schemas, since Bernstein’s synthesis doesn’t supply information foreign key references. use database schema build database, ’d rather add foreign key references first.","code":"schema <- synthesise(deps) schema #> 2 relation schemas #> 4 attributes: weight, Time, Chick, Diet #> schema Chick: Chick, Diet #>   key 1: Chick #> schema Time_Chick: Time, Chick, weight #>   key 1: Time, Chick maybe_plot(schema)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"tuning-detection-and-normalisation","dir":"Articles","previous_headings":"Simple examples","what":"Tuning detection and normalisation","title":"Using autodb","text":"Let’s look different dataset moment, look cases don’t want use dependencies given. ’ll use Titanic data set, also provided base R. data array form, first convert data frame form: simple set data, single count observation, Freq, combination four determining attributes. words, relation already normalised, expect one relation normalised database. use autodb , get following database: Oops! search found functional dependencies count used determine another attribute. clearly spurious: frequency count can’t causally determine age, example. However, algorithm still finds dependencies, counts unique often enough make dependencies hold given data. two approaches can take eliminate spurious dependencies: letting detected first place, removing using synthesise. stop detected, can put constraints discovered discover: can ask certain attributes considered determinants, can exclude attributes inherit certain classes. example, exclude Freq considered: Alternatively, exclude attributes inherit “numeric”: can used arguments autodb : Generally, excluding numeric attributes determinants often useful, expect non-integer numbers measurement, part primary key. Alternatively, remove unwanted dependencies using decompose. found dependencies, don’t exclude anything: can remove unwanted dependencies, Age dependant:","code":"knitr::kable(as.data.frame(Titanic)) show(autodb(as.data.frame(Titanic))) titanic_deps_freqonly <- discover(as.data.frame(Titanic), exclude = \"Freq\") titanic_deps_freqonly #> 1 functional dependency #> 5 attributes: Class, Sex, Age, Survived, Freq #> Class, Sex, Age, Survived -> Freq identical(titanic_deps_freqonly, discover(as.data.frame(Titanic), exclude_class = \"numeric\")) #> [1] TRUE show(autodb(as.data.frame(Titanic), exclude = \"Freq\")) titanic_deps <- discover(as.data.frame(Titanic)) titanic_deps #> 3 functional dependencies #> 5 attributes: Class, Sex, Age, Survived, Freq #>       Sex, Survived, Freq -> Age #>     Class, Survived, Freq -> Age #> Class, Sex, Age, Survived -> Freq titanic_deps[dependant(titanic_deps) == \"Freq\"] #> 1 functional dependency #> 5 attributes: Class, Sex, Age, Survived, Freq #> Class, Sex, Age, Survived -> Freq"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"adding-foreign-key-references","dir":"Articles","previous_headings":"Simple examples","what":"Adding foreign key references","title":"Using autodb","text":"Getting back ChickWeight example, now database schema, consisting list relation schemas. However, information relation schemas linked . particular, information foreign keys. can add information using autoref: also used normalise, instead synthesise autoref separately: Plotting updated database schema shows relation schemas , linked together foreign key references:","code":"linked_schema <- autoref(schema) linked_schema #> database schema with 2 relation schemas #> 4 attributes: weight, Time, Chick, Diet #> schema Chick: Chick, Diet #>   key 1: Chick #> schema Time_Chick: Time, Chick, weight #>   key 1: Time, Chick #> references: #> Time_Chick.{Chick} -> Chick.{Chick} normalise(deps) #> database schema with 2 relation schemas #> 4 attributes: weight, Time, Chick, Diet #> schema Chick: Chick, Diet #>   key 1: Chick #> schema Time_Chick: Time, Chick, weight #>   key 1: Time, Chick #> references: #> Time_Chick.{Chick} -> Chick.{Chick} maybe_plot(linked_schema)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"decomposing-the-original-relation","dir":"Articles","previous_headings":"Simple examples","what":"Decomposing the original relation","title":"Using autodb","text":"Finally, normalised database schema, can apply original data frame, new one structure. results normalised database, got using autodb: now record counts added.","code":"db2 <- decompose(ChickWeight, linked_schema) show(db2)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"rejoining-a-database-back-into-a-data-frame","dir":"Articles","previous_headings":"Simple examples","what":"Rejoining a database back into a data frame","title":"Using autodb","text":"can reverse process turning data frame database rejoin function. may identical ChickWeight, since rows may rearranged. However, can use convenience function df_equiv check equivalence row reordering: rejoined, relation attributes original order. However, record order might changed.","code":"rejoined <- rejoin(db) summary(rejoined) #>      weight           Time           Chick     Diet    #>  Min.   : 35.0   Min.   : 0.00   13     : 12   1:220   #>  1st Qu.: 63.0   1st Qu.: 4.00   9      : 12   2:120   #>  Median :103.0   Median :10.00   20     : 12   3:120   #>  Mean   :121.8   Mean   :10.72   10     : 12   4:118   #>  3rd Qu.:163.8   3rd Qu.:16.00   17     : 12           #>  Max.   :373.0   Max.   :21.00   19     : 12           #>                                  (Other):506 identical(rejoined, ChickWeight) #> [1] FALSE df_equiv(rejoined, ChickWeight) #> [1] TRUE"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"a-larger-example","dir":"Articles","previous_headings":"","what":"A larger example","title":"Using autodb","text":"Included package 447--25 data frame called nudge: data set meta-analysis, looking effectiveness “nudge” interventions. Measurements taken within three-layer hierarchy: publications contain studies, contain effect size measurements. expect hierarchy apparent normalisation.","code":"if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   DiagrammeR::grViz(gv(nudge, name = \"nudge\")) }else{   summary(nudge) }"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"initial-decomposition","dir":"Articles","previous_headings":"A larger example","what":"Initial decomposition","title":"Using autodb","text":"Getting full dependency information relation can take long time, search reduced set, considering numeric sample size attributes determinants: can see relation, many attributes, determined effect size ID number, es_id. contains numeric measurements, expected relation lowest level hierarchy. also expected, foreign key reference relation study-level information, determined study ID number, study_id. However, publication-level relation refers determined publication ID, publication_id, expect; neither determined publication reference. Instead, solely determined publication’s title: use ID, need supplement information, like publication year, choices come middle column relations, look likely spurious. suggests publication ID numbers erroneously assigned several publications, can easily test: ’d also expect reference determine publication, also case: needs additional information, binary_outcome. means publications share reference: BETA Behavioural Economics Team Australian Government, ’s surprising ’d multiple publications/reports per year. Duplicate references necessarily error, awkward references used. , clearly spurious, relations involving reference. One combines type_experiment determine location. Since reference publication-level attribute, location study-level attribute, can’t right. (far ’m aware, publication ID reference errors mentioned affected meta-analysis results.)","code":"nudge_deps <- discover(   nudge,   exclude = c(\"n_study\", \"n_comparison\", \"n_control\", \"n_intervention\"),   exclude_class = \"numeric\" ) nudge_schema <- normalise(nudge_deps, remove_avoidable = TRUE) show(nudge_schema) nudge_database <- decompose(nudge, nudge_schema) nudge_title_relation <- records(nudge_database)$title nudge_pid_duplicates <- unique(nudge_title_relation$publication_id[   duplicated(nudge_title_relation$publication_id) ]) knitr::kable(subset(nudge_title_relation, publication_id %in% nudge_pid_duplicates)) nudge_reference_duplicates <- unique(nudge_title_relation$reference[   duplicated(nudge_title_relation$reference) ]) knitr::kable(subset(nudge_title_relation, reference %in% nudge_reference_duplicates))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"removing-spurious-structure","dir":"Articles","previous_headings":"A larger example","what":"Removing spurious structure","title":"Using autodb","text":"publication ID reference clearly issues, need decide . , ’ll show usually correct approach, remove spurious functional dependencies. ’ll look options later. better option remove functional dependencies ’d consider spurious: publication ID reference part multiple-attribute determinant set, determinant set isn’t just two: now, finally, study location non-spurious relation. want , also add dependencies fail find, due excluding sample size attributes determinant sets: new schema confirms might expect, total sample size, sizes control treatment arms, two degrees freedom: knowing two determines . ’d expect total sample size sum two. However, functional dependency can’t determine . Indeed, check specific condition, find doesn’t hold: Looking paper, arm sample sizes aren’t given explicitly, numbers consistent parts study two treatments. Automatic search functional dependencies check domain-specific constraints like summation constraint , can give schemas suggest constraints check , two-degrees relation . Going back final database schema, removing dependencies revealed extra information study locations, via new title_type_experiment relation: studies experiment type publication always location. Looking resulting database shows removes many entries redundant location information kept study relation: dependency expect hold data collected, ’s reasonable dependency given data set, won’t added .","code":"nudge_deps_filtered <- nudge_deps[   lengths(detset(nudge_deps)) == 1 |     vapply(       detset(nudge_deps),       \\(ds) length(setdiff(ds, c(\"publication_id\", \"reference\"))) != 1,       logical(1)     ) ] nudge_schema_filtered <- normalise(nudge_deps_filtered, remove_avoidable = TRUE) show(nudge_schema_filtered) nudge_deps_size <- discover(nudge[, startsWith(names(nudge), \"n_\")]) nudge_deps_size #> 3 functional dependencies #> 4 attributes: n_study, n_comparison, n_control, n_intervention #>    n_control, n_intervention -> n_comparison #> n_comparison, n_intervention -> n_control #>      n_comparison, n_control -> n_intervention nudge_deps_final <- c(nudge_deps_filtered, nudge_deps_size) nudge_schema_final <- normalise(nudge_deps_final, remove_avoidable = TRUE) nudge_database_final <- decompose(nudge, nudge_schema_final) show(nudge_schema_final) knitr::kable(unique(subset(   nudge,   n_comparison != n_control + n_intervention,   c(     es_id,     reference,     title,     n_study,     n_comparison,     n_control,     n_intervention   ) ))) show(nudge_database_final)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"how-not-to-remove-spurious-structure","dir":"Articles","previous_headings":"A larger example","what":"How not to remove spurious structure","title":"Using autodb","text":"additional relation mentioned end previous section also notable ’ll now discuss: alternative ways get rid spurious structure. can ? Remove offending functional dependencies, re-schema creation (proper method); Remove offending attributes table – e.g. publication_id , since doesn’t intended job unique publication identification – re-entire process (re-running discover can expensive; don’t always want throw everything attribute, e.g. reference -> year, title -> reference); Add offending attributes exclude, disallow determinant sets, re-entire process (issues , except keep title -> reference, since excluded reference can still dependant); Remove offending schemas database schema / database (see ). happens remove offending schemas? Subsetting database schema also removes foreign key references involving removed schemas, resulting schema still valid. However, foreign key reference chains removed schemas middle broken. Amongst others, case lose reference three relations three hierarchical data levels: Re-running autoref effect, es_id section doesn’t contain key title section: database subschema including es_id relation publication_id distinguishing publications, effect sizes two publications ID uniquely associated publication: removing schemas irreversibly separates two parts database schema. Furthermore, compared nudge_schema_filtered, relation schema missing: directly removing schemas loses structure information results title_type_experiment relation. happen? relation isn’t present original schema, nudge_schema_filtered, full set functional dependencies make implied dependency transitive. Specifically, nudge_fds contains following functional dependencies: first two dependencies make third transitive, ’s ignored constructing relation schemas: ’s implied, enforced, title reference_type_experiment relation schemas. However, reference, type_experiment -> location removed spurious, title, type_experiment -> location longer transitive, now appears relation schema. instead remove reference_type_experiment schema, implicitly also throws away title, type_experiment -> location dependency co-implies. throw away non-spurious information don’t intend . risk irreversibly breaking database schema’s structure, risk unintentionally removing additional structure information, hope ’s clear directly removing relations avoided.","code":"nudge_schema_relfiltered <- nudge_schema[   !grepl(\"publication_id_\", names(nudge_schema), fixed = TRUE) &     !grepl(\"_publication_id\", names(nudge_schema), fixed = TRUE) &     !grepl(\"reference_\", names(nudge_schema), fixed = TRUE) &     !grepl(\"_reference\", names(nudge_schema), fixed = TRUE) ] show(nudge_schema_relfiltered) identical(autoref(nudge_schema_relfiltered), nudge_schema_relfiltered) #> [1] TRUE example_fds <- functional_dependency(   list(     list(\"title\", \"reference\"),     list(c(\"reference\", \"type_experiment\"), \"location\"),     list(c(\"title\", \"type_experiment\"), \"location\")   ),   c(\"title\", \"reference\", \"type_experiment\", \"location\") ) example_fds #> 3 functional dependencies #> 4 attributes: title, reference, type_experiment, location #>                      title -> reference #> reference, type_experiment -> location #>     title, type_experiment -> location show(normalise(example_fds, ensure_lossless = FALSE)) show(normalise(example_fds[-2], ensure_lossless = FALSE))"},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"approximate-dependencies-and-database-reduction","dir":"Articles","previous_headings":"Other features","what":"Approximate dependencies and database reduction","title":"Using autodb","text":"Larger datasets can often entry errors, without easy way remove deal . reason, might interested “approximate” functional dependencies, hold removing bounded amount violating records. Suppose normalise nudge , without manual dependency removal, allowing approximate dependencies. cheat, knowing questionable data example found showed two questionable records: one duplicated publication ID, one duplicated reference. Since nudge 447 records, can get rid resulting questionable dependencies setting accuracy allow two discrepant records. accuracy argument discover expects number zero one, determining proportion data frame’s records need satisfy given dependency algorithm consider valid. default, ’s equal one, exact dependencies returned. set less one, need use slower DFD search algorithm, since approximate dependency search implemented default FDHitsSep algorithm. Currently decompose doesn’t account approximate dependencies, resulting invalid databases, just work database schema. Compare database schema arrived manually: publication ID, title, reference considered equivalent, ’d originally expected. additional relation, showing approximation approximately determined publication- study-level attributes, rather functionally determined effect-size level. Lowering accuracy results dependencies found, relations. number relations can get large. example, suppose instead set accuracy 0.99, returning approximate dependencies hold least 443 records. little overwhelming, ’ll use utility function called reduce. returns named “main” relation, relations descendant via foreign key references. Reducing approximate schema, effect size table main table, gives us set relations: Questionable intermediate relations aside, can see now publication-level relation publication ID key, since determines publication attributes remove one duplicate records discovered . reduce can also used databases, considers relation largest number records main table. needs used caution: relations removes often spurious, ’s possible find databases relations linked main relation foreign key references required rejoin original data frame, reduction can remove necessary relations. intent mostly make glancing database plots manageable.","code":"nudge_approx_cheat_database_schema <- discover(   nudge,   accuracy = 1 - 2/nrow(nudge),   method = \"DFD\",   exclude = c(\"n_study\", \"n_comparison\", \"n_control\", \"n_intervention\"),   exclude_class = \"numeric\" ) |>   normalise() show(nudge_approx_cheat_database_schema) nudge_approx_database_schema <- discover(   nudge,   accuracy = 0.99,   method = \"DFD\",   exclude = c(\"n_study\", \"n_comparison\", \"n_control\", \"n_intervention\"),   exclude_class = \"numeric\" ) |>   normalise() show(nudge_approx_database_schema) show(reduce(nudge_approx_database_schema, \"es_id\"))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"avoidable-attributes","dir":"Articles","previous_headings":"Other features","what":"Avoidable attributes","title":"Using autodb","text":"next normal form third normal form (3NF) Boyes-Codd normal form (BCNF). Ensuring BCNF enforced database trickier, cases can’t enforced just relations foreign key constraints. However, package includes option convert enhanced third normal form, also known LTK form, can enforced. enhancement tangential BCNF, also used enhance schemas BCNF. brief, standard normal forms put constraints attributes present relations one relation time. enhancement constraint attributes present relation, considering presence relations. attribute relation can removed, still determined relation joining others, attribute “avoidable”, can removed. attribute relation’s keys, ’ll replaced keys use attributes removed. removes attributes relations without removing information database whole. example, can take simple example Chapter 6 Theory Relational Databases, David Maier: Attributes B equivalent, since relation key. words, relation simple lookup relation. , remove B relation A_C, replace key B, D , D, equivalent accounting relation . can removal avoidable attributes done automatically, using remove_avoidable flag normalise: schema now LTK form, remaining avoidable attributes. also removed relation A_C instead B, process may unique result. package’s implementation prefers remove attributes appear later original relation.","code":"avoid_deps <- functional_dependency(   list(     list(\"A\", \"B\"),     list(\"B\", \"A\"),     list(c(\"A\", \"C\"), \"D\"),     list(c(\"A\", \"C\"), \"E\"),     list(c(\"B\", \"D\"), \"C\")   ),   attrs_order = c(\"A\", \"B\", \"C\", \"D\", \"E\") ) avoid_deps #> 5 functional dependencies #> 5 attributes: A, B, C, D, E #>    A -> B #>    B -> A #> A, C -> D #> A, C -> E #> B, D -> C avoid_schema <- normalise(avoid_deps) show(avoid_schema) avoid_schema_removed <- normalise(   avoid_deps,   remove_avoidable = TRUE ) show(avoid_schema_removed)"},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"structure-conditional-on-value-missingness","dir":"Articles","previous_headings":"Handling some special cases","what":"Structure conditional on value missingness","title":"Using autodb","text":"Sometimes, structure attributes depends whether attributes missing. two possible reasons: piece information record takes one several possible formats, may different data classes. leaves single piece information spread across multiple sets attributes, necessarily disjoint, one set non-missing per record. general programming, referred union type. relational theory, called disjunctive existence union. set attributes missing non-missing together. general programming, attributes together represent option type, nullable class. example, commonly get data sets certain values can given either single values, endpoints interval, “union type” data spread across several attributes: autodb way know relationships, doesn’t treat missing values special case (see “Missing values” section “Planned extensions” ). resulting schema ignores : However, looking data , can see clearly-implied structure: record either perfectly-known value, distribution value . two options separate attributes. Distribution information contains lower upper bound, distribution type. Different distributions different numbers distribution parameters, given shared parameter attributes. Parameter attributes ordered: value can non-missing previous parameter values non-missing. general hack finding sorts relationships, like taking attribute missing values, adding companion attribute states whether value present missing: always practical, adding columns rapidly increases running time dependency search. However, ’s practical, helps make structure apparent database schema: shows values, bounds, interval distributions inform presence : drive main union type. can also see interval distribution determines many parameters required: ’s clearly additional structure , since ’s existence constraint: param2 present, param1 must also present. notice situation like , can attempt investigation splitting data, passing part autodb separately: case, constraint reflected first subset, param1 absent, always param2 absent, indicated param2_present param2 constant: Since data splitting currently manual process, practical limits far can take .","code":"df_options <- data.frame(   id = 1:20,   value = c(2.3, 2.3, 5.7, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),   lower_bound = c(NA_real_, NA_real_, NA_real_, 2.4, 0, 1, 0, 5.6, 2.4, 5.3, 5.3, 2.4, 2.4, 2.4, 2.4, 2.4, 2.4, 2.4, 5.6, 2.4),   upper_bound = c(NA_real_, NA_real_, NA_real_, 7.1, 10, 10, 13.1, 25.8, 10, 13.1, 10, 25.8, 25.8, 25.8, 25.8,13.1, 13.1, 25.8, 25.8, 25.8),   interval_distribution = c(NA, NA, NA, \"uniform\", \"uniform\", \"uniform\", \"uniform\", \"uniform\", \"Beta\", \"Beta\", \"Beta\", \"Beta\", \"Kumaraswamy\", \"Kumaraswamy\", \"Kumaraswamy\", \"Kumaraswamy\", \"PERT\", \"PERT\", \"PERT\", \"PERT\"),   param1 = c(NA, NA, NA, NA, NA, NA, NA, NA, 1, 1, 1, 2, 2, 2.1, 2, 2, 2, 1, 2, 2),   param2 = c(NA, NA, NA, NA, NA, NA, NA, NA, 1, 2, 2, 2, 2, 1, 1, 1, NA, NA, NA, NA) ) df_options$interval_distribution <- factor(df_options$interval_distribution) knitr::kable(df_options) db_options <- autodb(df_options) show(db_options) df_options_with_presence <- data.frame(   id = df_options$id,   value = df_options$value,   value_present = !is.na(df_options$value),   lower_bound = df_options$lower_bound,   lower_bound_present = !is.na(df_options$lower_bound),   upper_bound = df_options$upper_bound,   upper_bound_present = !is.na(df_options$upper_bound),   interval_distribution = df_options$interval_distribution,   interval_distribution_present = !is.na(df_options$interval_distribution),   param1 = df_options$param1,   param1_present = !is.na(df_options$param1),   param2 = df_options$param2,   param2_present = !is.na(df_options$param2) ) db_options_with_presence <- autodb(df_options_with_presence) show(db_options_with_presence) knitr::kable(records(db_options_with_presence)$value_present) knitr::kable(records(db_options_with_presence)$interval_distribution) db_options_with_presence_p1absent <- autodb(subset(   df_options_with_presence,   !param1_present )) show(db_options_with_presence_p1absent) show(autodb(subset(   df_options_with_presence,   param1_present ))) knitr::kable(records(db_options_with_presence_p1absent)$constants)"},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"handling-of-duplicate-records","dir":"Articles","previous_headings":"Planned extensions","what":"Handling of duplicate records","title":"Using autodb","text":"’s expected R user might pass data frame package duplicate records. moment, kept searching dependencies. can affect results approximate dependencies, due affecting record counts. However, removed data frame decomposed database. moment, ’m certain whether best handled removing , simply returning error duplicate records.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"missing-values","dir":"Articles","previous_headings":"Planned extensions","what":"Missing values","title":"Using autodb","text":"Strictly speaking, autodb search functional dependencies, can’t account missing values. Instead, searches weaker variant, called literal functional dependency (LFD) literature. functional dependency X -> Y holds , two possible records whose values X equal, values Y also equal. requires attribute values take equality operator, == R. Additionally, must take binary logic: whether two values equal can true false, missing. disallows presence missing values (NA NaN), since testing equality missing value returns missing result. literal functional dependency X -> Y holds, functional dependency X -> Y holds literally, , two possible records whose values X identical, values Y also identical, values identical non-missing equal, missing. words, missing values treated equal non-missing values, equal . requires attribute classes take identity operator, identical() default optional parameter values R. , must take binary logic, identity operator return non-binary results anyway: R, example, identical() can return TRUE FALSE, never NA. , therefore, constraint missing values attribute classes, attribute classes general. LFDs generic standard functional dependencies: since practically every class takes identity operator, practically make assumptions attribute classes present data set. FD variants handle missing values, , unlike , LFDs still satisfy Armstrong’s axioms, allowing used normalisation way normal FDs. example, still respect transitivity: X -> Y Y -> Z literally, X -> Z literally. However, ignoring special status missing values way ignores important structural information. relational model, ideally relational databases, want missing values , partly avoid awkward questions trinary logic means respect filtering joining tables. example, take following data frame: autodb currently treats NA just another value, results initial data frame split database schema: case, missing death date represents death, prefer move death information separate relation, containing patients death date, case patient 3: makes data’s structure apparent, enforceable, database structure, since makes clear death date optional. Removing missing values way requires additional steps dependency detection, well normalisation, autodb currently : requires keeping additional information attributes missing, compared others.","code":"df_nas <- data.frame(   patient = c(1L, 2L, 3L, 4L),   trial_entry_date = as.Date(c(\"2022/05/02\", \"2022/06/06\", \"2022/04/01\", \"2022/03/19\")),   death_date = as.Date(c(NA, NA, \"2022/10/07\", NA)) ) knitr::kable(df_nas) show(autodb(df_nas)) ideal_db <- decompose(   df_nas,   database_schema(     relation_schema(       list(         patient = list(c(\"patient\", \"trial_entry_date\"), list(\"patient\")),         patient_death = list(c(\"patient\", \"death_date\"), list(\"patient\"))       ),       names(df_nas)     ),     list(list(\"patient_death\", \"patient\", \"patient\", \"patient\"))   ) ) records(ideal_db)$patient_death <- subset(records(ideal_db)$patient_death, !is.na(death_date)) show(ideal_db)"},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"table-merges-dont-fix-issues-with-merge-data-frame","dir":"Articles","previous_headings":"Limitations","what":"Table merges don’t fix issues with merge.data.frame","title":"Using autodb","text":"Rejoining databases, checking relations satisfy foreign key constraints, done using merge.data.frame. means data classes don’t work properly merge aren’t guaranteed work properly autodb. issues come certain data classes handled merges base language, issues R, rather autodb, plans fix . autodb seems odd failures, check used data classes behave correctly merges. example, older versions R, built-POSIXct date/time class didn’t values merged properly, merge didn’t account differences time zone / daylight saving time. result , example, nycflights13::weather data set violating foreign key constraints discovered schema, since one foreign key used POSIXct attribute. complex example, still applies probably always , merge two attributes merged different classes. general, allowed: since autodb written R, dynamically-typed language, follows SQLite constraining user much comes data classes schemas. primitive classes, R’s class coercion usually makes things work ’d expect. However, merging factor attribute non-factor, non-character attribute handled caution latter contains values factor’s level set. example, can define data frames: can merge data frame logical two, keeping row attributes track records merged. Whichever data frame merge , two sets values different classes, R coercion. merging just , gives result ’d expect, data frames regardless merge order. integer version, logical values coerced integers: factor version, logical values coerced factors, don’t match given levels, become NA: However, see unexpected behaviour factor version, also merging another attribute, b: merge result now depends input order. factor version first, result similar : logical version first, however, logical values NA coercion kept, rather : autodb, problem two relations foreign key constraint contain attribute, one store factors records, due separate insertions. Letting attribute’s class vary across relations , therefore, done caution.","code":"df_badmerge_int <- cbind(   expand.grid(     a = c(NA, 0L, 1L),     b = c(NA, FALSE, TRUE)   ),   row = 1:9 ) df_badmerge_factor <- df_badmerge_int df_badmerge_factor$a <- as.factor(df_badmerge_factor$a) knitr::kable(df_badmerge_int) df_badmerge_logical <- df_badmerge_int df_badmerge_logical$a <- as.logical(df_badmerge_logical$a) names(df_badmerge_logical)[[3]] <- \"row2\" knitr::kable(df_badmerge_logical) knitr::kable(merge(   df_badmerge_int[, c(\"a\", \"row\")],   df_badmerge_logical[, c(\"a\", \"row2\")] )) knitr::kable(merge(   df_badmerge_logical[, c(\"a\", \"row2\")],   df_badmerge_int[, c(\"a\", \"row\")] )) knitr::kable(merge(   df_badmerge_factor[, c(\"a\", \"row\")],   df_badmerge_logical[, c(\"a\", \"row2\")] )) knitr::kable(merge(   df_badmerge_logical[, c(\"a\", \"row2\")],   df_badmerge_factor[, c(\"a\", \"row\")] )) knitr::kable(merge(   df_badmerge_factor,   df_badmerge_logical )) #> Warning in `[<-.factor`(`*tmp*`, ri, value = c(NA, FALSE, TRUE, NA, FALSE, : #> invalid factor level, NA generated knitr::kable(merge(   df_badmerge_logical,   df_badmerge_factor ))"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"synthesis-doesnt-minimise-relation-key-count","dir":"Articles","previous_headings":"Limitations","what":"Synthesis doesn’t minimise relation key count","title":"Using autodb","text":"Bernstein’s synthesis guaranteed minimise number relations created given set functional dependencies, removing avoidable attributes can reduce number attributes relations. However, can still redundant keys. example, can take following set functional dependencies: Normalising gives following relations: relations redundancy: relation implies {b, d} -> c, relation d implies {d} -> c. isn’t resolved removing avoidable attributes, d still needs relation : just need remove {b, d} key. However, resolved instead use set functional dependencies, equivalent previous set: Unfortunately, ’s way package find better sets like .","code":"fds_redkey <- functional_dependency(   list(     list(\"a\", \"b\"),     list(\"d\", \"c\"),     list(c(\"b\", \"d\"), \"a\"),     list(\"a\", \"c\"),     list(c(\"b\", \"c\"), \"d\")   ),   letters[1:4] ) fds_redkey #> 5 functional dependencies #> 4 attributes: a, b, c, d #>    a -> b #>    d -> c #> b, d -> a #>    a -> c #> b, c -> d schema_redkey <- normalise(fds_redkey, remove_avoidable = TRUE) show(schema_redkey) fds_redkey_fix <- functional_dependency(   list(     list(\"a\", \"b\"),     list(\"d\", \"c\"),     list(c(\"b\", \"c\"), \"a\"),     list(\"a\", \"d\")   ),   letters[1:4] ) fds_redkey_fix #> 4 functional dependencies #> 4 attributes: a, b, c, d #>    a -> b #>    d -> c #> b, c -> a #>    a -> d schema_redkey_fix <- normalise(fds_redkey_fix, remove_avoidable = TRUE) show(schema_redkey_fix)"},{"path":"https://charnelmouse.github.io/autodb/dev/articles/autodb.html","id":"normalisation-isnt-all-there-is-to-database-design","dir":"Articles","previous_headings":"Limitations","what":"Normalisation isn’t all there is to database design","title":"Using autodb","text":"mentioned section avoidable attributes, normal forms refer one relation time: referring database following normal form just means relations follow . Even also add foreign key references normal forms don’t require, leaves room database schemas satisfy normal forms, wouldn’t want use. simple example, take database schema, whose relation schemas third normal form: now create copies relations, intention copies always contain data, relations still third normal form, ’d say database : However, one claim good database design, since clearly large amount data redundancy. Higher normal forms change .","code":"dup_db <- autodb(ChickWeight) show(dup_db) show(dup_db[c(1, 1, 2, 2, 2)])"},{"path":"https://charnelmouse.github.io/autodb/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mark Webster. Author, maintainer.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Webster M (2025). autodb: Automatic Database Normalisation Data Frames. R package version 2.3.1.9000, https://charnelmouse.github.io/autodb/.","code":"@Manual{,   title = {autodb: Automatic Database Normalisation for Data Frames},   author = {Mark Webster},   year = {2025},   note = {R package version 2.3.1.9000},   url = {https://charnelmouse.github.io/autodb/}, }"},{"path":"https://charnelmouse.github.io/autodb/dev/index.html","id":"autodb","dir":"","previous_headings":"","what":"Automatic Database Normalisation for Data Frames","title":"Automatic Database Normalisation for Data Frames","text":"autodb R package automatic normalisation data frame third normal form, intention easing process data cleaning. (Usage design actual database advised.)","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Automatic Database Normalisation for Data Frames","text":"Install stable released version CRAN : Install unstable development version GitHub :","code":"install.packages(\"autodb\") # install.packages(\"devtools\") devtools::install_github(\"CharnelMouse/autodb\")"},{"path":"https://charnelmouse.github.io/autodb/dev/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Automatic Database Normalisation for Data Frames","text":"Turning simple data frame database:  Using exclude argument forbid certain variables appearing keys:   also functions step database creation separately, including functional dependency detection normalisation. See vignette details.","code":"library(autodb) #>  #> Attaching package: 'autodb' #> The following object is masked from 'package:stats': #>  #>     decompose summary(ChickWeight) #>      weight           Time           Chick     Diet    #>  Min.   : 35.0   Min.   : 0.00   13     : 12   1:220   #>  1st Qu.: 63.0   1st Qu.: 4.00   9      : 12   2:120   #>  Median :103.0   Median :10.00   20     : 12   3:120   #>  Mean   :121.8   Mean   :10.72   10     : 12   4:118   #>  3rd Qu.:163.8   3rd Qu.:16.00   17     : 12           #>  Max.   :373.0   Max.   :21.00   19     : 12           #>                                  (Other):506 db <- autodb(ChickWeight) db #> database with 2 relations #> 4 attributes: weight, Time, Chick, Diet #> relation Chick: Chick, Diet; 50 records #>   key 1: Chick #> relation Time_Chick: Time, Chick, weight; 578 records #>   key 1: Time, Chick #> references: #> Time_Chick.{Chick} -> Chick.{Chick} graphviz_text <- gv(db) DiagrammeR::grViz(graphviz_text) summary(CO2) #>      Plant             Type         Treatment       conc          uptake      #>  Qn1    : 7   Quebec     :42   nonchilled:42   Min.   :  95   Min.   : 7.70   #>  Qn2    : 7   Mississippi:42   chilled   :42   1st Qu.: 175   1st Qu.:17.90   #>  Qn3    : 7                                    Median : 350   Median :28.30   #>  Qc1    : 7                                    Mean   : 435   Mean   :27.21   #>  Qc3    : 7                                    3rd Qu.: 675   3rd Qu.:37.12   #>  Qc2    : 7                                    Max.   :1000   Max.   :45.50   #>  (Other):42 db2_noexclude <- autodb(CO2) db2_noexclude #> database with 3 relations #> 5 attributes: Plant, Type, Treatment, conc, uptake #> relation Plant: Plant, Type, Treatment; 12 records #>   key 1: Plant #> relation Plant_conc: Plant, conc, Treatment, uptake; 84 records #>   key 1: Plant, conc #>   key 2: Treatment, conc, uptake #> relation conc_uptake: conc, uptake, Type; 82 records #>   key 1: conc, uptake #> references: #> Plant_conc.{Plant} -> Plant.{Plant} #> Plant_conc.{conc, uptake} -> conc_uptake.{conc, uptake} graphviz_text2_noexclude <- gv(db2_noexclude) DiagrammeR::grViz(graphviz_text2_noexclude) db2 <- autodb(CO2, exclude = \"uptake\") db2 #> database with 2 relations #> 5 attributes: Plant, Type, Treatment, conc, uptake #> relation Plant: Plant, Type, Treatment; 12 records #>   key 1: Plant #> relation Plant_conc: Plant, conc, uptake; 84 records #>   key 1: Plant, conc #> references: #> Plant_conc.{Plant} -> Plant.{Plant} graphviz_text2 <- gv(db2) DiagrammeR::grViz(graphviz_text2)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational data attributes — attrs","title":"Relational data attributes — attrs","text":"Generic function, fetching attribute sets elements relational object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational data attributes — attrs","text":"","code":"attrs(x, ...)  attrs(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational data attributes — attrs","text":"x relational schema object, relation_schema database_schema object, relational data object, relation database object. ... arguments passed methods. value character vector length attrs(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational data attributes — attrs","text":"list, containing character vector element x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational data attribute order — attrs_order","title":"Relational data attribute order — attrs_order","text":"Generic function, fetching attribute order relational objects.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational data attribute order — attrs_order","text":"","code":"attrs_order(x, ...)  attrs_order(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational data attribute order — attrs_order","text":"x R object, functional_dependency, relation_schema, relation, database_schema, database object. ... arguments passed methods. value character vector length attrs_order(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational data attribute order — attrs_order","text":"character vector, giving attributes order prioritised sorting within x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/attrs_order.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relational data attribute order — attrs_order","text":"classes autodb contain attrs_order attribute. gives easy way find list attributes/variables involved object, main purpose also assign attributes consistent order printing plotting object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Database-style normalisation for data.frames — autodb-package","title":"Database-style normalisation for data.frames — autodb-package","text":"Automatic normalisation data.frame third normal form, intention easing process data cleaning. (Usage design actual database advised.) Originally inspired Alteryx's AutoNormalize Python library (https://github.com/alteryx/autonormalize), various changes improvements. Automatic discovery functional approximate dependencies, normalisation based , plotting resulting \"database\" via Graphviz, options exclude attributes discovery time, remove discovered dependencies normalisation time.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Database-style normalisation for data.frames — autodb-package","text":"Maintainer: Mark Webster markwebster204@yahoo.co.uk (ORCID)","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a normalised database from a data frame — autodb","title":"Create a normalised database from a data frame — autodb","text":"wrapper function applying normalise, autoref, decompose. takes data frame converts straight database, main intended use case package.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a normalised database from a data frame — autodb","text":"","code":"autodb(   df,   digits = getOption(\"digits\"),   single_ref = FALSE,   ensure_lossless = TRUE,   remove_avoidable = FALSE,   constants_name = \"constants\",   progress = FALSE,   progress_file = \"\",   ... )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a normalised database from a data frame — autodb","text":"df data.frame, containing data normalised. digits positive integer, indicating many significant digits used numeric complex variables. used pre-formatting discover, rounding data use decompose, data satisfies resulting schema. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See \"Floating-point variables\" section discover rounding necessary consistent results across different machines. See note print.default digits >=   16. single_ref logical, FALSE default. TRUE, one reference relation pair kept generating foreign key references. pair multiple references, kept reference refers earliest key child relation, sorted priority order. ensure_lossless logical, indicating whether check whether normalisation lossless. , additional relation added final \"database\", containing key df. enough make normalisation lossless. remove_avoidable logical, indicating whether remove avoidable attributes relations. , attribute removed relations keys can changed needed preserve given functional dependencies. constants_name scalar character, giving name relation created store constant attributes. generated relation name, changed, warning, ensure relations unique name. progress logical, whether display progress user dependency search discover. progress_file scalar character connection. progress non-zero, determines progress written , way file argument cat. ... arguments passed discover.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a normalised database from a data frame — autodb","text":"database, containing data df within inferred database schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a normalised database from a data frame — autodb","text":"Since decompose works functional dependencies, approximate dependencies, accuracy discover fixed 1.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autodb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a normalised database from a data frame — autodb","text":"","code":"# simple example autodb(ChickWeight) #> database with 2 relations #> 4 attributes: weight, Time, Chick, Diet #> relation Chick: Chick, Diet; 50 records #>   key 1: Chick #> relation Time_Chick: Time, Chick, weight; 578 records #>   key 1: Time, Chick #> references: #> Time_Chick.{Chick} -> Chick.{Chick}"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":null,"dir":"Reference","previous_headings":"","what":"Add foreign key references to a normalised database — autoref","title":"Add foreign key references to a normalised database — autoref","text":"Adds foreign key references relation_schema object automatically, replacing existing references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add foreign key references to a normalised database — autoref","text":"","code":"autoref(schema, single_ref = FALSE)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add foreign key references to a normalised database — autoref","text":"schema relation_schema object, given synthesise. single_ref logical, FALSE default. TRUE, one reference relation pair kept generating foreign key references. pair multiple references, kept reference refers earliest key child relation, sorted priority order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add foreign key references to a normalised database — autoref","text":"database_schema object, containing given relation schemas created foreign key references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add foreign key references to a normalised database — autoref","text":"method generating references simple. First, finds every link two relation schemas, parent contains attributes one child's keys. can done separately child's keys, can multiple links parent child single_ref TRUE. Second, transitive references removed: link relation pairs -> b, b -> c, -> c, latter transitive, removed. cyclic reference, e.g. c -> , choice link remove arbitrary. Cycles occur sets relation schemas resulting decomposing single table.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/autoref.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add foreign key references to a normalised database — autoref","text":"","code":"rs <- relation_schema(   list(     a_b_c = list(c(\"a\", \"b\", \"c\", \"d\"), list(c(\"a\", \"b\", \"c\"))),     a_b = list(c(\"a\", \"b\", \"d\"), list(c(\"a\", \"b\"), c(\"b\", \"d\")))   ),   letters[1:4] ) autoref(rs, single_ref = FALSE) #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a_b_c: a, b, c, d #>   key 1: a, b, c #> schema a_b: a, b, d #>   key 1: a, b #>   key 2: b, d #> references: #> a_b_c.{a, b} -> a_b.{a, b} #> a_b_c.{b, d} -> a_b.{b, d} autoref(rs, single_ref = TRUE) #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a_b_c: a, b, c, d #>   key 1: a, b, c #> schema a_b: a, b, d #>   key 1: a, b #>   key 2: b, d #> references: #> a_b_c.{a, b} -> a_b.{a, b}"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create instance of a schema — create","title":"Create instance of a schema — create","text":"Create relation data object, using given relational schema object, resulting relations empty ready data insertion using insert.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create instance of a schema — create","text":"","code":"create(x, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create instance of a schema — create","text":"x relational schema object, representing schema create instance , relation_schema database_schema object. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create instance of a schema — create","text":"instance schema. example, calling create database_schema creates database, relations contain zero records.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":null,"dir":"Reference","previous_headings":"","what":"Databases — database","title":"Databases — database","text":"Enhances relation object foreign key reference information.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Databases — database","text":"","code":"database(relations, references)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Databases — database","text":"relations relation object. references list references, represented list containing four character elements. order, elements scalar giving name child (referrer) schema, vector giving child attribute names, scalar giving name parent (referee) schema, vector giving parent attribute names. vectors must length contain names attributes present respective schemas, parent attributes must form key.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Databases — database","text":"database object, containing relations references stored attribute name. References stored attributes order appear respective relations.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Databases — database","text":"Unlike relation_schema relation, like database_schema, database designed vector-like: holds single database. adheres usual package use case, single data frame analysed time. However, inherits relation, vectorised respect relations. relation, duplicate relations, ordering attribute, allowed, can removed unique. References, .e. foreign key references, allowed different attribute names child parent relations; occur output autoref normalise. Subsetting removes references involve removed relations. Removing duplicates unique changes references involving duplicates involve kept equivalent relations instead. Renaming relations names<- also changes names references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Databases — database","text":"","code":"rels <- relation(   list(     a = list(       df = data.frame(a = logical(), b = logical()),       keys = list(\"a\")     ),     b = list(       df = data.frame(b = logical(), c = logical()),       keys = list(\"b\", \"c\")     )   ),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) db <- database(   rels,   list(list(\"a\", \"b\", \"b\", \"b\")) ) print(db) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} attrs(db) #> $a #> [1] \"a\" \"b\" #>  #> $b #> [1] \"b\" \"c\" #>  stopifnot(identical(   attrs(db),   lapply(records(db), names) )) keys(db) #> $a #> $a[[1]] #> [1] \"a\" #>  #>  #> $b #> $b[[1]] #> [1] \"b\" #>  #> $b[[2]] #> [1] \"c\" #>  #>  attrs_order(db) #> [1] \"a\" \"b\" \"c\" \"d\" names(db) #> [1] \"a\" \"b\" references(db) #> [[1]] #> [[1]][[1]] #> [1] \"a\" #>  #> [[1]][[2]] #> [1] \"b\" #>  #> [[1]][[3]] #> [1] \"b\" #>  #> [[1]][[4]] #> [1] \"b\" #>  #>   # relations can't reference themselves if (FALSE) { # \\dontrun{   database(     relation(       list(a = list(df = data.frame(a = 1:5), keys = list(\"a\"))),       c(\"a\", \"b\")     ),     list(list(\"a\", \"a\", \"a\", \"a\"))   )   database(     relation(       list(a = list(df = data.frame(a = 1:5, b = 6:10), keys = list(\"a\"))),       c(\"a\", \"b\")     ),     list(list(\"a\", \"b\", \"a\", \"a\"))   ) } # }  # an example with references between differently-named attributes print(database(   relation(     list(       citation = list(df = data.frame(citer = 1:5, citee = 6:10), keys = list(c(\"citer\", \"citee\"))),       article = list(df = data.frame(article = 1:10), keys = list(\"article\"))     ),     c(\"citer\", \"citee\", \"article\")   ),   list(     list(\"citation\", \"citer\", \"article\", \"article\"),     list(\"citation\", \"citee\", \"article\", \"article\")   ) )) #> database with 2 relations #> 3 attributes: citer, citee, article #> relation citation: citer, citee; 5 records #>   key 1: citer, citee #> relation article: article; 10 records #>   key 1: article #> references: #> citation.{citer} -> article.{article} #> citation.{citee} -> article.{article}  # inserting data insert(db, data.frame(a = 1L, b = 2L, c = 3L, d = 4L)) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} # data is only inserted into relations where all columns are given... insert(db, data.frame(a = 1L, b = 2L, c = 3L)) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} # and that are listed in relations argument insert(   db,   data.frame(a = 1L, b = 2L, c = 3L, d = 4L),   relations = \"b\" ) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} # inserted data can't violate keys if (FALSE) { # \\dontrun{   insert(     db,     data.frame(a = 1L, b = 1:2)   ) } # } # inserted data can't violate foreign key references if (FALSE) { # \\dontrun{   insert(     db,     data.frame(a = 1L, b = 2L, c = 3L, d = 4L),     relations = \"a\"   ) } # }  # vector operations db2 <- database(   relation(     list(       e = list(df = data.frame(a = 1:5, e = 6:10), keys = list(\"e\"))     ),     attrs_order = c(\"a\", \"e\")   ),   list() ) c(db, db2) # attrs_order attributes are merged #> database with 3 relations #> 5 attributes: a, b, c, d, e #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation e: e, a; 5 records #>   key 1: e #> references: #> a.{b} -> b.{b} unique(c(db, db)) #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b}  # subsetting db[1] #> database with 1 relation #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> no references stopifnot(identical(db[[1]], db[1])) db[c(1, 2, 1, 2)] # replicates the foreign key references #> database with 4 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation a.1: a, b; 0 records #>   key 1: a #> relation b.1: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} #> a.{b} -> b.1.{b} #> a.1.{b} -> b.{b} #> a.1.{b} -> b.1.{b} c(db[c(1, 2)], db[c(1, 2)]) # doesn't reference between separate copies of db #> database with 4 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation a.1: a, b; 0 records #>   key 1: a #> relation b.1: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} #> a.1.{b} -> b.1.{b} unique(db[c(1, 2, 1, 2)]) # unique() also merges references #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b}  # another example of unique() merging references db_merge <- database(   relation(     list(       a = list(         df = data.frame(a = logical(), b = logical()),         keys = list(\"a\")       ),       b = list(         df = data.frame(b = logical(), c = logical(), d = logical()),         keys = list(\"b\")       ),       c_d = list(         df = data.frame(c = logical(), d = logical(), e = logical()),         keys = list(c(\"c\", \"d\"))       ),       a.1 = list(         df = data.frame(a = logical(), b = logical()),         keys = list(\"a\")       ),       b.1 = list(         df = data.frame(b = logical(), c = logical(), d = logical()),         keys = list(\"b\")       )     ),     c(\"a\", \"b\", \"c\", \"d\", \"e\")   ),   list(     list(\"a\", \"b\", \"b\", \"b\"),     list(\"b.1\", c(\"c\", \"d\"), \"c_d\", c(\"c\", \"d\"))   ) ) print(db_merge) #> database with 5 relations #> 5 attributes: a, b, c, d, e #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c, d; 0 records #>   key 1: b #> relation c_d: c, d, e; 0 records #>   key 1: c, d #> relation a.1: a, b; 0 records #>   key 1: a #> relation b.1: b, c, d; 0 records #>   key 1: b #> references: #> a.{b} -> b.{b} #> b.1.{c, d} -> c_d.{c, d} unique(db_merge) #> database with 3 relations #> 5 attributes: a, b, c, d, e #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c, d; 0 records #>   key 1: b #> relation c_d: c, d, e; 0 records #>   key 1: c, d #> references: #> a.{b} -> b.{b} #> b.{c, d} -> c_d.{c, d}  # reassignment # can't change keys included in references if (FALSE) keys(db)[[2]] <- list(\"c\") # \\dontrun{} # can't remove attributes included in keys if (FALSE) attrs(db)[[2]] <- list(\"c\", \"d\") # \\dontrun{} # can't remove attributes included in references if (FALSE) attrs(db)[[1]] <- c(\"a\", \"d\") # \\dontrun{} db3 <- db # can change subset of schema, but loses references between altered and # non-altered subsets db3[2] <- database(   relation(     list(d = list(df = data.frame(d = logical(), c = logical()), keys = list(\"d\"))),     attrs_order(db3)   ),   list() ) print(db3) # note the schema's name doesn't change #> database with 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: d, c; 0 records #>   key 1: d #> no references # names(db3)[2] <- \"d\" # this would change the name keys(db3)[[2]] <- list(character()) # removing keys first... # for a database_schema, we could then change the attrs for # the second database. For a created relation, this is not # allowed. if (FALSE) { # \\dontrun{   attrs(db3)[[2]] <- c(\"b\", \"c\")   names(records(db3)[[2]]) <- c(\"b\", \"c\") } # }  # changing appearance priority for attributes attrs_order(db3) <- c(\"d\", \"c\", \"b\", \"a\") print(db3) #> database with 2 relations #> 4 attributes: d, c, b, a #> relation a: a, b; 0 records #>   key 1: a #> relation b: d, c; 0 records #>   key 1:  #> no references  # changing relation schema names changes them in references names(db3) <- paste0(names(db3), \"_long\") print(db3) #> database with 2 relations #> 4 attributes: d, c, b, a #> relation a_long: a, b; 0 records #>   key 1: a #> relation b_long: d, c; 0 records #>   key 1:  #> no references  # reconstructing from components db_recon <- database(   relation(     Map(list, df = records(db), keys = keys(db)),     attrs_order(db)   ),   references(db) ) stopifnot(identical(db_recon, db)) db_recon2 <- database(   subrelations(db),   references(db) ) stopifnot(identical(db_recon2, db))  # can be a data frame column data.frame(id = 1:2, relation = db) #>   id               relation #> 1  1 relation a (0 records) #> 2  2 relation b (0 records)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Database schemas — database_schema","title":"Database schemas — database_schema","text":"Enhances relation_schema object foreign key reference information.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Database schemas — database_schema","text":"","code":"database_schema(relation_schemas, references)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Database schemas — database_schema","text":"relation_schemas relation_schema object, returned synthesise relation_schema. references list references, represented list containing four character elements. order, elements scalar giving name child (referrer) schema, vector giving child attribute names, scalar giving name parent (referee) schema, vector giving parent attribute names. vectors must length contain names attributes present respective schemas, parent attributes must form key.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Database schemas — database_schema","text":"database_schema object, containing relation_schemas references stored attribute name. References stored attributes order appear respective relation schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Database schemas — database_schema","text":"Unlike functional_dependency relation_schema, database_schema designed vector-like: holds single database schema. adheres usual package use case, single data frame analysed time. However, inherits relation_schema, vectorised respect relation schemas. relation_schema, duplicate relation schemas, ordering attribute, allowed, can removed unique. References, .e. foreign key references, allowed different attribute names child parent relations; occur output autoref normalise. Subsetting removes references involve removed relation schemas. Removing duplicates unique changes references involving duplicates involve kept equivalent schemas instead. Renaming relation schemas names<- also changes names references.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/database_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Database schemas — database_schema","text":"","code":"rs <- relation_schema(   list(     a = list(c(\"a\", \"b\"), list(\"a\")),     b = list(c(\"b\", \"c\"), list(\"b\", \"c\"))   ),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) ds <- database_schema(   rs,   list(list(\"a\", \"b\", \"b\", \"b\")) ) print(ds) #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} attrs(ds) #> $a #> [1] \"a\" \"b\" #>  #> $b #> [1] \"b\" \"c\" #>  keys(ds) #> $a #> $a[[1]] #> [1] \"a\" #>  #>  #> $b #> $b[[1]] #> [1] \"b\" #>  #> $b[[2]] #> [1] \"c\" #>  #>  attrs_order(ds) #> [1] \"a\" \"b\" \"c\" \"d\" names(ds) #> [1] \"a\" \"b\" references(ds) #> [[1]] #> [[1]][[1]] #> [1] \"a\" #>  #> [[1]][[2]] #> [1] \"b\" #>  #> [[1]][[3]] #> [1] \"b\" #>  #> [[1]][[4]] #> [1] \"b\" #>  #>   # relations can't reference themselves if (FALSE) { # \\dontrun{   database_schema(     relation_schema(       list(a = list(\"a\", list(\"a\"))),       c(\"a\", \"b\")     ),     list(list(\"a\", \"a\", \"a\", \"a\"))   )   database_schema(     relation_schema(       list(a = list(c(\"a\", \"b\"), list(\"a\"))),       c(\"a\", \"b\")     ),     list(list(\"a\", \"b\", \"a\", \"a\"))   ) } # }  # an example with references between differently-named attributes print(database_schema(   relation_schema(     list(       citation = list(c(\"citer\", \"citee\"), list(c(\"citer\", \"citee\"))),       article = list(\"article\", list(\"article\"))     ),     c(\"citer\", \"citee\", \"article\")   ),   list(     list(\"citation\", \"citer\", \"article\", \"article\"),     list(\"citation\", \"citee\", \"article\", \"article\")   ) )) #> database schema with 2 relation schemas #> 3 attributes: citer, citee, article #> schema citation: citer, citee #>   key 1: citer, citee #> schema article: article #>   key 1: article #> references: #> citation.{citer} -> article.{article} #> citation.{citee} -> article.{article}  # vector operations ds2 <- database_schema(   relation_schema(     list(       e = list(c(\"a\", \"e\"), list(\"e\"))     ),     attrs_order = c(\"a\", \"e\")   ),   list() ) c(ds, ds2) # attrs_order attributes are merged #> database schema with 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema e: e, a #>   key 1: e #> references: #> a.{b} -> b.{b} unique(c(ds, ds)) #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b}  # subsetting ds[1] #> database schema with 1 relation schema #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> no references stopifnot(identical(ds[[1]], ds[1])) ds[c(1, 2, 1, 2)] # replicates the foreign key references #> database schema with 4 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema a.1: a, b #>   key 1: a #> schema b.1: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} #> a.{b} -> b.1.{b} #> a.1.{b} -> b.{b} #> a.1.{b} -> b.1.{b} c(ds[c(1, 2)], ds[c(1, 2)]) # doesn't reference between separate copies of ds #> database schema with 4 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema a.1: a, b #>   key 1: a #> schema b.1: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b} #> a.1.{b} -> b.1.{b} unique(ds[c(1, 2, 1, 2)]) # unique() also merges references #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> references: #> a.{b} -> b.{b}  # another example of unique() merging references ds_merge <- database_schema(   relation_schema(     list(       a = list(c(\"a\", \"b\"), list(\"a\")),       b = list(c(\"b\", \"c\", \"d\"), list(\"b\")),       c_d = list(c(\"c\", \"d\", \"e\"), list(c(\"c\", \"d\"))),       a.1 = list(c(\"a\", \"b\"), list(\"a\")),       b.1 = list(c(\"b\", \"c\", \"d\"), list(\"b\"))     ),     c(\"a\", \"b\", \"c\", \"d\", \"e\")   ),   list(     list(\"a\", \"b\", \"b\", \"b\"),     list(\"b.1\", c(\"c\", \"d\"), \"c_d\", c(\"c\", \"d\"))   ) ) print(ds_merge) #> database schema with 5 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c, d #>   key 1: b #> schema c_d: c, d, e #>   key 1: c, d #> schema a.1: a, b #>   key 1: a #> schema b.1: b, c, d #>   key 1: b #> references: #> a.{b} -> b.{b} #> b.1.{c, d} -> c_d.{c, d} unique(ds_merge) #> database schema with 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c, d #>   key 1: b #> schema c_d: c, d, e #>   key 1: c, d #> references: #> a.{b} -> b.{b} #> b.{c, d} -> c_d.{c, d}  # reassignment # can't change keys included in references if (FALSE) keys(ds)[[2]] <- list(\"c\") # \\dontrun{} # can't remove attributes included in keys if (FALSE) attrs(ds)[[2]] <- list(\"c\", \"d\") # \\dontrun{} # can't remove attributes included in references if (FALSE) attrs(ds)[[1]] <- c(\"a\", \"d\") # \\dontrun{} ds3 <- ds # can change subset of schema, but loses references between altered and # non-altered subsets ds3[2] <- database_schema(   relation_schema(     list(d = list(c(\"d\", \"c\"), list(\"d\"))),     attrs_order(ds3)   ),   list() ) print(ds3) # note the schema's name doesn't change #> database schema with 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: d, c #>   key 1: d #> no references # names(ds3)[2] <- \"d\" # this would change the name keys(ds3)[[2]] <- list(character()) # removing keys first... attrs(ds3)[[2]] <- c(\"b\", \"c\") # so we can change the attrs legally keys(ds3)[[2]] <- list(\"b\", \"c\") # add the new keys # add the reference lost during subset replacement references(ds3) <- c(references(ds3), list(list(\"a\", \"b\", \"b\", \"b\"))) stopifnot(identical(ds3, ds))  # changing appearance priority for attributes attrs_order(ds3) <- c(\"d\", \"c\", \"b\", \"a\") print(ds3) #> database schema with 2 relation schemas #> 4 attributes: d, c, b, a #> schema a: a, b #>   key 1: a #> schema b: c, b #>   key 1: c #>   key 2: b #> references: #> a.{b} -> b.{b}  # changing relation schema names changes them in references names(ds3) <- paste0(names(ds3), \"_long\") print(ds3) #> database schema with 2 relation schemas #> 4 attributes: d, c, b, a #> schema a_long: a, b #>   key 1: a #> schema b_long: c, b #>   key 1: c #>   key 2: b #> references: #> a_long.{b} -> b_long.{b}  # reconstructing from components ds_recon <- database_schema(   relation_schema(     Map(list, attrs(ds), keys(ds)),     attrs_order(ds)   ),   references(ds) ) stopifnot(identical(ds_recon, ds)) ds_recon2 <- database_schema(   subschemas(ds),   references(ds) ) stopifnot(identical(ds_recon2, ds))  # can be a data frame column data.frame(id = 1:2, schema = ds) #>   id   schema #> 1  1 schema a #> 2  2 schema b"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":null,"dir":"Reference","previous_headings":"","what":"Decompose a data frame based on given normalised dependencies — decompose","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"Decomposes data frame several relations, based given database schema. intended data frame satisfies functional dependencies implied schema, schema constructed data frame. case, function returns error.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"","code":"decompose(df, schema, digits = getOption(\"digits\"), check = TRUE)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"df data.frame, containing data normalised. schema database schema foreign key references, given autoref. digits positive integer, indicating many significant digits used numeric complex variables. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See \"Floating-point variables\" section discover rounding necessary consistent results across different machines. See note print.default digits >= 16. check logical, indicating whether check df satisfies functional dependencies enforced schema creating result. can find key violations without spending time creating result first, redundant df used create schema first place.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"database object, containing data df within database schema given schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/decompose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Decompose a data frame based on given normalised dependencies — decompose","text":"schema constructed using approximate dependencies data frame, decompose returns error, prevent either duplicate records lossy decompositions. temporary: next update, plan add option allow , add \"approximate\" equivalents databases database schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/dependant.html","id":null,"dir":"Reference","previous_headings":"","what":"Dependants — dependant","title":"Dependants — dependant","text":"Generic function, given method fetching dependants functional dependencies.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/dependant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dependants — dependant","text":"","code":"dependant(x, ...)  dependant(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/dependant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dependants — dependant","text":"x R object. given method, functional_dependency. ... arguments passed methods. value character vector length dependant(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/dependant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dependants — dependant","text":"character vector containing dependants.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/detset.html","id":null,"dir":"Reference","previous_headings":"","what":"Determinant sets — detset","title":"Determinant sets — detset","text":"Generic function, given method fetching determinant sets functional dependencies.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/detset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determinant sets — detset","text":"","code":"detset(x, ...)  detset(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/detset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determinant sets — detset","text":"x R object. given method, functional_dependency. ... arguments passed methods. value character vector length detset(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/detset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determinant sets — detset","text":"list containing determinant sets, consisting character vector unique elements.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine Duplicate Elements — df_duplicated","title":"Determine Duplicate Elements — df_duplicated","text":"duplicated \"determines elements vector data frame duplicates elements smaller subscripts, returns logical vector indicating elements (rows) duplicates\". However, R 4.1, calling data frame zero columns always returns empty logical vector. repercussions functions use duplicated, unique anyDuplicated. functions add zero-column data frames special case.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine Duplicate Elements — df_duplicated","text":"","code":"df_duplicated(x, incomparables = FALSE, fromLast = FALSE, ...)  df_unique(x, incomparables = FALSE, fromLast = FALSE, ...)  df_anyDuplicated(x, incomparables = FALSE, fromLast = FALSE, ...)  df_records(x, use_rownames = FALSE, use_colnames = FALSE)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine Duplicate Elements — df_duplicated","text":"x data frame. incomparables vector values compared.     FALSE special value, meaning values can     compared, may value accepted methods     default.  coerced internally type        x. fromLast logical indicating duplication considered     reverse side, .e., last (rightmost) identical     elements correspond duplicated = FALSE. ... arguments particular methods. use_rownames logical, FALSE default, indicating whether row values keep row names x. Defaults FALSE. use_colnames logical, FALSE default, indicating whether row values keep column names x elements. Defaults FALSE.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine Duplicate Elements — df_duplicated","text":"df_duplicated, logical vector one element row. df_unique, data frame returned columns, possible fewer rows (row names first occurrences unique rows). df_anyDuplicated, integer real vector length one value 1-based index first duplicate , otherwise 0. df_records, list row values x. based step duplicated.data.frame. However, data frames zero columns, special handling returns list empty row values, one row x. Without special handling, step returns empty list. cause duplicated returning incorrect results zero-column data frames older versions R.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_duplicated.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine Duplicate Elements — df_duplicated","text":"","code":"# row values for a 5x0 data frame x <- data.frame(a = 1:5)[, FALSE, drop = FALSE] do.call(Map, unname(c(list, x))) # original step returns empty list #> list() df_records(x) # corrected version preserves row count #> [[1]] #> list() #>  #> [[2]] #> list() #>  #> [[3]] #> list() #>  #> [[4]] #> list() #>  #> [[5]] #> list() #>"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_equiv.html","id":null,"dir":"Reference","previous_headings":"","what":"Test data frames for equivalence under row reordering — df_equiv","title":"Test data frames for equivalence under row reordering — df_equiv","text":"convenience function, mostly used testing rejoin works intended. checks data frames dimensions column names, duplicates allowed, checks contain data. latter step, column names made unique first, columns duplicate names must presented order data frames.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_equiv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test data frames for equivalence under row reordering — df_equiv","text":"","code":"df_equiv(df1, df2, digits = getOption(\"digits\"))"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_equiv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test data frames for equivalence under row reordering — df_equiv","text":"df1, df2 Data frames. digits positive integer, indicating many significant digits used numeric complex variables. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See note print.default digits >= 16.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_equiv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test data frames for equivalence under row reordering — df_equiv","text":"logical.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_rbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine R Objects by Rows or Columns — df_rbind","title":"Combine R Objects by Rows or Columns — df_rbind","text":"rbind takes \"sequence vector, matrix data-frame arguments\", combines rows latter. However, R 4.1, calling data frame zero columns always returns zero rows, due issue mentioned df_duplicated. function adds zero-column data frames special case.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_rbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine R Objects by Rows or Columns — df_rbind","text":"","code":"df_rbind(...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_rbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine R Objects by Rows or Columns — df_rbind","text":"... data frames.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/df_rbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine R Objects by Rows or Columns — df_rbind","text":"data frame containing ... arguments row-wise.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":null,"dir":"Reference","previous_headings":"","what":"Dependency discovery with DFD — discover","title":"Dependency discovery with DFD — discover","text":"Finds minimal functional dependencies represented data frame.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dependency discovery with DFD — discover","text":"","code":"discover(   df,   method = c(\"FDHitsSep\", \"FDHitsJoint\", \"DFD\"),   digits = getOption(\"digits\"),   exclude = character(),   exclude_class = character(),   dependants = names(df),   detset_limit = ncol(df) - 1L,   progress = FALSE,   progress_file = \"\",   skip_bijections = FALSE,   accuracy = 1,   full_cache = TRUE,   store_cache = TRUE )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dependency discovery with DFD — discover","text":"df data.frame, relation evaluate. method string, indicating search algorithm use. Currently, defaults DFD. Alternative options FDHitsSep FDHitsJoint. digits positive integer, indicating many significant digits used numeric complex variables. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See \"Floating-point variables\" section rounding necessary consistent results across different machines. See note print.default digits >=   16. exclude character vector, containing names attributes consider members determinant sets. names given present df, user given warning. exclude_class character vector, indicating classes attributes consider members determinant_sets. Attributes excluded inherit given class. dependants character vector, containing names attributes find minimal functional dependencies dependant. default, attribute names. smaller set attribute names reduces amount searching required, can reduce computation time potential dependencies interest. detset_limit integer, indicating largest determinant set size searched . default, large enough allow possible determinant sets. See Details comments effect result, computation time. progress logical, whether display progress user dependency search discover. progress_file scalar character connection. progress non-zero, determines progress written , way file argument cat. skip_bijections logical, indicating whether skip dependency searches made redundant discovered bijections attributes. can significantly speed search df contains equivalent attributes early column order, results undefined behaviour accuracy < 1. See Details information. Currently implemented DFD. accuracy numeric (0, 1]: accuracy threshold required order conclude dependency. Accuracy thresholds less one supported DFD. full_cache logical, indicating whether store information sets attributes group relation records (stripped partitions). Otherwise, number groups stored. Storing stripped partition expected let algorithm run quickly, might inefficient small data frames small amounts memory. relevant DFD. store_cache logical, indicating whether keep cached information use finding dependencies dependants. allows algorithm run quickly re-calculate information, takes memory. relevant DFD.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dependency discovery with DFD — discover","text":"functional_dependency object, containing discovered dependencies. column names df stored attrs attribute, order, serve default priority order attributes normalisation.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dependency discovery with DFD — discover","text":"Column names df must unique. two search algorithms available finding dependencies: DFD, FDHits. described .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"dfd","dir":"Reference","previous_headings":"","what":"DFD","title":"Dependency discovery with DFD — discover","text":"DFD algorithm searches determinant sets dependant attribute separately, traversing powerset (non-excluded) attributes. can roughly considered depth-first search candidate determinant sets. implementation DFD differs little algorithm presented original paper: attributes, attribute types, can designated, ahead time, candidate members determinant sets. reduces number candidate determinant sets searched, saving time searching determinant sets user remove later anyway. dependants can also trimmed similar fashion, although reduces search space linearly rather exponentially. Attributes single unique value, .e. constant, get attributed single empty determinant set. standard DFD algorithm, assigned non-excluded attributes length-one determinant sets. Assigning empty set distinguishes constant, allowing special treatment normalisation later steps. done original Python library, extra case seed generation discovered maximal non-dependencies. case, take single-attribute nodes, filter minimal dependencies usual. equivalent taking empty set single maximal non-dependency. three results checking whether candidate node minimal/maximal. TRUE indicates node minimal/maximal, usual. FALSE split FALSE NA. NA indicates can yet determine whether node minimal/maximal. FALSE indicates determined minimal/maximal, can set category . done checking whether adjacent subsets/supersets dependencies/non-dependencies, instead waiting exhaust adjacent subsets/supersets visit picking next node visit. yet keep hashmaps manage subset/superset relationships, described Section 3.5 original paper. skip_bijections allows additional optimisation finding functional dependencies pairwise-equivalent attributes. Missing values (NA) treated normal value, NA = NA true, x = NA false non-NA value x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"fdhits","dir":"Reference","previous_headings":"","what":"FDHits","title":"Dependency discovery with DFD — discover","text":"FDHits begins sampling pairs records attributes values differ (difference sets). difference sets render determinant-dependant pairings invalid, pruning search space. candidate pairing rendered invalid known difference sets, validated, resulting either confirmation minimal functional dependency, discovery new difference sets make invalid. two variants. FDHitsSep performs search dependant attribute separately, way DFD. FDHitsJoint handles dependant attributes time. implementation FDHits differs little algorithm presented original paper: attributes, attribute types, can designated, ahead time, candidate members determinant sets. reduces number candidate determinant sets searched, saving time searching determinant sets user remove later anyway. dependants can also trimmed similar fashion. search can limited determinant sets given size. also option DFD, useful FDHits, due search order. described paper, FDHitsSep FDHitsJoint branch search several child nodes: \\(\\mu_0\\) FDHitsJoint, \\(\\mu_1\\), \\(\\mu_2\\) etc. . paper implies latter nodes visited order. However, causes algorithm always work correctly: guaranteed correctness, must visited reverse order, \\(\\mu_0\\) able visited point. correction expected appear future paper. final algorithm paper automatically chooses FDHitsSep FDHits Joint, depending number initially-sampled difference sets. yet implemented.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"floating-point-variables","dir":"Reference","previous_headings":"","what":"Floating-point variables","title":"Dependency discovery with DFD — discover","text":"Numerical/complex values, .e. floating-point values, represent difficulties stating functional dependencies. fundamental condition stating functional dependencies can compare two values variable, equivalent equivalent. Usually, done checking equal – approach used discover – can use comparison equivalence relation. However, checking floating-point values equality simple. == appropriate, even comparing non-calculated values read file, given number converted float can vary computer architecture, meaning two values can considered equal one computer, equal another. can happen even using 64-bit R, even though R platforms work values conforming standard (see double). example, \\(8.54917750000000076227\\) \\(8.54917749999999898591\\) converted different floating-point representations x86, representation ARM, resulting inequality equality respectively. reasons, checking numerical/complex values (near-)equality R usually done .equal. determines values \\(x\\) \\(y\\) equal absolute/relative absolute difference within tolerance value. However, can use . Equivalence relations must transitive: values \\(x\\), \\(y\\), \\(z\\), \\(x\\) equivalent \\(y\\) \\(z\\), \\(y\\) \\(z\\) must also equivalent. tolerance-based equivalence transitive: reasonably straightforward set three values outer values far enough apart considered non-equivalent, middle value close enough considered equivalent . Using determine functional dependencies, therefore, easily result large number inconsistencies. means good option comparing numerical/complex values -equivalence, consistent results across different machines, must treat differently. three options: Round/truncate values, comparison, low degree precision; Coerce values another class passing discover; Read values characters reading data file. discover takes first option, default number significant digits low enough ensure consistency across different machines. However, user can also use options processing data passing discover. third option, particular, recommended reading data file.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"skipping-bijections","dir":"Reference","previous_headings":"","what":"Skipping bijections","title":"Dependency discovery with DFD — discover","text":"Skipping bijections allows skipping redundant searches. example, search discovers -> B B -> , one attributes considered remainder search. Since search time increases exponentially number attributes considered, can significantly speed search times. moment, done bijections single attributes, <-> B; <-> {B, C}, nothing skipped. Whether bijections skipped affect functional dependencies present output, might affect order. Skipping bijections approximate dependencies, .e. accuracy < 1, avoided: can result incorrect output, since approximate bijection imply equivalent approximate dependencies.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"limiting-the-determinant-set-size","dir":"Reference","previous_headings":"","what":"Limiting the determinant set size","title":"Dependency discovery with DFD — discover","text":"Setting detset_limit smaller largest-possible value different behaviour different search algorithms, result always discover(x, 1, detset_limit = n) equivalent full search, fds <- discover(x, 1), filtering determinant set size post-hoc, fds[lengths(detset(fds)) <= n]. DFD, naive way implement removing determinant sets larger limit search tree possible functional dependencies dependant. However, usually results search taking much time without limit. example, suppose search determinant sets dependant none (dependant key df, example). Using DFD, begin single attribute, add attributes one--one, since every set gives non-dependency. reach maximum-size set, can mark subsets also non-dependencies. default limit, one maximum-size set, containing available attributes. \\(n\\) candidate attributes determinants, search finishes visiting \\(n\\) sets. smaller limit \\(k\\), \\(\\binom{n}{k}\\) maximum-size sets explore. Since DFD search adds removes one attribute step, means search must take least \\(k - 2 + 2\\binom{n}{k}\\) steps, larger \\(n\\) non-trivial cases \\(0 < k \\leq n\\). therefore use different approach, determinant sets size limit allowed candidate seeds new search paths, discovered dependencies size limit discard end entire DFD search. means nodes determinant sets size limit visited order determine maximality non-dependencies within size limit. turns rare results significant speed-, never results search visit nodes without size limit, average search time never made worse. FDHits implements detset_limit naturally, since explores determinant sets increasing set size. Limiting size simply matter visiting new nodes determinant set within given size limit.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Dependency discovery with DFD — discover","text":"DFD: Abedjan Z., Schulze P., Naumann F. (2014) DFD: efficient functional dependency discovery. Proceedings 23rd ACM International Conference Conference Information Knowledge Management (CIKM '14). New York, U.S.., 949–958. FDHits: Bleifuss T., Papenbrock T., Bläsius T., Schirneck M, Naumann F. (2024) Discovering Functional Dependencies Hitting Set Enumeration. Proc. ACM Manag. Data, 2, 1, 43:1–24.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/discover.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dependency discovery with DFD — discover","text":"","code":"# simple example discover(ChickWeight) #> 2 functional dependencies #> 4 attributes: weight, Time, Chick, Diet #> Time, Chick -> weight #>       Chick -> Diet  # example with spurious dependencies discover(CO2) #> 5 functional dependencies #> 5 attributes: Plant, Type, Treatment, conc, uptake #> Treatment, conc, uptake -> Plant #>            conc, uptake -> Type #>                   Plant -> Type #>                   Plant -> Treatment #>             Plant, conc -> uptake # exclude attributes that can't be determinants. # in this case, the numeric attributes are now # not determined by anything, because of repeat measurements # with no variable to mark them as such. discover(CO2, exclude_class = \"numeric\") #> 2 functional dependencies #> 5 attributes: Plant, Type, Treatment, conc, uptake #> Plant -> Type #> Plant -> Treatment # include only dependencies with dependants of interest. discover(CO2, dependants = c(\"Treatment\", \"uptake\")) #> 2 functional dependencies #> 5 attributes: Plant, Type, Treatment, conc, uptake #>       Plant -> Treatment #> Plant, conc -> uptake"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional dependency vectors — functional_dependency","title":"Functional dependency vectors — functional_dependency","text":"Creates set functional dependencies length-one dependants.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional dependency vectors — functional_dependency","text":"","code":"functional_dependency(FDs, attrs_order, unique = TRUE)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional dependency vectors — functional_dependency","text":"FDs list functional dependencies, form two-elements lists: first element contains character vector attributes determinant set, second element contains single dependent attribute (dependant). attrs_order character vector, giving names attributes. need present FDs, attributes FDs must present attrs. unique logical, TRUE default, whether remove duplicate dependencies.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional dependency vectors — functional_dependency","text":"functional_dependency object, containing list given FDs, attrs_order attribute name. Functional dependencies returned determinant sets sorted according attribute order attrs. duplicates found sorting removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional dependency vectors — functional_dependency","text":"several sets functional dependencies concatenated, attrs_order attributes merged, preserve original attribute orders, possible. possible, orderings disagree, returned value attrs_order attribute union instead.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/functional_dependency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional dependency vectors — functional_dependency","text":"","code":"fds <- functional_dependency(   list(list(c(\"a\", \"b\"), \"c\"), list(character(), \"d\")),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) print(fds) #> 2 functional dependencies #> 4 attributes: a, b, c, d #> a, b -> c #>      -> d detset(fds) #> [[1]] #> [1] \"a\" \"b\" #>  #> [[2]] #> character(0) #>  dependant(fds) #> [1] \"c\" \"d\" attrs_order(fds) #> [1] \"a\" \"b\" \"c\" \"d\"  # vector operations fds2 <- functional_dependency(list(list(\"e\", \"a\")), c(\"a\", \"e\")) c(fds, fds2) # attrs_order attributes are merged #> 3 functional dependencies #> 5 attributes: a, b, c, d, e #> a, b -> c #>      -> d #>    e -> a unique(c(fds, fds)) #> 2 functional dependencies #> 4 attributes: a, b, c, d #> a, b -> c #>      -> d  # subsetting fds[1] #> 1 functional dependency #> 4 attributes: a, b, c, d #> a, b -> c fds[c(1, 2, 1)] #> 3 functional dependencies #> 4 attributes: a, b, c, d #> a, b -> c #>      -> d #> a, b -> c stopifnot(identical(fds[[2]], fds[2]))  # reassignment fds3 <- fds fds3[2] <- functional_dependency(list(list(\"a\", \"c\")), attrs_order(fds3)) print(fds3) #> 2 functional dependencies #> 4 attributes: a, b, c, d #> a, b -> c #>    a -> c detset(fds3)[[2]] <- character() dependant(fds3)[[2]] <- \"d\" stopifnot(identical(fds3, fds)) # changing appearance priority for attributes attrs_order(fds3) <- rev(attrs_order(fds3)) fds3 #> 2 functional dependencies #> 4 attributes: d, c, b, a #> b, a -> c #>      -> d  # reconstructing from components fds_recon <- functional_dependency(  Map(list, detset(fds), dependant(fds)),  attrs_order(fds) ) stopifnot(identical(fds_recon, fds))  # can be a data frame column data.frame(id = 1:2, fd = fds) #>   id        fd #> 1  1 a, b -> c #> 2  2      -> d  # (in)equality ignores header stopifnot(all(fds3 == fds)) stopifnot(!any(fds != fds))"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot a data frame — gv.data.frame","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"Produces text input Graphviz make HTML diagram given data frame.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"","code":"# S3 method for class 'data.frame' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"x data.frame. name character scalar, giving name record, . name must non-empty, since also used name single table plot. Defaults NA: left missing, set \"data\". ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.data.frame.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot a data frame — gv.data.frame","text":"rows plotted data frame include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot databases — gv.database","title":"Generate Graphviz input text to plot databases — gv.database","text":"Produces text input Graphviz make HTML diagram given database.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot databases — gv.database","text":"","code":"# S3 method for class 'database' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot databases — gv.database","text":"x database, returned autoref autodb. name scalar character, giving name database, . name used resulting graph, allow easier combining graphs single diagram required. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot databases — gv.database","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot databases — gv.database","text":"relation database presented set rows, one attribute relation. rows include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot database schemas — gv.database_schema","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"Produces text input Graphviz make HTML diagram given database schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"","code":"# S3 method for class 'database_schema' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"x database schema, given normalise, synthesise, autoref. name character scalar, giving name schema, . ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.database_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot database schemas — gv.database_schema","text":"relation schema presented set rows, one attribute relation. rows include information attribute classes. foreign key references represented arrows attribute pairs.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot objects — gv","title":"Generate Graphviz input text to plot objects — gv","text":"Produces text input Graphviz make HTML diagram given object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot objects — gv","text":"","code":"gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot objects — gv","text":"x object plotted. name scalar character, giving name object, . name used resulting graph, allow easier combining graphs single diagram required. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot objects — gv","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot objects — gv","text":"Details plotted given individual methods. expected commonalities, described . object expected one following: object whose elements length. Examples data frames, matrices, objects can represent relations, names elements, optional name object . graph sub-objects, represent relation described , possibly connections objects, optional name graph whole. relation presented record-like shape, following elements: optional header relation's name, number (unique) records. set rows, one attribute relation. rows following contents: attribute names. depiction relation's (candidate) keys. column represents key, filled cell indicates attribute row key. keys given lexical order, precedence given keys fewer attributes, keys attributes appear earlier original data frame's attribute order. Default output package functions thus primary key given first. future, changed always give primary key first. optionally, attribute types: specifically, first element passing attribute's values class. foreign key references relations represented one-way arrows, one per attribute foreign key. object name, name attached resulting graph Graphviz. allow easier combination several graphs single image, user wishes .","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Graphviz input text to plot objects — gv","text":"","code":"# simple data.frame example txt_df <- gv(ChickWeight, \"chick\") cat(txt_df) #> digraph \"chick\" { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">chick (578 rows)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD PORT=\"FROM_weight\">numeric<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD PORT=\"FROM_time\">numeric<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD PORT=\"FROM_diet\">factor<\/TD><\/TR> #>     <\/TABLE>>]; #> } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   DiagrammeR::grViz(txt_df) }  {\"x\":{\"diagram\":\"digraph \\\"chick\\\" {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">chick (578 rows)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD PORT=\\\"FROM_weight\\\">numeric<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD PORT=\\\"FROM_time\\\">numeric<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\">ordered<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD PORT=\\\"FROM_diet\\\">factor<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}# simple database example db <- autodb(ChickWeight) txt_db <- gv(db) cat(txt_db) #> digraph { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Chick (50 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD><\/TD><TD PORT=\"FROM_diet\">factor<\/TD><\/TR> #>     <\/TABLE>>]; #>   \"Time_Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Time_Chick (578 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_time\">numeric<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">ordered<\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD><\/TD><TD PORT=\"FROM_weight\">numeric<\/TD><\/TR> #>     <\/TABLE>>]; #>  #>   \"Time_Chick\":FROM_chick -> \"Chick\":TO_chick; #> } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   DiagrammeR::grViz(txt_db) }  {\"x\":{\"diagram\":\"digraph {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"3\\\">Chick (50 records)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_chick\\\">ordered<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD><\\/TD><TD PORT=\\\"FROM_diet\\\">factor<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n  \\\"Time_Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"3\\\">Time_Chick (578 records)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_time\\\">numeric<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_chick\\\">ordered<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD><\\/TD><TD PORT=\\\"FROM_weight\\\">numeric<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n\\n  \\\"Time_Chick\\\":FROM_chick -> \\\"Chick\\\":TO_chick;\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}# simple relation schemas rschema <- synthesise(discover(ChickWeight)) txt_rschema <- gv(rschema) cat(txt_rschema) #> digraph { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">Chick<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD PORT=\"FROM_diet\"><\/TD><\/TR> #>     <\/TABLE>>]; #>   \"Time_Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">Time_Chick<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD PORT=\"FROM_time\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD PORT=\"FROM_weight\"><\/TD><\/TR> #>     <\/TABLE>>]; #> } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   DiagrammeR::grViz(txt_rschema) }  {\"x\":{\"diagram\":\"digraph {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">Chick<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD PORT=\\\"FROM_diet\\\"><\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n  \\\"Time_Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">Time_Chick<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD PORT=\\\"FROM_time\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD PORT=\\\"FROM_weight\\\"><\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}# simple database schema dschema <- normalise(discover(ChickWeight)) txt_dschema <- gv(dschema) cat(txt_dschema) #> digraph { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">Chick<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD PORT=\"FROM_diet\"><\/TD><\/TR> #>     <\/TABLE>>]; #>   \"Time_Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"2\">Time_Chick<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD PORT=\"FROM_time\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD PORT=\"FROM_chick\" BGCOLOR=\"black\"><\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD PORT=\"FROM_weight\"><\/TD><\/TR> #>     <\/TABLE>>]; #>  #>   \"Time_Chick\":FROM_chick -> \"Chick\":TO_chick; #> } DiagrammeR::grViz(txt_dschema)  {\"x\":{\"diagram\":\"digraph {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">Chick<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD PORT=\\\"FROM_diet\\\"><\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n  \\\"Time_Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"2\\\">Time_Chick<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD PORT=\\\"FROM_time\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD PORT=\\\"FROM_chick\\\" BGCOLOR=\\\"black\\\"><\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD PORT=\\\"FROM_weight\\\"><\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n\\n  \\\"Time_Chick\\\":FROM_chick -> \\\"Chick\\\":TO_chick;\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}# simple relations rel <- create(synthesise(discover(ChickWeight))) txt_rel <- gv(rel) cat(txt_rel) #> digraph { #>   rankdir = \"LR\" #>   node [shape=plaintext]; #>  #>   \"Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Chick (0 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">logical<\/TD><\/TR> #>     <TR><TD PORT=\"TO_diet\">Diet<\/TD><TD><\/TD><TD PORT=\"FROM_diet\">logical<\/TD><\/TR> #>     <\/TABLE>>]; #>   \"Time_Chick\" [label = < #>     <TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"> #>     <TR><TD COLSPAN=\"3\">Time_Chick (0 records)<\/TD><\/TR> #>     <TR><TD PORT=\"TO_time\">Time<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_time\">logical<\/TD><\/TR> #>     <TR><TD PORT=\"TO_chick\">Chick<\/TD><TD BGCOLOR=\"black\"><\/TD><TD PORT=\"FROM_chick\">logical<\/TD><\/TR> #>     <TR><TD PORT=\"TO_weight\">weight<\/TD><TD><\/TD><TD PORT=\"FROM_weight\">logical<\/TD><\/TR> #>     <\/TABLE>>]; #> } if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {   DiagrammeR::grViz(txt_rel) }  {\"x\":{\"diagram\":\"digraph {\\n  rankdir = \\\"LR\\\"\\n  node [shape=plaintext];\\n\\n  \\\"Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"3\\\">Chick (0 records)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_chick\\\">logical<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_diet\\\">Diet<\\/TD><TD><\\/TD><TD PORT=\\\"FROM_diet\\\">logical<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n  \\\"Time_Chick\\\" [label = <\\n    <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" CELLSPACING=\\\"0\\\" CELLPADDING=\\\"4\\\">\\n    <TR><TD COLSPAN=\\\"3\\\">Time_Chick (0 records)<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_time\\\">Time<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_time\\\">logical<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_chick\\\">Chick<\\/TD><TD BGCOLOR=\\\"black\\\"><\\/TD><TD PORT=\\\"FROM_chick\\\">logical<\\/TD><\\/TR>\\n    <TR><TD PORT=\\\"TO_weight\\\">weight<\\/TD><TD><\\/TD><TD PORT=\\\"FROM_weight\\\">logical<\\/TD><\\/TR>\\n    <\\/TABLE>>];\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot relations — gv.relation","title":"Generate Graphviz input text to plot relations — gv.relation","text":"Produces text input Graphviz make HTML diagram given relation.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot relations — gv.relation","text":"","code":"# S3 method for class 'relation' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot relations — gv.relation","text":"x relation. name character scalar, giving name schema, . ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot relations — gv.relation","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot relations — gv.relation","text":"relation presented set rows, one attribute relation. rows include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"Produces text input Graphviz make HTML diagram given relation schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"","code":"# S3 method for class 'relation_schema' gv(x, name = NA_character_, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"x relation schema, given relation_schema synthesise. name character scalar, giving name schema, . ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"scalar character, containing text input Graphviz.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/gv.relation_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Graphviz input text to plot relation schemas — gv.relation_schema","text":"relation schema presented set rows, one attribute relation. rows include information attribute classes.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert data — insert","title":"Insert data — insert","text":"Generic function inserting data frame data object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert data — insert","text":"","code":"insert(   x,   vals,   relations = names(x),   all = FALSE,   digits = getOption(\"digits\"),   ... )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert data — insert","text":"x relational data object, insert data, relation database object. vals data frame, containing data insert. relations character vector, containing names elements x insert data. default, insert attempts insert data every element. logical, indicating whether vals required contain attributes elements x[relations]. default, , data inserted elements x[relations] whose attributes present vals. digits positive integer, indicating many significant digits used numeric complex variables. value NA results rounding. default, uses getOption(\"digits\"), similarly format. See \"Floating-point variables\" section discover rounding necessary consistent results across different machines. See note print.default digits >= 16. ... arguments pass methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Insert data — insert","text":"R object class x, containing additional new data.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/insert.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Insert data — insert","text":"function intended inserting object comprised data frames, relation database. given methods following behaviour: empty set data inserted, non-empty object element, nothing happens. empty set data inserted empty object element, resulting element also empty, takes attribute/column classes inserted data. done prevent know attribute classes object creation. Insertion can fail inserting violate object constraints. example, databases data inserted violate candidate/foreign key constraints. cases, data inserted object element way using rbind, followed unique. key violations prevent insertion, re-insertion existing records object element . makes insertion equivalent INSERT IGNORE expression SQL. particular, somewhat like using expression SQLite, since implementation uses dynamic typing. vals contains attributes included attrs_order(x), insert throws error, since attributes inserted. partial set attributes inserted, FALSE, data inserted components x[relations] whose required attributes present vals. TRUE, insert returns error instead. useful specifying relations: case, often intend insert specified elements, including required attributes mistake, = TRUE prevents . TRUE, insert throws error case: ensures insert members specified value relations.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational data keys — keys","title":"Relational data keys — keys","text":"Generic function, given method fetching candidate key lists relation schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational data keys — keys","text":"","code":"keys(x, ...)  keys(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational data keys — keys","text":"x relational schema object, relation_schema database_schema object, relational data object, relation database object. ... arguments passed methods. value list lists character vectors, length keys(x, ...). number keys element x can changed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational data keys — keys","text":"list containing lists unique character vectors, representing candidate keys element x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge relation schemas with empty keys — merge_empty_keys","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"Merges object's schemas empty keys. remaining schema contains attributes contained schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"","code":"merge_empty_keys(x)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"x relational schema object, relation_schema database_schema object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"R object class x, relations empty key merged single relation.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_empty_keys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge relation schemas with empty keys — merge_empty_keys","text":"function generic, makes use generic functions keys merge_schemas. input class valid methods generic functions can passed function. database_schema objects, references involving schemas empty keys updated refer merged schema.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge relation schemas in given pairs — merge_schemas","title":"Merge relation schemas in given pairs — merge_schemas","text":"Generic function merges pairs object's schemas matching sets keys. remaining schemas contain attributes schemas merged .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge relation schemas in given pairs — merge_schemas","text":"","code":"merge_schemas(x, to_remove, merge_into, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge relation schemas in given pairs — merge_schemas","text":"x relational schema object, relation_schema database_schema object. to_remove integer vector, giving indices schemas merged schemas, removed. merge_into integer vector length to_remove, giving indices schemas merge. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge relation schemas in given pairs — merge_schemas","text":"R object class x, relations merged indicated.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/merge_schemas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge relation schemas in given pairs — merge_schemas","text":"","code":"rs <- relation_schema(   list(     a = list(c(\"a\", \"b\"), list(\"a\")),     b = list(c(\"b\", \"c\"), list(\"b\")),     b.1 = list(c(\"b\", \"d\"), list(\"b\")),     d = list(c(\"d\", \"e\"), list(\"d\", \"e\"))   ),   letters[1:5] ) ds <- database_schema(   rs,   list(     list(\"a\", \"b\", \"b\", \"b\"),     list(\"b.1\", \"d\", \"d\", \"d\")    ) ) merge_schemas(rs, 3, 2) # merging b and b.1 #> 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c, d #>   key 1: b #> schema d: d, e #>   key 1: d #>   key 2: e merge_schemas(ds, 3, 2) # also merging their references #> database schema with 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c, d #>   key 1: b #> schema d: d, e #>   key 1: d #>   key 2: e #> references: #> a.{b} -> b.{b} #> b.{d} -> d.{d}  # merging a schema into itself just removes it merge_schemas(rs, 3, 3) #> 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #> schema d: d, e #>   key 1: d #>   key 2: e merge_schemas(ds, 3, 3) #> database schema with 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #> schema d: d, e #>   key 1: d #>   key 2: e #> references: #> a.{b} -> b.{b}"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":null,"dir":"Reference","previous_headings":"","what":"Create normalised database schemas from functional dependencies — normalise","title":"Create normalised database schemas from functional dependencies — normalise","text":"Creates database schema given functional dependencies, satisfying least third normal form, using Bernstein's synthesis.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create normalised database schemas from functional dependencies — normalise","text":"","code":"normalise(   dependencies,   single_ref = FALSE,   ensure_lossless = TRUE,   reduce_attributes = TRUE,   remove_avoidable = FALSE,   constants_name = \"constants\",   progress = FALSE,   progress_file = \"\" )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create normalised database schemas from functional dependencies — normalise","text":"dependencies functional_dependency object, given discover. single_ref logical, FALSE default. TRUE, one reference relation pair kept generating foreign key references. pair multiple references, kept reference refers earliest key child relation, sorted priority order. ensure_lossless logical, TRUE default. TRUE, decomposition lossless, extra relation added make decomposition lossless. reduce_attributes logical, TRUE default. TRUE, dependencies checked determinant attributes made redundant dependencies. redundant dependencies output discover, since redundant attributes. remove_avoidable logical, indicating whether remove avoidable attributes relations. , attribute removed relations keys can changed needed preserve given functional dependencies. constants_name scalar character, giving name relation created store constant attributes. generated relation name, changed, warning, ensure relations unique name. progress logical, whether display progress user dependency search discover. progress_file scalar character connection. progress non-zero, determines progress written , way file argument cat.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create normalised database schemas from functional dependencies — normalise","text":"database_schema object, containing synthesis relation schemas created foreign key references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/normalise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create normalised database schemas from functional dependencies — normalise","text":"wrapper function applying synthesise autoref, order. creating relation schemas foreign key references separately, use functions directly. See functions examples. details synthesis algorithm used, see synthesise.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":null,"dir":"Reference","previous_headings":"","what":"Nudge meta-analysis data — nudge","title":"Nudge meta-analysis data — nudge","text":"Data used meta-analysis effectiveness nudges, .e. choice architecture interventions.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nudge meta-analysis data — nudge","text":"","code":"nudge"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Nudge meta-analysis data — nudge","text":"data frame 447 effect size measurements 25 columns: publication_id, integer ID number publication. Note two publications erroneously assigned ID number, unique publication identifier. study_id, integer ID number study. es_id, integer ID number effect size measured. reference, publication citation \"Author(s) (year)\" format. Due two publications assigned reference, also unique publication identifier. title, title publication. Due error assigning publication ID numbers, unique publication identifier within data set. year, year publication. location, geographical location intervention. given factor, rather integer, using information provided codebook. domain, factor giving intervention's behavioural domain. intervention_category, factor giving intervention's category, based taxonomy Münscher et al. (2016). intervention_technique, factor giving intervention's technique, based taxonomy Münscher et al. (2016). type_experiment, factor giving type experiment, defined Harrison List (2004). population, factor giving intervention's target population. given factor, rather integer, using information provided codebook. n_study, sample size overall study. n_comparison, combined sample size control intervention measured effect size. n_control, sample size control condition measured effect size. n_intervention, sample size intervention condition measured effect size. binary_outcome, logical whether outcome scale binary continuous. mean_control, mean outcome control condition. sd_control, SD outcome control condition. mean_intervention, mean outcome intervention condition. sd_intervention, SD outcome intervention condition. cohens_d, extracted effect size intervention. variance_d, variance extracted effect size. approximation, logical whether effect size extraction involved approximation. wansink, logical whether study (co-)authored Brian Wansink. added revision, , years publication, Wansink many papers retracted corrected, due various questionable practices, resulting Wansink determined committed scientific misconduct. column added check whether findings robust exclusion non-retracted studies Cornell Food Brand Laboratory, Wansink director.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Nudge meta-analysis data — nudge","text":"https://osf.io/fywae/","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/nudge.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nudge meta-analysis data — nudge","text":"Mertens S., Herberz M., Hahnel U. J. J., Brosch T. (2022) effectiveness nudging: meta-analysis choice architecture interventions across behavioral domains. Proc. Natl. Acad. Sci. U.S.., 4, 119(1).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational data records — records","title":"Relational data records — records","text":"Generic function, retrieving data contained database-like structure. particular, intended structures individual relations accessed subsetting.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational data records — records","text":"","code":"records(x, ...)  records(x, ...) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational data records — records","text":"x relational data object, relation database object. ... arguments passed methods. value list data frames length records(x,   ...), data frame column names replace, order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational data records — records","text":"list containing data frames, elements named respective relations.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relational data records — records","text":"Since relational data objects autodb, relation database, subsetting methods return relational data objects, data contained within accessed subsetting. function intended accessing instead. recommended call records subsetting, since subsetting relation data object work thrown away, subsetting database checking whether foreign key references removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/records.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational data records — records","text":"","code":"db <- autodb(ChickWeight) records(db) # data for Chick and Time_Chick relations #> $Chick #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4 #>  #> $Time_Chick #>     Time Chick weight #> 1      0     1     42 #> 2      2     1     51 #> 3      4     1     59 #> 4      6     1     64 #> 5      8     1     76 #> 6     10     1     93 #> 7     12     1    106 #> 8     14     1    125 #> 9     16     1    149 #> 10    18     1    171 #> 11    20     1    199 #> 12    21     1    205 #> 13     0     2     40 #> 14     2     2     49 #> 15     4     2     58 #> 16     6     2     72 #> 17     8     2     84 #> 18    10     2    103 #> 19    12     2    122 #> 20    14     2    138 #> 21    16     2    162 #> 22    18     2    187 #> 23    20     2    209 #> 24    21     2    215 #> 25     0     3     43 #> 26     2     3     39 #> 27     4     3     55 #> 28     6     3     67 #> 29     8     3     84 #> 30    10     3     99 #> 31    12     3    115 #> 32    14     3    138 #> 33    16     3    163 #> 34    18     3    187 #> 35    20     3    198 #> 36    21     3    202 #> 37     0     4     42 #> 38     2     4     49 #> 39     4     4     56 #> 40     6     4     67 #> 41     8     4     74 #> 42    10     4     87 #> 43    12     4    102 #> 44    14     4    108 #> 45    16     4    136 #> 46    18     4    154 #> 47    20     4    160 #> 48    21     4    157 #> 49     0     5     41 #> 50     2     5     42 #> 51     4     5     48 #> 52     6     5     60 #> 53     8     5     79 #> 54    10     5    106 #> 55    12     5    141 #> 56    14     5    164 #> 57    16     5    197 #> 58    18     5    199 #> 59    20     5    220 #> 60    21     5    223 #> 61     0     6     41 #> 62     2     6     49 #> 63     4     6     59 #> 64     6     6     74 #> 65     8     6     97 #> 66    10     6    124 #> 67    12     6    141 #> 68    14     6    148 #> 69    16     6    155 #> 70    18     6    160 #> 71    20     6    160 #> 72    21     6    157 #> 73     0     7     41 #> 74     2     7     49 #> 75     4     7     57 #> 76     6     7     71 #> 77     8     7     89 #> 78    10     7    112 #> 79    12     7    146 #> 80    14     7    174 #> 81    16     7    218 #> 82    18     7    250 #> 83    20     7    288 #> 84    21     7    305 #> 85     0     8     42 #> 86     2     8     50 #> 87     4     8     61 #> 88     6     8     71 #> 89     8     8     84 #> 90    10     8     93 #> 91    12     8    110 #> 92    14     8    116 #> 93    16     8    126 #> 94    18     8    134 #> 95    20     8    125 #> 96     0     9     42 #> 97     2     9     51 #> 98     4     9     59 #> 99     6     9     68 #> 100    8     9     85 #> 101   10     9     96 #> 102   12     9     90 #> 103   14     9     92 #> 104   16     9     93 #> 105   18     9    100 #> 106   20     9    100 #> 107   21     9     98 #> 108    0    10     41 #> 109    2    10     44 #> 110    4    10     52 #> 111    6    10     63 #> 112    8    10     74 #> 113   10    10     81 #> 114   12    10     89 #> 115   14    10     96 #> 116   16    10    101 #> 117   18    10    112 #> 118   20    10    120 #> 119   21    10    124 #> 120    0    11     43 #> 121    2    11     51 #> 122    4    11     63 #> 123    6    11     84 #> 124    8    11    112 #> 125   10    11    139 #> 126   12    11    168 #> 127   14    11    177 #> 128   16    11    182 #> 129   18    11    184 #> 130   20    11    181 #> 131   21    11    175 #> 132    0    12     41 #> 133    2    12     49 #> 134    4    12     56 #> 135    6    12     62 #> 136    8    12     72 #> 137   10    12     88 #> 138   12    12    119 #> 139   14    12    135 #> 140   16    12    162 #> 141   18    12    185 #> 142   20    12    195 #> 143   21    12    205 #> 144    0    13     41 #> 145    2    13     48 #> 146    4    13     53 #> 147    6    13     60 #> 148    8    13     65 #> 149   10    13     67 #> 150   12    13     71 #> 151   14    13     70 #> 152   16    13     71 #> 153   18    13     81 #> 154   20    13     91 #> 155   21    13     96 #> 156    0    14     41 #> 157    2    14     49 #> 158    4    14     62 #> 159    6    14     79 #> 160    8    14    101 #> 161   10    14    128 #> 162   12    14    164 #> 163   14    14    192 #> 164   16    14    227 #> 165   18    14    248 #> 166   20    14    259 #> 167   21    14    266 #> 168    0    15     41 #> 169    2    15     49 #> 170    4    15     56 #> 171    6    15     64 #> 172    8    15     68 #> 173   10    15     68 #> 174   12    15     67 #> 175   14    15     68 #> 176    0    16     41 #> 177    2    16     45 #> 178    4    16     49 #> 179    6    16     51 #> 180    8    16     57 #> 181   10    16     51 #> 182   12    16     54 #> 183    0    17     42 #> 184    2    17     51 #> 185    4    17     61 #> 186    6    17     72 #> 187    8    17     83 #> 188   10    17     89 #> 189   12    17     98 #> 190   14    17    103 #> 191   16    17    113 #> 192   18    17    123 #> 193   20    17    133 #> 194   21    17    142 #> 195    0    18     39 #> 196    2    18     35 #> 197    0    19     43 #> 198    2    19     48 #> 199    4    19     55 #> 200    6    19     62 #> 201    8    19     65 #> 202   10    19     71 #> 203   12    19     82 #> 204   14    19     88 #> 205   16    19    106 #> 206   18    19    120 #> 207   20    19    144 #> 208   21    19    157 #> 209    0    20     41 #> 210    2    20     47 #> 211    4    20     54 #> 212    6    20     58 #> 213    8    20     65 #> 214   10    20     73 #> 215   12    20     77 #> 216   14    20     89 #> 217   16    20     98 #> 218   18    20    107 #> 219   20    20    115 #> 220   21    20    117 #> 221    0    21     40 #> 222    2    21     50 #> 223    4    21     62 #> 224    6    21     86 #> 225    8    21    125 #> 226   10    21    163 #> 227   12    21    217 #> 228   14    21    240 #> 229   16    21    275 #> 230   18    21    307 #> 231   20    21    318 #> 232   21    21    331 #> 233    0    22     41 #> 234    2    22     55 #> 235    4    22     64 #> 236    6    22     77 #> 237    8    22     90 #> 238   10    22     95 #> 239   12    22    108 #> 240   14    22    111 #> 241   16    22    131 #> 242   18    22    148 #> 243   20    22    164 #> 244   21    22    167 #> 245    0    23     43 #> 246    2    23     52 #> 247    4    23     61 #> 248    6    23     73 #> 249    8    23     90 #> 250   10    23    103 #> 251   12    23    127 #> 252   14    23    135 #> 253   16    23    145 #> 254   18    23    163 #> 255   20    23    170 #> 256   21    23    175 #> 257    0    24     42 #> 258    2    24     52 #> 259    4    24     58 #> 260    6    24     74 #> 261    8    24     66 #> 262   10    24     68 #> 263   12    24     70 #> 264   14    24     71 #> 265   16    24     72 #> 266   18    24     72 #> 267   20    24     76 #> 268   21    24     74 #> 269    0    25     40 #> 270    2    25     49 #> 271    4    25     62 #> 272    6    25     78 #> 273    8    25    102 #> 274   10    25    124 #> 275   12    25    146 #> 276   14    25    164 #> 277   16    25    197 #> 278   18    25    231 #> 279   20    25    259 #> 280   21    25    265 #> 281    0    26     42 #> 282    2    26     48 #> 283    4    26     57 #> 284    6    26     74 #> 285    8    26     93 #> 286   10    26    114 #> 287   12    26    136 #> 288   14    26    147 #> 289   16    26    169 #> 290   18    26    205 #> 291   20    26    236 #> 292   21    26    251 #> 293    0    27     39 #> 294    2    27     46 #> 295    4    27     58 #> 296    6    27     73 #> 297    8    27     87 #> 298   10    27    100 #> 299   12    27    115 #> 300   14    27    123 #> 301   16    27    144 #> 302   18    27    163 #> 303   20    27    185 #> 304   21    27    192 #> 305    0    28     39 #> 306    2    28     46 #> 307    4    28     58 #> 308    6    28     73 #> 309    8    28     92 #> 310   10    28    114 #> 311   12    28    145 #> 312   14    28    156 #> 313   16    28    184 #> 314   18    28    207 #> 315   20    28    212 #> 316   21    28    233 #> 317    0    29     39 #> 318    2    29     48 #> 319    4    29     59 #> 320    6    29     74 #> 321    8    29     87 #> 322   10    29    106 #> 323   12    29    134 #> 324   14    29    150 #> 325   16    29    187 #> 326   18    29    230 #> 327   20    29    279 #> 328   21    29    309 #> 329    0    30     42 #> 330    2    30     48 #> 331    4    30     59 #> 332    6    30     72 #> 333    8    30     85 #> 334   10    30     98 #> 335   12    30    115 #> 336   14    30    122 #> 337   16    30    143 #> 338   18    30    151 #> 339   20    30    157 #> 340   21    30    150 #> 341    0    31     42 #> 342    2    31     53 #> 343    4    31     62 #> 344    6    31     73 #> 345    8    31     85 #> 346   10    31    102 #> 347   12    31    123 #> 348   14    31    138 #> 349   16    31    170 #> 350   18    31    204 #> 351   20    31    235 #> 352   21    31    256 #> 353    0    32     41 #> 354    2    32     49 #> 355    4    32     65 #> 356    6    32     82 #> 357    8    32    107 #> 358   10    32    129 #> 359   12    32    159 #> 360   14    32    179 #> 361   16    32    221 #> 362   18    32    263 #> 363   20    32    291 #> 364   21    32    305 #> 365    0    33     39 #> 366    2    33     50 #> 367    4    33     63 #> 368    6    33     77 #> 369    8    33     96 #> 370   10    33    111 #> 371   12    33    137 #> 372   14    33    144 #> 373   16    33    151 #> 374   18    33    146 #> 375   20    33    156 #> 376   21    33    147 #> 377    0    34     41 #> 378    2    34     49 #> 379    4    34     63 #> 380    6    34     85 #> 381    8    34    107 #> 382   10    34    134 #> 383   12    34    164 #> 384   14    34    186 #> 385   16    34    235 #> 386   18    34    294 #> 387   20    34    327 #> 388   21    34    341 #> 389    0    35     41 #> 390    2    35     53 #> 391    4    35     64 #> 392    6    35     87 #> 393    8    35    123 #> 394   10    35    158 #> 395   12    35    201 #> 396   14    35    238 #> 397   16    35    287 #> 398   18    35    332 #> 399   20    35    361 #> 400   21    35    373 #> 401    0    36     39 #> 402    2    36     48 #> 403    4    36     61 #> 404    6    36     76 #> 405    8    36     98 #> 406   10    36    116 #> 407   12    36    145 #> 408   14    36    166 #> 409   16    36    198 #> 410   18    36    227 #> 411   20    36    225 #> 412   21    36    220 #> 413    0    37     41 #> 414    2    37     48 #> 415    4    37     56 #> 416    6    37     68 #> 417    8    37     80 #> 418   10    37     83 #> 419   12    37    103 #> 420   14    37    112 #> 421   16    37    135 #> 422   18    37    157 #> 423   20    37    169 #> 424   21    37    178 #> 425    0    38     41 #> 426    2    38     49 #> 427    4    38     61 #> 428    6    38     74 #> 429    8    38     98 #> 430   10    38    109 #> 431   12    38    128 #> 432   14    38    154 #> 433   16    38    192 #> 434   18    38    232 #> 435   20    38    280 #> 436   21    38    290 #> 437    0    39     42 #> 438    2    39     50 #> 439    4    39     61 #> 440    6    39     78 #> 441    8    39     89 #> 442   10    39    109 #> 443   12    39    130 #> 444   14    39    146 #> 445   16    39    170 #> 446   18    39    214 #> 447   20    39    250 #> 448   21    39    272 #> 449    0    40     41 #> 450    2    40     55 #> 451    4    40     66 #> 452    6    40     79 #> 453    8    40    101 #> 454   10    40    120 #> 455   12    40    154 #> 456   14    40    182 #> 457   16    40    215 #> 458   18    40    262 #> 459   20    40    295 #> 460   21    40    321 #> 461    0    41     42 #> 462    2    41     51 #> 463    4    41     66 #> 464    6    41     85 #> 465    8    41    103 #> 466   10    41    124 #> 467   12    41    155 #> 468   14    41    153 #> 469   16    41    175 #> 470   18    41    184 #> 471   20    41    199 #> 472   21    41    204 #> 473    0    42     42 #> 474    2    42     49 #> 475    4    42     63 #> 476    6    42     84 #> 477    8    42    103 #> 478   10    42    126 #> 479   12    42    160 #> 480   14    42    174 #> 481   16    42    204 #> 482   18    42    234 #> 483   20    42    269 #> 484   21    42    281 #> 485    0    43     42 #> 486    2    43     55 #> 487    4    43     69 #> 488    6    43     96 #> 489    8    43    131 #> 490   10    43    157 #> 491   12    43    184 #> 492   14    43    188 #> 493   16    43    197 #> 494   18    43    198 #> 495   20    43    199 #> 496   21    43    200 #> 497    0    44     42 #> 498    2    44     51 #> 499    4    44     65 #> 500    6    44     86 #> 501    8    44    103 #> 502   10    44    118 #> 503   12    44    127 #> 504   14    44    138 #> 505   16    44    145 #> 506   18    44    146 #> 507    0    45     41 #> 508    2    45     50 #> 509    4    45     61 #> 510    6    45     78 #> 511    8    45     98 #> 512   10    45    117 #> 513   12    45    135 #> 514   14    45    141 #> 515   16    45    147 #> 516   18    45    174 #> 517   20    45    197 #> 518   21    45    196 #> 519    0    46     40 #> 520    2    46     52 #> 521    4    46     62 #> 522    6    46     82 #> 523    8    46    101 #> 524   10    46    120 #> 525   12    46    144 #> 526   14    46    156 #> 527   16    46    173 #> 528   18    46    210 #> 529   20    46    231 #> 530   21    46    238 #> 531    0    47     41 #> 532    2    47     53 #> 533    4    47     66 #> 534    6    47     79 #> 535    8    47    100 #> 536   10    47    123 #> 537   12    47    148 #> 538   14    47    157 #> 539   16    47    168 #> 540   18    47    185 #> 541   20    47    210 #> 542   21    47    205 #> 543    0    48     39 #> 544    2    48     50 #> 545    4    48     62 #> 546    6    48     80 #> 547    8    48    104 #> 548   10    48    125 #> 549   12    48    154 #> 550   14    48    170 #> 551   16    48    222 #> 552   18    48    261 #> 553   20    48    303 #> 554   21    48    322 #> 555    0    49     40 #> 556    2    49     53 #> 557    4    49     64 #> 558    6    49     85 #> 559    8    49    108 #> 560   10    49    128 #> 561   12    49    152 #> 562   14    49    166 #> 563   16    49    184 #> 564   18    49    203 #> 565   20    49    233 #> 566   21    49    237 #> 567    0    50     41 #> 568    2    50     54 #> 569    4    50     67 #> 570    6    50     84 #> 571    8    50    105 #> 572   10    50    122 #> 573   12    50    155 #> 574   14    50    175 #> 575   16    50    205 #> 576   18    50    234 #> 577   20    50    264 #> 578   21    50    264 #>   # ways to get data for subsets records(db)[c(1, 2)] #> $Chick #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4 #>  #> $Time_Chick #>     Time Chick weight #> 1      0     1     42 #> 2      2     1     51 #> 3      4     1     59 #> 4      6     1     64 #> 5      8     1     76 #> 6     10     1     93 #> 7     12     1    106 #> 8     14     1    125 #> 9     16     1    149 #> 10    18     1    171 #> 11    20     1    199 #> 12    21     1    205 #> 13     0     2     40 #> 14     2     2     49 #> 15     4     2     58 #> 16     6     2     72 #> 17     8     2     84 #> 18    10     2    103 #> 19    12     2    122 #> 20    14     2    138 #> 21    16     2    162 #> 22    18     2    187 #> 23    20     2    209 #> 24    21     2    215 #> 25     0     3     43 #> 26     2     3     39 #> 27     4     3     55 #> 28     6     3     67 #> 29     8     3     84 #> 30    10     3     99 #> 31    12     3    115 #> 32    14     3    138 #> 33    16     3    163 #> 34    18     3    187 #> 35    20     3    198 #> 36    21     3    202 #> 37     0     4     42 #> 38     2     4     49 #> 39     4     4     56 #> 40     6     4     67 #> 41     8     4     74 #> 42    10     4     87 #> 43    12     4    102 #> 44    14     4    108 #> 45    16     4    136 #> 46    18     4    154 #> 47    20     4    160 #> 48    21     4    157 #> 49     0     5     41 #> 50     2     5     42 #> 51     4     5     48 #> 52     6     5     60 #> 53     8     5     79 #> 54    10     5    106 #> 55    12     5    141 #> 56    14     5    164 #> 57    16     5    197 #> 58    18     5    199 #> 59    20     5    220 #> 60    21     5    223 #> 61     0     6     41 #> 62     2     6     49 #> 63     4     6     59 #> 64     6     6     74 #> 65     8     6     97 #> 66    10     6    124 #> 67    12     6    141 #> 68    14     6    148 #> 69    16     6    155 #> 70    18     6    160 #> 71    20     6    160 #> 72    21     6    157 #> 73     0     7     41 #> 74     2     7     49 #> 75     4     7     57 #> 76     6     7     71 #> 77     8     7     89 #> 78    10     7    112 #> 79    12     7    146 #> 80    14     7    174 #> 81    16     7    218 #> 82    18     7    250 #> 83    20     7    288 #> 84    21     7    305 #> 85     0     8     42 #> 86     2     8     50 #> 87     4     8     61 #> 88     6     8     71 #> 89     8     8     84 #> 90    10     8     93 #> 91    12     8    110 #> 92    14     8    116 #> 93    16     8    126 #> 94    18     8    134 #> 95    20     8    125 #> 96     0     9     42 #> 97     2     9     51 #> 98     4     9     59 #> 99     6     9     68 #> 100    8     9     85 #> 101   10     9     96 #> 102   12     9     90 #> 103   14     9     92 #> 104   16     9     93 #> 105   18     9    100 #> 106   20     9    100 #> 107   21     9     98 #> 108    0    10     41 #> 109    2    10     44 #> 110    4    10     52 #> 111    6    10     63 #> 112    8    10     74 #> 113   10    10     81 #> 114   12    10     89 #> 115   14    10     96 #> 116   16    10    101 #> 117   18    10    112 #> 118   20    10    120 #> 119   21    10    124 #> 120    0    11     43 #> 121    2    11     51 #> 122    4    11     63 #> 123    6    11     84 #> 124    8    11    112 #> 125   10    11    139 #> 126   12    11    168 #> 127   14    11    177 #> 128   16    11    182 #> 129   18    11    184 #> 130   20    11    181 #> 131   21    11    175 #> 132    0    12     41 #> 133    2    12     49 #> 134    4    12     56 #> 135    6    12     62 #> 136    8    12     72 #> 137   10    12     88 #> 138   12    12    119 #> 139   14    12    135 #> 140   16    12    162 #> 141   18    12    185 #> 142   20    12    195 #> 143   21    12    205 #> 144    0    13     41 #> 145    2    13     48 #> 146    4    13     53 #> 147    6    13     60 #> 148    8    13     65 #> 149   10    13     67 #> 150   12    13     71 #> 151   14    13     70 #> 152   16    13     71 #> 153   18    13     81 #> 154   20    13     91 #> 155   21    13     96 #> 156    0    14     41 #> 157    2    14     49 #> 158    4    14     62 #> 159    6    14     79 #> 160    8    14    101 #> 161   10    14    128 #> 162   12    14    164 #> 163   14    14    192 #> 164   16    14    227 #> 165   18    14    248 #> 166   20    14    259 #> 167   21    14    266 #> 168    0    15     41 #> 169    2    15     49 #> 170    4    15     56 #> 171    6    15     64 #> 172    8    15     68 #> 173   10    15     68 #> 174   12    15     67 #> 175   14    15     68 #> 176    0    16     41 #> 177    2    16     45 #> 178    4    16     49 #> 179    6    16     51 #> 180    8    16     57 #> 181   10    16     51 #> 182   12    16     54 #> 183    0    17     42 #> 184    2    17     51 #> 185    4    17     61 #> 186    6    17     72 #> 187    8    17     83 #> 188   10    17     89 #> 189   12    17     98 #> 190   14    17    103 #> 191   16    17    113 #> 192   18    17    123 #> 193   20    17    133 #> 194   21    17    142 #> 195    0    18     39 #> 196    2    18     35 #> 197    0    19     43 #> 198    2    19     48 #> 199    4    19     55 #> 200    6    19     62 #> 201    8    19     65 #> 202   10    19     71 #> 203   12    19     82 #> 204   14    19     88 #> 205   16    19    106 #> 206   18    19    120 #> 207   20    19    144 #> 208   21    19    157 #> 209    0    20     41 #> 210    2    20     47 #> 211    4    20     54 #> 212    6    20     58 #> 213    8    20     65 #> 214   10    20     73 #> 215   12    20     77 #> 216   14    20     89 #> 217   16    20     98 #> 218   18    20    107 #> 219   20    20    115 #> 220   21    20    117 #> 221    0    21     40 #> 222    2    21     50 #> 223    4    21     62 #> 224    6    21     86 #> 225    8    21    125 #> 226   10    21    163 #> 227   12    21    217 #> 228   14    21    240 #> 229   16    21    275 #> 230   18    21    307 #> 231   20    21    318 #> 232   21    21    331 #> 233    0    22     41 #> 234    2    22     55 #> 235    4    22     64 #> 236    6    22     77 #> 237    8    22     90 #> 238   10    22     95 #> 239   12    22    108 #> 240   14    22    111 #> 241   16    22    131 #> 242   18    22    148 #> 243   20    22    164 #> 244   21    22    167 #> 245    0    23     43 #> 246    2    23     52 #> 247    4    23     61 #> 248    6    23     73 #> 249    8    23     90 #> 250   10    23    103 #> 251   12    23    127 #> 252   14    23    135 #> 253   16    23    145 #> 254   18    23    163 #> 255   20    23    170 #> 256   21    23    175 #> 257    0    24     42 #> 258    2    24     52 #> 259    4    24     58 #> 260    6    24     74 #> 261    8    24     66 #> 262   10    24     68 #> 263   12    24     70 #> 264   14    24     71 #> 265   16    24     72 #> 266   18    24     72 #> 267   20    24     76 #> 268   21    24     74 #> 269    0    25     40 #> 270    2    25     49 #> 271    4    25     62 #> 272    6    25     78 #> 273    8    25    102 #> 274   10    25    124 #> 275   12    25    146 #> 276   14    25    164 #> 277   16    25    197 #> 278   18    25    231 #> 279   20    25    259 #> 280   21    25    265 #> 281    0    26     42 #> 282    2    26     48 #> 283    4    26     57 #> 284    6    26     74 #> 285    8    26     93 #> 286   10    26    114 #> 287   12    26    136 #> 288   14    26    147 #> 289   16    26    169 #> 290   18    26    205 #> 291   20    26    236 #> 292   21    26    251 #> 293    0    27     39 #> 294    2    27     46 #> 295    4    27     58 #> 296    6    27     73 #> 297    8    27     87 #> 298   10    27    100 #> 299   12    27    115 #> 300   14    27    123 #> 301   16    27    144 #> 302   18    27    163 #> 303   20    27    185 #> 304   21    27    192 #> 305    0    28     39 #> 306    2    28     46 #> 307    4    28     58 #> 308    6    28     73 #> 309    8    28     92 #> 310   10    28    114 #> 311   12    28    145 #> 312   14    28    156 #> 313   16    28    184 #> 314   18    28    207 #> 315   20    28    212 #> 316   21    28    233 #> 317    0    29     39 #> 318    2    29     48 #> 319    4    29     59 #> 320    6    29     74 #> 321    8    29     87 #> 322   10    29    106 #> 323   12    29    134 #> 324   14    29    150 #> 325   16    29    187 #> 326   18    29    230 #> 327   20    29    279 #> 328   21    29    309 #> 329    0    30     42 #> 330    2    30     48 #> 331    4    30     59 #> 332    6    30     72 #> 333    8    30     85 #> 334   10    30     98 #> 335   12    30    115 #> 336   14    30    122 #> 337   16    30    143 #> 338   18    30    151 #> 339   20    30    157 #> 340   21    30    150 #> 341    0    31     42 #> 342    2    31     53 #> 343    4    31     62 #> 344    6    31     73 #> 345    8    31     85 #> 346   10    31    102 #> 347   12    31    123 #> 348   14    31    138 #> 349   16    31    170 #> 350   18    31    204 #> 351   20    31    235 #> 352   21    31    256 #> 353    0    32     41 #> 354    2    32     49 #> 355    4    32     65 #> 356    6    32     82 #> 357    8    32    107 #> 358   10    32    129 #> 359   12    32    159 #> 360   14    32    179 #> 361   16    32    221 #> 362   18    32    263 #> 363   20    32    291 #> 364   21    32    305 #> 365    0    33     39 #> 366    2    33     50 #> 367    4    33     63 #> 368    6    33     77 #> 369    8    33     96 #> 370   10    33    111 #> 371   12    33    137 #> 372   14    33    144 #> 373   16    33    151 #> 374   18    33    146 #> 375   20    33    156 #> 376   21    33    147 #> 377    0    34     41 #> 378    2    34     49 #> 379    4    34     63 #> 380    6    34     85 #> 381    8    34    107 #> 382   10    34    134 #> 383   12    34    164 #> 384   14    34    186 #> 385   16    34    235 #> 386   18    34    294 #> 387   20    34    327 #> 388   21    34    341 #> 389    0    35     41 #> 390    2    35     53 #> 391    4    35     64 #> 392    6    35     87 #> 393    8    35    123 #> 394   10    35    158 #> 395   12    35    201 #> 396   14    35    238 #> 397   16    35    287 #> 398   18    35    332 #> 399   20    35    361 #> 400   21    35    373 #> 401    0    36     39 #> 402    2    36     48 #> 403    4    36     61 #> 404    6    36     76 #> 405    8    36     98 #> 406   10    36    116 #> 407   12    36    145 #> 408   14    36    166 #> 409   16    36    198 #> 410   18    36    227 #> 411   20    36    225 #> 412   21    36    220 #> 413    0    37     41 #> 414    2    37     48 #> 415    4    37     56 #> 416    6    37     68 #> 417    8    37     80 #> 418   10    37     83 #> 419   12    37    103 #> 420   14    37    112 #> 421   16    37    135 #> 422   18    37    157 #> 423   20    37    169 #> 424   21    37    178 #> 425    0    38     41 #> 426    2    38     49 #> 427    4    38     61 #> 428    6    38     74 #> 429    8    38     98 #> 430   10    38    109 #> 431   12    38    128 #> 432   14    38    154 #> 433   16    38    192 #> 434   18    38    232 #> 435   20    38    280 #> 436   21    38    290 #> 437    0    39     42 #> 438    2    39     50 #> 439    4    39     61 #> 440    6    39     78 #> 441    8    39     89 #> 442   10    39    109 #> 443   12    39    130 #> 444   14    39    146 #> 445   16    39    170 #> 446   18    39    214 #> 447   20    39    250 #> 448   21    39    272 #> 449    0    40     41 #> 450    2    40     55 #> 451    4    40     66 #> 452    6    40     79 #> 453    8    40    101 #> 454   10    40    120 #> 455   12    40    154 #> 456   14    40    182 #> 457   16    40    215 #> 458   18    40    262 #> 459   20    40    295 #> 460   21    40    321 #> 461    0    41     42 #> 462    2    41     51 #> 463    4    41     66 #> 464    6    41     85 #> 465    8    41    103 #> 466   10    41    124 #> 467   12    41    155 #> 468   14    41    153 #> 469   16    41    175 #> 470   18    41    184 #> 471   20    41    199 #> 472   21    41    204 #> 473    0    42     42 #> 474    2    42     49 #> 475    4    42     63 #> 476    6    42     84 #> 477    8    42    103 #> 478   10    42    126 #> 479   12    42    160 #> 480   14    42    174 #> 481   16    42    204 #> 482   18    42    234 #> 483   20    42    269 #> 484   21    42    281 #> 485    0    43     42 #> 486    2    43     55 #> 487    4    43     69 #> 488    6    43     96 #> 489    8    43    131 #> 490   10    43    157 #> 491   12    43    184 #> 492   14    43    188 #> 493   16    43    197 #> 494   18    43    198 #> 495   20    43    199 #> 496   21    43    200 #> 497    0    44     42 #> 498    2    44     51 #> 499    4    44     65 #> 500    6    44     86 #> 501    8    44    103 #> 502   10    44    118 #> 503   12    44    127 #> 504   14    44    138 #> 505   16    44    145 #> 506   18    44    146 #> 507    0    45     41 #> 508    2    45     50 #> 509    4    45     61 #> 510    6    45     78 #> 511    8    45     98 #> 512   10    45    117 #> 513   12    45    135 #> 514   14    45    141 #> 515   16    45    147 #> 516   18    45    174 #> 517   20    45    197 #> 518   21    45    196 #> 519    0    46     40 #> 520    2    46     52 #> 521    4    46     62 #> 522    6    46     82 #> 523    8    46    101 #> 524   10    46    120 #> 525   12    46    144 #> 526   14    46    156 #> 527   16    46    173 #> 528   18    46    210 #> 529   20    46    231 #> 530   21    46    238 #> 531    0    47     41 #> 532    2    47     53 #> 533    4    47     66 #> 534    6    47     79 #> 535    8    47    100 #> 536   10    47    123 #> 537   12    47    148 #> 538   14    47    157 #> 539   16    47    168 #> 540   18    47    185 #> 541   20    47    210 #> 542   21    47    205 #> 543    0    48     39 #> 544    2    48     50 #> 545    4    48     62 #> 546    6    48     80 #> 547    8    48    104 #> 548   10    48    125 #> 549   12    48    154 #> 550   14    48    170 #> 551   16    48    222 #> 552   18    48    261 #> 553   20    48    303 #> 554   21    48    322 #> 555    0    49     40 #> 556    2    49     53 #> 557    4    49     64 #> 558    6    49     85 #> 559    8    49    108 #> 560   10    49    128 #> 561   12    49    152 #> 562   14    49    166 #> 563   16    49    184 #> 564   18    49    203 #> 565   20    49    233 #> 566   21    49    237 #> 567    0    50     41 #> 568    2    50     54 #> 569    4    50     67 #> 570    6    50     84 #> 571    8    50    105 #> 572   10    50    122 #> 573   12    50    155 #> 574   14    50    175 #> 575   16    50    205 #> 576   18    50    234 #> 577   20    50    264 #> 578   21    50    264 #>  records(db)[[1]] #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4 records(db)$Chick #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4  # subsetting first isn't recommended: removes foreign key # reference as mentions, and you need to subset again anyway records(db[[1]])[[1]] #>     Chick Diet #> 1       1    1 #> 13      2    1 #> 25      3    1 #> 37      4    1 #> 49      5    1 #> 61      6    1 #> 73      7    1 #> 85      8    1 #> 96      9    1 #> 108    10    1 #> 120    11    1 #> 132    12    1 #> 144    13    1 #> 156    14    1 #> 168    15    1 #> 176    16    1 #> 183    17    1 #> 195    18    1 #> 197    19    1 #> 209    20    1 #> 221    21    2 #> 233    22    2 #> 245    23    2 #> 257    24    2 #> 269    25    2 #> 281    26    2 #> 293    27    2 #> 305    28    2 #> 317    29    2 #> 329    30    2 #> 341    31    3 #> 353    32    3 #> 365    33    3 #> 377    34    3 #> 389    35    3 #> 401    36    3 #> 413    37    3 #> 425    38    3 #> 437    39    3 #> 449    40    3 #> 461    41    4 #> 473    42    4 #> 485    43    4 #> 497    44    4 #> 507    45    4 #> 519    46    4 #> 531    47    4 #> 543    48    4 #> 555    49    4 #> 567    50    4"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove database relations not linked to the main relations — reduce.database","title":"Remove database relations not linked to the main relations — reduce.database","text":"Filters database's relations, keeping main relations, considered ancestors via foreign key references. Foreign key references involving removed relations also removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove database relations not linked to the main relations — reduce.database","text":"","code":"# S3 method for class 'database' reduce(x, main, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove database relations not linked to the main relations — reduce.database","text":"x database, whose relations filtered. main character vector, containing names relations considered \"main\" relations. missing, taken names relations largest record count. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove database relations not linked to the main relations — reduce.database","text":"database, auxiliary relations foreign key references removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove database relations not linked to the main relations — reduce.database","text":"main relations considered relations largest number records. Using rejoin database resulting reduce likely fail return incomplete results.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove database schema relations not linked to the given relations — reduce.database_schema","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"Filters database schema's relations, keeping given relations, considered ancestors via foreign key references. Foreign key references involving removed relations also removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"","code":"# S3 method for class 'database_schema' reduce(x, main, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"x database schema, whose relations filtered. main character vector, containing names relations considered \"main\" relations. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"database schema, auxiliary relations foreign key references removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.database_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove database schema relations not linked to the given relations — reduce.database_schema","text":"method takes given set main relations, rather inferring . Using rejoin database resulting decomposing data frame reduced schema likely fail return incomplete results.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove relations not linked to the main relations — reduce","title":"Remove relations not linked to the main relations — reduce","text":"Filters object's relations, keeping main relations, considered ancestors via foreign key references. Foreign key references involving removed relations also removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove relations not linked to the main relations — reduce","text":"","code":"reduce(x, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove relations not linked to the main relations — reduce","text":"x object whose relations filtered. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove relations not linked to the main relations — reduce","text":"object class x, auxiliary relations foreign key references removed.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/reduce.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove relations not linked to the main relations — reduce","text":"Details main tables chosen given individual methods. function mostly intended simplifying database, database schema, purposes exploration, particularly examining plots. filtering might remove important auxiliary relations, also likely remove based spurious dependencies, databases can contain many.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/references.html","id":null,"dir":"Reference","previous_headings":"","what":"Schema references — references","title":"Schema references — references","text":"Generic function, returning present (foreign key) references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/references.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Schema references — references","text":"","code":"references(x, ...)  references(x) <- value"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/references.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Schema references — references","text":"x R object references, database_schema database object. ... arguments passed methods. value list, length references(x, ...).","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/references.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Schema references — references","text":"list, giving references.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":null,"dir":"Reference","previous_headings":"","what":"Join a database into a data frame — rejoin","title":"Join a database into a data frame — rejoin","text":"Rejoins relations database single data frame, possible. inverse calling autodb, except rows might returned different order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join a database into a data frame — rejoin","text":"","code":"rejoin(database)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join a database into a data frame — rejoin","text":"database database containing data rejoined, returned decompose.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Join a database into a data frame — rejoin","text":"data frame, containing information contained database lossless self-consistent.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Join a database into a data frame — rejoin","text":"rejoining algorithm might use given relations: begins relation largest number records, joins enough relations contain present attributes. limited relations starting relation linked foreign keys, limited either, since cases constraint make impossible rejoin present attributes. Since algorithm may use given relations, algorithm may ignore types database inconsistency, different relations hold data inconsistent . case, rejoining lossy. Rejoining results reduce can also lossy. Due issues, algorithm changed use relations future. databases can represented single data frame. simple example database attribute name used several difference sources data, since rejoining results inappropriate merges.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rejoin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Join a database into a data frame — rejoin","text":"","code":"# simple example db <- autodb(ChickWeight) rj <- rejoin(db) rj <- rj[order(as.integer(rownames(rj))), ] all(rj == ChickWeight) # TRUE #> [1] TRUE  # showing rejoin() doesn't check for inconsistency: # add another Chick table with the diets swapped db2 <- db[c(1, 2, 1)] records(db2)[[3]]$Diet <- rev(records(db2)[[3]]$Diet) rj2 <- rejoin(db2) rj2 <- rj2[order(as.integer(rownames(rj2))), ] all(rj2 == ChickWeight) # TRUE #> [1] TRUE"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":null,"dir":"Reference","previous_headings":"","what":"Relation vectors — relation","title":"Relation vectors — relation","text":"Creates set relation schemas, including relation's attributes candidate keys.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relation vectors — relation","text":"","code":"relation(relations, attrs_order)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relation vectors — relation","text":"relations named list relations, form two-element lists: first element contains data frame, column names attributes associated schema, second element contains list character vectors, representing candidate key. attrs_order character vector, giving names attributes. need present schemas, attributes schemas must present attrs_order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relation vectors — relation","text":"relation object, containing list given relations, attrs_order stored attribute name. Relation schemas returned keys' attributes sorted according attribute order attrs_order, keys sorted priority order. Attributes data frame also sorted, first order appearance sorted keys, order attrs_order non-prime attributes.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relation vectors — relation","text":"Relation vectors unlikely needed user directly, since essentially database objects foreign key references. mostly used mirror use vector-like relation_schema class database_schema class wrapper around. makes creating database relation_schema two-step process, two steps can done either order: creation create insert, adding references database_schema database. Duplicate schemas, ordering attribute, allowed, can removed unique. several sets relation schemas concatenated, attrs_order attributes merged, preserve original attribute orders, possible. possible, orderings disagree, returned value attrs_order attribute union instead.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relation vectors — relation","text":"","code":"rels <- relation(   list(     a = list(       df = data.frame(a = logical(), b = logical()),       keys = list(\"a\")     ),     b = list(       df = data.frame(b = logical(), c = logical()),       keys = list(\"b\", \"c\")     )   ),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) print(rels) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c records(rels) #> $a #> [1] a b #> <0 rows> (or 0-length row.names) #>  #> $b #> [1] b c #> <0 rows> (or 0-length row.names) #>  attrs(rels) #> $a #> [1] \"a\" \"b\" #>  #> $b #> [1] \"b\" \"c\" #>  stopifnot(identical(   attrs(rels),   lapply(records(rels), names) )) keys(rels) #> $a #> $a[[1]] #> [1] \"a\" #>  #>  #> $b #> $b[[1]] #> [1] \"b\" #>  #> $b[[2]] #> [1] \"c\" #>  #>  attrs_order(rels) #> [1] \"a\" \"b\" \"c\" \"d\" names(rels) #> [1] \"a\" \"b\"  # inserting data insert(rels, data.frame(a = 1L, b = 2L, c = 3L, d = 4L)) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c # data is only inserted into relations where all columns are given... insert(rels, data.frame(a = 1L, b = 2L, c = 3L)) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 1 record #>   key 1: b #>   key 2: c # and that are listed in relations argument insert(   rels,   data.frame(a = 1L, b = 2L, c = 3L, d = 4L),   relations = \"a\" ) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 1 record #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c  # vector operations rels2 <- relation(   list(     e = list(       df = data.frame(a = logical(), e = logical()),       keys = list(\"e\")     )   ),   attrs_order = c(\"a\", \"e\") ) c(rels, rels2) # attrs_order attributes are merged #> 3 relations #> 5 attributes: a, b, c, d, e #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation e: e, a; 0 records #>   key 1: e unique(c(rels, rels)) #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c  # subsetting rels[1] #> 1 relation #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a rels[c(1, 2, 1)] #> 3 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: b, c; 0 records #>   key 1: b #>   key 2: c #> relation a.1: a, b; 0 records #>   key 1: a stopifnot(identical(rels[[1]], rels[1]))  # reassignment rels3 <- rels rels3[2] <- relation(   list(     d = list(       df = data.frame(d = logical(), c = logical()),       keys = list(\"d\")     )   ),   attrs_order(rels3) ) print(rels3) # note the relation's name doesn't change #> 2 relations #> 4 attributes: a, b, c, d #> relation a: a, b; 0 records #>   key 1: a #> relation b: d, c; 0 records #>   key 1: d # names(rels3)[2] <- \"d\" # this would change the name keys(rels3)[[2]] <- list(character()) # removing keys first... # for a relation_schema, we could then change the attrs for # the second relation. For a created relation, this is not # allowed. if (FALSE) { # \\dontrun{   attrs(rels3)[[2]] <- c(\"b\", \"c\")   names(records(rels3)[[2]]) <- c(\"b\", \"c\") } # }  # changing appearance priority for attributes rels4 <- rels attrs_order(rels4) <- c(\"d\", \"c\", \"b\", \"a\") print(rels4) #> 2 relations #> 4 attributes: d, c, b, a #> relation a: a, b; 0 records #>   key 1: a #> relation b: c, b; 0 records #>   key 1: c #>   key 2: b  # reconstructing from components rels_recon <- relation(   Map(list, df = records(rels), keys = keys(rels)),   attrs_order(rels) ) stopifnot(identical(rels_recon, rels))  # can be a data frame column data.frame(id = 1:2, relation = rels) #>   id               relation #> 1  1 relation a (0 records) #> 2  2 relation b (0 records)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Relation schema vectors — relation_schema","title":"Relation schema vectors — relation_schema","text":"Creates set relation schemas, including relation's attributes candidate keys.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relation schema vectors — relation_schema","text":"","code":"relation_schema(schemas, attrs_order)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relation schema vectors — relation_schema","text":"schemas named list schemas, form two-element lists: first element contains character vector attributes relation schema, second element contains list character vectors, representing candidate key. attrs_order character vector, giving names attributes. need present schemas, attributes schemas must present attrs_order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relation schema vectors — relation_schema","text":"relation_schema object, containing list given schemas, attrs_order stored attribute name. Relation schemas returned keys' attributes sorted according attribute order attrs_order, keys sorted priority order. Attributes schema also sorted, first order appearance sorted keys, order attrs_order non-prime attributes.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relation schema vectors — relation_schema","text":"Duplicate schemas, ordering attribute, allowed, can removed \\code{\\link{unique}}. several sets relation schemas concatenated, attrs_order attributes merged, preserve original attribute orders, possible. possible, orderings disagree, returned value attrs_order attribute union instead.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/reference/relation_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relation schema vectors — relation_schema","text":"","code":"schemas <- relation_schema(   list(     a = list(c(\"a\", \"b\"), list(\"a\")),     b = list(c(\"b\", \"c\"), list(\"b\", \"c\"))   ),   attrs_order = c(\"a\", \"b\", \"c\", \"d\") ) print(schemas) #> 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c attrs(schemas) #> $a #> [1] \"a\" \"b\" #>  #> $b #> [1] \"b\" \"c\" #>  keys(schemas) #> $a #> $a[[1]] #> [1] \"a\" #>  #>  #> $b #> $b[[1]] #> [1] \"b\" #>  #> $b[[2]] #> [1] \"c\" #>  #>  attrs_order(schemas) #> [1] \"a\" \"b\" \"c\" \"d\" names(schemas) #> [1] \"a\" \"b\"  # vector operations schemas2 <- relation_schema(   list(     e = list(c(\"a\", \"e\"), list(\"e\"))   ),   attrs_order = c(\"a\", \"e\") ) c(schemas, schemas2) # attrs_order attributes are merged #> 3 relation schemas #> 5 attributes: a, b, c, d, e #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema e: e, a #>   key 1: e unique(c(schemas, schemas)) #> 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c  # subsetting schemas[1] #> 1 relation schema #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a schemas[c(1, 2, 1)] #> 3 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: b, c #>   key 1: b #>   key 2: c #> schema a.1: a, b #>   key 1: a stopifnot(identical(schemas[[1]], schemas[1]))  # reassignment schemas3 <- schemas schemas3[2] <- relation_schema(   list(d = list(c(\"d\", \"c\"), list(\"d\"))),   attrs_order(schemas3) ) print(schemas3) # note the schema's name doesn't change #> 2 relation schemas #> 4 attributes: a, b, c, d #> schema a: a, b #>   key 1: a #> schema b: d, c #>   key 1: d # names(schemas3)[2] <- \"d\" # this would change the name keys(schemas3)[[2]] <- list(character()) # removing keys first... attrs(schemas3)[[2]] <- c(\"b\", \"c\") # so we can change the attrs legally keys(schemas3)[[2]] <- list(\"b\", \"c\") # add the new keys stopifnot(identical(schemas3, schemas))  # changing appearance priority for attributes attrs_order(schemas3) <- c(\"d\", \"c\", \"b\", \"a\") print(schemas3) #> 2 relation schemas #> 4 attributes: d, c, b, a #> schema a: a, b #>   key 1: a #> schema b: c, b #>   key 1: c #>   key 2: b  # reconstructing from components schemas_recon <- relation_schema(   Map(list, attrs(schemas), keys(schemas)),   attrs_order(schemas) ) stopifnot(identical(schemas_recon, schemas))  # can be a data frame column data.frame(id = 1:2, schema = schemas) #>   id   schema #> 1  1 schema a #> 2  2 schema b"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":null,"dir":"Reference","previous_headings":"","what":"Rename relational data attributes — rename_attrs","title":"Rename relational data attributes — rename_attrs","text":"Generic function, renaming attributes present database-like structure.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rename relational data attributes — rename_attrs","text":"","code":"rename_attrs(x, names, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rename relational data attributes — rename_attrs","text":"x object attrs_order attribute. includes relational schema objects, relation_schema database_schema object, relational data objects, relation database object, functional_dependency objects. names character vector length attrs_order(x), duplicated elements, used new attribute names. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rename relational data attributes — rename_attrs","text":"relational object type x, attributes renamed consistently across whole object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/rename_attrs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rename relational data attributes — rename_attrs","text":"function different intended use re-assigning attrs_order: intended rearranging order attributes, without renaming . intended renaming attributes without re-ordering .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subrelations.html","id":null,"dir":"Reference","previous_headings":"","what":"Database subrelations — subrelations","title":"Database subrelations — subrelations","text":"Generic function, returning subrelations x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subrelations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Database subrelations — subrelations","text":"","code":"subrelations(x, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subrelations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Database subrelations — subrelations","text":"x R object, intended sort database-like object contains relations, database object. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subrelations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Database subrelations — subrelations","text":"relation-type object, list relation-type objects subrelation vectorised. example, x database, result contained relation.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subschemas.html","id":null,"dir":"Reference","previous_headings":"","what":"Schema subschemas — subschemas","title":"Schema subschemas — subschemas","text":"Generic function, returning subschemas x.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subschemas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Schema subschemas — subschemas","text":"","code":"subschemas(x, ...)"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subschemas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Schema subschemas — subschemas","text":"x R object, intended sort schema contains schemas, database_schema object. ... arguments passed methods.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/subschemas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Schema subschemas — subschemas","text":"schema-type object, list schema-type objects subschema vectorised. example, x database_schema, result contained relation_schema.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthesise relation schemas from functional dependencies — synthesise","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"Synthesises dependency relationships dependencies database schema satisfying least third normal form, using Bernstein's synthesis.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"","code":"synthesise(   dependencies,   ensure_lossless = TRUE,   reduce_attributes = TRUE,   remove_avoidable = FALSE,   constants_name = \"constants\",   progress = FALSE,   progress_file = \"\" )"},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"dependencies functional_dependency object, given discover. ensure_lossless logical, TRUE default. TRUE, decomposition lossless, extra relation added make decomposition lossless. reduce_attributes logical, TRUE default. TRUE, dependencies checked determinant attributes made redundant dependencies. redundant dependencies output discover, since redundant attributes. remove_avoidable logical, indicating whether remove avoidable attributes relations. , attribute removed relations keys can changed needed preserve given functional dependencies. constants_name scalar character, giving name relation created store constant attributes. generated relation name, changed, warning, ensure relations unique name. progress logical, whether display progress user dependency search discover. progress_file scalar character connection. progress non-zero, determines progress written , way file argument cat.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"relation_schema object, containing synthesised relation schemas.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"Bernstein's synthesis synthesis algorithm normalisation set dependencies set relations third normal form. implementation based version given referenced paper. implementation also includes common additional step, ensure resulting decomposition lossless, .e. relation satisfying given dependencies can perfectly reconstructed relations given decomposition. done adding additional relation, containing key original attributes, one already present. additional optional step, schemas checked \"avoidable\" attributes, can removed without loss information. Constant attributes, .e. whose determinant set empty, get assigned relation keys. Output independent order input dependencies: schemas sorted according simplest keys. Schemas sorted ensuring losslessness, removing avoidable attributes. result, neither optional step changes order schemas, ensuring losslessness can add extra schema end output vector.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"3NF synthesis algorithm: Bernstein P. . (1976) Synthesizing third normal form relations functional dependencies. ACM Trans. Database Syst., 1, 4, 277–298. Removal avoidable attributes: Ling T., Tompa F. W., Kameda T. (1981) improved third normal form relational databases. ACM Trans. Database Syst., 6, 2, 329–346.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/reference/synthesise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synthesise relation schemas from functional dependencies — synthesise","text":"","code":"# example 6.24 from The Theory of Relational Databases by David Maier # A <-> B, AC -> D, AC -> E, BD -> C deps <- functional_dependency(   list(     list(\"A\", \"B\"),     list(\"B\", \"A\"),     list(c(\"A\", \"C\"), \"D\"),     list(c(\"A\", \"C\"), \"E\"),     list(c(\"B\", \"D\"), \"C\")   ),   attrs_order = c(\"A\", \"B\", \"C\", \"D\", \"E\") ) synthesise(deps, remove_avoidable = FALSE) #> 2 relation schemas #> 5 attributes: A, B, C, D, E #> schema A: A, B #>   key 1: A #>   key 2: B #> schema A_C: A, C, B, D, E #>   key 1: A, C #>   key 2: B, D synthesise(deps, remove_avoidable = TRUE) #> 2 relation schemas #> 5 attributes: A, B, C, D, E #> schema A: A, B #>   key 1: A #>   key 2: B #> schema A_C: A, C, D, E #>   key 1: A, C #>   key 2: A, D"},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"breaking-changes-development-version","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"autodb (development version)","text":"accuracy argument now optional, defaulting one exact dependency search. reflects reduced focus approximate dependencies: main autodb function doesn’t allow anyway, new FDHits search algorithms can search exact dependencies. Arguments specific DFD algorithm moved back list, since lesser priority. includes accuracy parameter. skip_bijections argument now first DFD-specific arguments, since setting TRUE speeds search, non-accuracy parameters slow .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-development-version","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb (development version)","text":"package remaining package dependencies. still implicit dependency GraphViz, use gv export plotting code. Added new FDHits search algorithm alternative option DFD discover. relation database methods rename_attrs gv now run significantly quickly large data sets, due re-running key validity checks. Removed unnecessary validity checks database method reduce, runs quickly, especially databases large number records. Removed unnecessary validity checks database_schema database methods [. Removed unnecessary closure calculations normalise. normalise, synthesise, autoref, rejoin improved performance, due efficient closure checks. Added check parameter decompose, allow skipping checks data frame decompose one used create schema. Values now rounded significant digits, intended, rather decimal places. addition autodb, discover, df_equiv, values now also rounded insert decompose. relation error messages informative. Added main argument database method reduce.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-development-version","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb (development version)","text":"Fixed format method relation describe elements relations, rather schemas. Fixed autodb pass progress_file argument discover.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-231","dir":"Changelog","previous_headings":"","what":"autodb 2.3.1","title":"autodb 2.3.1","text":"CRAN release: 2025-03-19 minor changes tests, part re-submission CRAN.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-230","dir":"Changelog","previous_headings":"","what":"autodb 2.3.0","title":"autodb 2.3.0","text":"performance improvements, part re-submission CRAN.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-2-3-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 2.3.0","text":"Added convenience function called df_records, converting data frame list row values. sometimes useful data frames, e.g. checking rows data frame present another one. Improved run time database larger data sets, specifically validity checks data satisfying foreign key references. Improved run time create relation_schema database_schema, removing validity checks. input valid, redundant. Improved run time autodb, skipping removal extraneous attributes. done results discover, won’t .","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-2-3-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 2.3.0","text":"CRAN fixes DESCRIPTION. Fixes documentation.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-2-2-1","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 2.2.1","text":"CRAN fixes DESCRIPTION. Fixes documentation: PDF version manual now created successfully.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-220","dir":"Changelog","previous_headings":"","what":"autodb 2.2.0","title":"autodb 2.2.0","text":"Continuing efforts prepare submission CRAN.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-2-2-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 2.2.0","text":"Changed handling numerical/complex variables autodb, discover, df_equiv, round number significant digits. Due nature floating-point, definition functional dependency, floating-point values can’t compared using equality (==), .equal purposes functional dependency discovery / validation, result consistent different machines. , floating-point variables now rounded small level precision default processing. data frame loaded file, recommend reading numerical/complex variables character values (strings), ’s appropriate, avoid loss precision. df_equiv now checks rows exact matches, outside rounding mentioned . Previously, compared rows using match, gave control float precision. relation_schema, relation, database_schema, database now return name-based subset successfully given names exist object.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-211","dir":"Changelog","previous_headings":"","what":"autodb 2.1.1","title":"autodb 2.1.1","text":"minor changes documentation tests, allow package updates submission CRAN.","code":""},{"path":[]},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-2-1-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 2.1.0","text":"Added format .data.frame methods functional_dependency, relation_schema, database_schema, relation, database. allows columns data frame initial construction. ’m sure ’d want put data frame column, ’s consistent idea objects classes mostly treatable vectors. warned: don’t currently work tibbles. Added .character method functional_dependency. optional align_arrows argument can add padding one side, order make arrows align ’re printed different lines. options used align arrows print method, format method printed data frame column. Added == != implementations functional_dependency. ignore differences attrs_order: differently-ordered determinant sets considered equal. Added rename_attrs method functional_dependency. Added dependants argument discover, limit functional dependency search dependant given set column names, defaulting . significantly speed searches dependants interest. Added detset_limit argument discover/autodb, limits FD search look dependencies determinant set size given limit. DFD, usually doesn’t significantly reduce search time, won’t make worse. useful search algorithms implemented. Added argument insert, FALSE default. TRUE, insert returns error data insert doesn’t include attribute elements inserted , rather skipping elements. helps prevent accidental -ops. Running discover() autodb() progress = TRUE now keeps output display date using console-based version R. DFD now checks single-attribute keys, excludes determinants main search, potentially reducing search time.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-2-1-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 2.1.0","text":"Fixed gv account Graphviz HTML-like labels requiring certain characters, namely set “<>&, escaped Graphviz HTML-like labels, removed completely attribute values. Fixed df_equiv properly handle data frames zero columns duplicate rows. Fixed database_schema database, reference re-assignments, allow references given referee’s key attribute order.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-200","dir":"Changelog","previous_headings":"","what":"autodb 2.0.0","title":"autodb 2.0.0","text":"general theme version classes intermediate results: functional dependencies, schemas, databases now fleshed-classes, methods keep self-consistent. constructors, users create , instead generate given data frame.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"breaking-changes-2-0-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"autodb 2.0.0","text":"Renamed dfd discover, reflect generalisation allow use methods. moment, just includes DFD. Removed flatten exported functions, favour flattening functional dependencies dfd/discover instead. Since flatten usually called anyway, output readable since adding print method , little reason keep old dfd/discover output format, functional dependencies grouped dependant. Renamed cross_reference autoref, better reflect purpose generating foreign key references. Renamed normalise synthesise, reflect creating relation schemas, foreign key references. new function named normalise now calls wrapper synthesise autoref, since cases don’t need steps separately. Additionally, ensure_lossless now argument synthesise rather autoref: nature place put , since synthesise creates relations, autoref adds foreign key references. noted improvements, functional dependency objects now subsetting methods. particular, [[ method, code used [[ extract determinant sets dependants functional dependencies longer work. extracted new detset dependant functions instead. Similarly, database class subsetting methods, components must extracted records, keys, . database class longer assigns parents attribute relation, since duplicates foreign key reference information given references. database class longer name attribute. used name graph using gv function, now argument database method gv instead, bringing arguments line methods. relationships database_schema database objects now called references, better reflect foreign key constraints, stored format better reflects : instead element pair attributes foreign key, one element whole foreign key, containing involved attributes. Similarly, now printed format “child.{c1, c2, …} -> parent.{p1, p2, …}” instead “child.c1 -> parent.p1; child.c2 -> parent.p2; …”. cross_reference/autoref now defaults generating one foreign key reference per parent-child relation pair, rather keeping one first child key priority order. can result confusion plots, since references still plotted one attribute pair time.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-2-0-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 2.0.0","text":"Added functional_dependency class flattened functional dependency sets. attributes vector now stored attribute, dependencies can accessed simple list without list subsetting operators. also detset, dependant, attrs_order generic functions extracting relevant parts. detset dependant, particular, useful purposes filtering predicates. Added relation_schema class relational schema sets, returned synthesise. attributes keys now stored together named list, attrs_order vector attribute order stored attribute. functional_dependency, lets schemas accessed like vector. also merge_empty_keys combining schemas empty key, attrs, keys, attrs_order generic functions extracting relevant parts. Added database_schema class database schemas, returned normalise. inherits relation_schema, foreign key references additional references attribute. merge_empty_keys method conserves validity foreign key references. Additionally, names contained relation schemas changed using names<-, references changed use new names. Added relation class vectors relations containing data. Since database_schema just relation_schema vector foreign key references added, relation class added equivalent underlying vector database class. user package probably won’t need use . database now wrapper class around relation, adds foreign key references, handles separately methods. methods [, [[, – except functional_dependency – $ subsetting operators, along replacement equivalents, [<- etc., allow treating vectors relation schemas relations. Subsetting also removes foreign key references database_schema database objects longer relevant. methods prevent subsetting operators used access object’s internal components, many generic functions mentioned written allow access principled manner, requiring knowledge structure implemented. c method vector-like concatenation. two non-trivial aspects . Firstly, concatenating objects different attrs_order attributes, c merges orders keep consistent, possible. Secondly, database_schema database, foreign key references changed reflect changes made relation names keep unique. unique method vector-like removal duplicate schemas / relations. conserves validity foreign key references database_schema database objects. relation database objects, duplication doesn’t require records kept order. names<- method consistently changing relation (schema) names. particular, databases database schemas, ensures names also changed references. , except functional_dependency, rename_attrs method renaming attributes across whole object. renames schemas, relations, references, . Added create generic function, creating relation database objects relation_schema database_schema objects, respectively. created objects contain data. function roughly equivalent CREATE TABLE SQL, vectorised nature relation classes means several tables created . Added insert generic function relation database objects, takes data frame new data, inserts relation object whose attributes present new data. roughly equivalent SQL’s INSERT, works multiple relations , means ’s now way put data database outside decompose. Indeed, decompose now equivalent calling create, calling insert relations. Adjusted normalise prefer remove dependencies dependants determinant sets later table order, larger dependant sets. brings line similar decisions made package functions. Simplified internals dfd/discover improve computation time. Added skip_bijections option dfd/discover, speed functional dependency searches pairwise-equivalent attributes present.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-2-0-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 2.0.0","text":"Corrected vignette re: remove spurious dependencies . Corrected autodb documentation link page database format information. Corrected df_equiv work data.frame columns lists. Fixed dfd/discover treating similar numeric values equal, resulting data frames insertable schema. Fixed database checks handling doubles correctly. Specifically, foreign key reference checks involve merging tables together, merge operates doubles tolerance ’s set within internal method, merges can create duplicates need removed afterwards. Similarly, fixed rejoin case merges based doubles, sometimes resulting duplicates. Fixed normalise’s return output invariant given order functional_dependency input. Fixed normalise returning relations attributes wrong order certain cases remove_avoidable = TRUE. Fixed gv giving Graphviz code result incorrect diagrams: relation attribute names converted lower case, checked uniqueness afterwards. result incorrect foreign key references drawn. fix also accounts current bug Graphviz, edges HTML-style node ports ignore case port labels.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-110","dir":"Changelog","previous_headings":"","what":"autodb 1.1.0","title":"autodb 1.1.0","text":"Added NEWS.md file track changes package.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"improvements-1-1-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"autodb 1.1.0","text":"Added examples autodb, dfd, gv, rejoin. Added reference removing avoidable attributes enhanced third normal form. Changed decompose return error data.frame doesn’t satisfy functional dependencies implied schema. return error using decompose schema derived data.frame approximate dependencies included. Previously, using decompose dfd approximate dependencies result constructing database duplicate key values, since ’s currently handling approximate dependencies database construction, records ignored approximate dependencies kept. incorrect behaviour; decompose added back approximate dependencies package can properly handle . Made reduce generic, added method database schemas. Currently method requires explicitly naming main relations, rather inferring . Removed incorrect comment vignette needing foreign keys reconstruct original data frame database. Tidied nudge data documentation, improved commentary publication references vignette. Removed accuracy argument autodb, due approximate dependencies now returning error decompose.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"fixes-1-1-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"autodb 1.1.0","text":"Fixed print.database refer records instead rows. Fixed existing reference formatting. Fixed references missing-value implementation mockup vignette. Fixed bug normalise resulted relations duplicate keys. Fixed bug normalise, resulted schemas didn’t reproduce given functional dependencies. Fixed dfd’s data simplification step POSIXct datetimes, case two times differ standard/daylight-savings time (e.g. 1:00:00 EST vs. 1:00:00 EDT day). Fixed bug dfd cache = TRUE, data frame column names argument names paste can result error. Fixed decomposition tables zero columns (TABLE_DUM TABLE_DEE) allow lossless rejoin. Fixed bug output gv methods included Graphviz syntax errors given relations zero-length names. gv.data.frame now requires name non-empty; gv.database_schema gv.database replace zero-length names.","code":""},{"path":"https://charnelmouse.github.io/autodb/dev/news/index.html","id":"autodb-100","dir":"Changelog","previous_headings":"","what":"autodb 1.0.0","title":"autodb 1.0.0","text":"Initial version","code":""}]
